import { __decorate } from "tslib";
import { ComponentFactoryResolver, ComponentRef, Directive, EventEmitter, HostListener, Input, OnDestroy, OnInit, Output, ViewContainerRef } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { SwalComponent } from './swal.component';
/**
 * [swal] directive. It takes a value that defines the SweetAlert and can be of three types:
 *
 * 1) A simple array of two or three strings defining [title, text, icon] - the icon being optional, ex:
 *
 *    <button [swal]="['Title', 'Text']">Click me</button>
 *
 * 2) A native SweetAlert2 options object, ex:
 *
 *    <button [swal]="{ title: 'Title', text: 'Text' }">Click me</button>
 *
 * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:
 *
 *    <button [swal]="mySwal">Click me</button>
 *    <swal #mySwal title="Title" text="Text"></swal>
 */
import * as ɵngcc0 from '@angular/core';
let SwalDirective = class SwalDirective {
    constructor(viewContainerRef, resolver) {
        this.viewContainerRef = viewContainerRef;
        this.resolver = resolver;
        /**
         * Emits when the user clicks "Confirm".
         * Bears a value when using "input", resolved "preConfirm", etc.
         *
         * Example:
         *     <swal (confirm)="handleConfirm($event)"></swal>
         *
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
         * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
         * The reason is `undefined` when {@link dismiss} is called.
         *
         * Example:
         *     <swal (cancel)="handleCancel($event)"></swal>
         *
         *     public handleCancel(reason: DismissReason | undefined): void {
         *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
         *         // ... do something
         *     }
         */
        this.cancel = new EventEmitter();
    }
    /**
     * SweetAlert2 options or a SwalComponent instance.
     * See the class doc block for more informations.
     */
    set swal(options) {
        if (options instanceof SwalComponent) {
            this.swalInstance = options;
        }
        else if (isArrayOptions(options)) {
            this.swalOptions = {};
            [this.swalOptions.title, this.swalOptions.text, this.swalOptions.icon] = options;
        }
        else {
            this.swalOptions = options;
        }
        function isArrayOptions(value) {
            return Array.isArray(options);
        }
    }
    /**
     * OnInit lifecycle handler.
     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
     * (cancel) outputs to reemit on the directive.
     */
    ngOnInit() {
        if (!this.swalInstance) {
            const factory = this.resolver.resolveComponentFactory(SwalComponent);
            this.swalRef = this.viewContainerRef.createComponent(factory);
            this.swalInstance = this.swalRef.instance;
        }
    }
    /**
     * OnDestroy lifecycle handler.
     * Destroys the dynamically-created SwalComponent.
     */
    ngOnDestroy() {
        if (this.swalRef) {
            this.swalRef.destroy();
        }
    }
    /**
     * Click handler.
     * The directive listens for onclick events on its host element.
     * When this happens, it shows the <swal> attached to this directive.
     */
    onClick(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        event.stopPropagation();
        if (!this.swalInstance)
            return;
        if (this.swalOptions) {
            this.swalInstance.swalOptions = this.swalOptions;
        }
        const swalClosed = new Subject();
        this.swalInstance.confirm.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.confirm.emit(v));
        this.swalInstance.cancel.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.cancel.emit(v));
        this.swalInstance.fire().then(() => swalClosed.next());
    }
};
SwalDirective.ɵfac = function SwalDirective_Factory(t) { return new (t || SwalDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver)); };
SwalDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SwalDirective, selectors: [["", "swal", ""]], hostBindings: function SwalDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function SwalDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } }, inputs: { swal: "swal" }, outputs: { confirm: "confirm", cancel: "cancel" } });
SwalDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver }
];
__decorate([
    Input()
], SwalDirective.prototype, "swal", null);
__decorate([
    Output()
], SwalDirective.prototype, "confirm", void 0);
__decorate([
    Output()
], SwalDirective.prototype, "cancel", void 0);
__decorate([
    HostListener('click', ['$event'])
], SwalDirective.prototype, "onClick", null);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SwalDirective, [{
        type: Directive,
        args: [{
                selector: '[swal]'
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ComponentFactoryResolver }]; }, { confirm: [{
            type: Output
        }], cancel: [{
            type: Output
        }], swal: [{
            type: Input
        }], 
    /**
     * Click handler.
     * The directive listens for onclick events on its host element.
     * When this happens, it shows the <swal> attached to this directive.
     */
    onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();
export { SwalDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dhbC5kaXJlY3RpdmUuanMiLCJzb3VyY2VzIjpbIkBzd2VldGFsZXJ0Mi9uZ3gtc3dlZXRhbGVydDIvbGliL3N3YWwuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0gsd0JBQXdCLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFDL0csZ0JBQWdCLEVBQ25CLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNDLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUlILElBQWEsYUFBYSxHQUExQixNQUFhLGFBQWE7QUFBRyxJQW1FekIsWUFDcUIsZ0JBQWtDLEVBQ2xDLFFBQWtDO0FBQzNELFFBRnlCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7QUFBQyxRQUNuQyxhQUFRLEdBQVIsUUFBUSxDQUEwQjtBQUFDLFFBakR4RDtBQUNKO0FBQ0k7QUFFSDtBQUFXO0FBQ0k7QUFFSDtBQUFXO0FBQ0k7QUFHakI7QUFBaUIsV0FEckI7QUFDUCxRQUE4QixZQUFPLEdBQUcsSUFBSSxZQUFZLEVBQU8sQ0FBQztBQUNoRSxRQUNJO0FBQ0o7QUFDSTtBQUNJO0FBRUg7QUFDTDtBQUFvQjtBQUVIO0FBQVc7QUFDSTtBQUUvQjtBQUVrQjtBQUFpQixXQUQ3QjtBQUNQLFFBQThCLFdBQU0sR0FBRyxJQUFJLFlBQVksRUFBa0MsQ0FBQztBQUMxRixJQXVCSSxDQUFDO0FBQ0wsSUF0RUk7QUFDSjtBQUNBO0FBQ0EsT0FBTztB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RUFBRSxDQUFDLENBQUM7QUFDL0QsSUFBSSxDQUFDO0FBQ0wsQ0FBQzs7Ozt3RkFBQTtBQUNEO0FBQXVDLFlBckRJLGdCQUFnQjtBQUN6RCxZQUFpQyx3QkFBd0I7QUFBRztBQWhFakQ7QUFBYSxJQUFyQixLQUFLLEVBQUU7QUFBQyx5Q0FhUjtBQWFTO0FBQWEsSUFBdEIsTUFBTSxFQUFFO0FBQUMsOENBQWtEO0FBZWxEO0FBQWEsSUFBdEIsTUFBTSxFQUFFO0FBQUMsNkNBQTRFO0FBd0R0RjtBQUFhLElBRFosWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3RDLDRDQWlCSztBQXZIUSxhQUFhLG9CQUh6QixTQUFTLENBQUMsVUFDUCxRQUFRLEVBQUUsUUFBUTtLQUNyQixDQUFDLElBQ1csYUFBYSxDQXdIekI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQ0Q7QUFBQyxTQXpIWSxhQUFhO0FBQUkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQ29tcG9uZW50UmVmLCBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCxcbiAgICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IFN3YWwsIHsgU3dlZXRBbGVydEFycmF5T3B0aW9ucywgU3dlZXRBbGVydE9wdGlvbnMgfSBmcm9tICdzd2VldGFsZXJ0Mic7XG5pbXBvcnQgeyBTd2FsQ29tcG9uZW50IH0gZnJvbSAnLi9zd2FsLmNvbXBvbmVudCc7XG5cbi8qKlxuICogW3N3YWxdIGRpcmVjdGl2ZS4gSXQgdGFrZXMgYSB2YWx1ZSB0aGF0IGRlZmluZXMgdGhlIFN3ZWV0QWxlcnQgYW5kIGNhbiBiZSBvZiB0aHJlZSB0eXBlczpcbiAqXG4gKiAxKSBBIHNpbXBsZSBhcnJheSBvZiB0d28gb3IgdGhyZWUgc3RyaW5ncyBkZWZpbmluZyBbdGl0bGUsIHRleHQsIGljb25dIC0gdGhlIGljb24gYmVpbmcgb3B0aW9uYWwsIGV4OlxuICpcbiAqICAgIDxidXR0b24gW3N3YWxdPVwiWydUaXRsZScsICdUZXh0J11cIj5DbGljayBtZTwvYnV0dG9uPlxuICpcbiAqIDIpIEEgbmF0aXZlIFN3ZWV0QWxlcnQyIG9wdGlvbnMgb2JqZWN0LCBleDpcbiAqXG4gKiAgICA8YnV0dG9uIFtzd2FsXT1cInsgdGl0bGU6ICdUaXRsZScsIHRleHQ6ICdUZXh0JyB9XCI+Q2xpY2sgbWU8L2J1dHRvbj5cbiAqXG4gKiAzKSBBIHJlZmVyZW5jZSB0byBhbiBleGlzdGluZyBTd2FsQ29tcG9uZW50IGluc3RhbmNlIGZvciBtb3JlIGFkdmFuY2VkIHVzZXMsIGV4OlxuICpcbiAqICAgIDxidXR0b24gW3N3YWxdPVwibXlTd2FsXCI+Q2xpY2sgbWU8L2J1dHRvbj5cbiAqICAgIDxzd2FsICNteVN3YWwgdGl0bGU9XCJUaXRsZVwiIHRleHQ9XCJUZXh0XCI+PC9zd2FsPlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tzd2FsXSdcbn0pXG5leHBvcnQgY2xhc3MgU3dhbERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICAvKipcbiAgICAgKiBTd2VldEFsZXJ0MiBvcHRpb25zIG9yIGEgU3dhbENvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgKiBTZWUgdGhlIGNsYXNzIGRvYyBibG9jayBmb3IgbW9yZSBpbmZvcm1hdGlvbnMuXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHNldCBzd2FsKG9wdGlvbnM6IFN3YWxDb21wb25lbnQgfCBTd2VldEFsZXJ0T3B0aW9ucyB8IFN3ZWV0QWxlcnRBcnJheU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBTd2FsQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLnN3YWxJbnN0YW5jZSA9IG9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheU9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhbE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIFt0aGlzLnN3YWxPcHRpb25zLnRpdGxlLCB0aGlzLnN3YWxPcHRpb25zLnRleHQsIHRoaXMuc3dhbE9wdGlvbnMuaWNvbl0gPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zd2FsT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc0FycmF5T3B0aW9ucyh2YWx1ZTogYW55KTogdmFsdWUgaXMgU3dlZXRBbGVydEFycmF5T3B0aW9ucyB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIFwiQ29uZmlybVwiLlxuICAgICAqIEJlYXJzIGEgdmFsdWUgd2hlbiB1c2luZyBcImlucHV0XCIsIHJlc29sdmVkIFwicHJlQ29uZmlybVwiLCBldGMuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgICA8c3dhbCAoY29uZmlybSk9XCJoYW5kbGVDb25maXJtKCRldmVudClcIj48L3N3YWw+XG4gICAgICpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNvbmZpcm0oZW1haWw6IHN0cmluZyk6IHZvaWQge1xuICAgICAqICAgICAgICAgLy8gLi4uIHNhdmUgdXNlciBlbWFpbFxuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyByZWFkb25seSBjb25maXJtID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNhbmNlbFwiLCBvciBkaXNtaXNzZXMgdGhlIG1vZGFsIGJ5IGFueSBvdGhlciBhbGxvd2VkIHdheS5cbiAgICAgKiBCeSBkZWZhdWx0LCBpdCB3aWxsIGVtaXQgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByZWFzb24gZm9yIHdoaWNoIHRoZSBTd2VldEFsZXJ0IGhhcyBiZWVuIGNsb3NlZC5cbiAgICAgKiBUaGUgcmVhc29uIGlzIGB1bmRlZmluZWRgIHdoZW4ge0BsaW5rIGRpc21pc3N9IGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIDxzd2FsIChjYW5jZWwpPVwiaGFuZGxlQ2FuY2VsKCRldmVudClcIj48L3N3YWw+XG4gICAgICpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNhbmNlbChyZWFzb246IERpc21pc3NSZWFzb24gfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICAgKiAgICAgICAgIC8vIHJlYXNvbiBjYW4gYmUgJ2NhbmNlbCcsICdvdmVybGF5JywgJ2Nsb3NlJywgJ3RpbWVyJyBvciB1bmRlZmluZWQuXG4gICAgICogICAgICAgICAvLyAuLi4gZG8gc29tZXRoaW5nXG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIHJlYWRvbmx5IGNhbmNlbCA9IG5ldyBFdmVudEVtaXR0ZXI8U3dhbC5EaXNtaXNzUmVhc29uIHwgdW5kZWZpbmVkPigpO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgdXNlciBkb2VzIG5vdCBwcm92aWRlcyBhIFN3YWxDb21wb25lbnQgaW5zdGFuY2UsIHdlIGNyZWF0ZSBpdCBvbi10aGUtZmx5IGFuZCBhc3NpZ24gdGhlIHBsYWluLW9iamVjdFxuICAgICAqIG9wdGlvbnMgdG8gaXQuXG4gICAgICogVGhpcyBmaWVsZHMga2VlcHMgYSByZWZlcmVuY2UgdG8gdGhlIGR5bmFtaWNhbGx5LWNyZWF0ZWQgPHN3YWw+LCB0byBkZXN0cm95IGl0IGFsb25nIHRoaXMgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHByaXZhdGUgc3dhbFJlZj86IENvbXBvbmVudFJlZjxTd2FsQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICAqIEFuIGluc3RhbmNlIG9mIHRoZSA8c3dhbD4gY29tcG9uZW50IHRoYXQgdGhpcyBkaXJlY3RpdmUgY29udHJvbHMuXG4gICAgICogQ291bGQgYmUgYW4gaW5zdGFuY2UgcGFzc2VkIGJ5IHRoZSB1c2VyLCBvdGhlcndpc2UgaXQncyB0aGUgaW5zdGFuY2Ugd2UndmUgZHluYW1pY2FsbHkgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN3YWxJbnN0YW5jZT86IFN3YWxDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgbmF0aXZlIFN3ZWV0QWxlcnQyIG9wdGlvbnMuXG4gICAgICogRW1wdHkgd2hlbiB0aGUgdXNlciBwYXNzZWQgYW4gZXhpc3RpbmcgU3dhbENvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN3YWxPcHRpb25zPzogU3dlZXRBbGVydE9wdGlvbnM7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSByZXNvbHZlcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25Jbml0IGxpZmVjeWNsZSBoYW5kbGVyLlxuICAgICAqIENyZWF0ZXMgYSBTd2FsQ29tcG9uZW50IGluc3RhbmNlIGlmIHRoZSB1c2VyIGRpZG4ndCBwcm92aWRlZCBvbmUgYW5kIGJpbmRzIG9uIHRoYXQgY29tcG9uZW50IChjb25maXJtKSBhbmRcbiAgICAgKiAoY2FuY2VsKSBvdXRwdXRzIHRvIHJlZW1pdCBvbiB0aGUgZGlyZWN0aXZlLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLnN3YWxJbnN0YW5jZSkge1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoU3dhbENvbXBvbmVudCk7XG5cbiAgICAgICAgICAgIHRoaXMuc3dhbFJlZiA9IHRoaXMudmlld0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoZmFjdG9yeSk7XG4gICAgICAgICAgICB0aGlzLnN3YWxJbnN0YW5jZSA9IHRoaXMuc3dhbFJlZi5pbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uRGVzdHJveSBsaWZlY3ljbGUgaGFuZGxlci5cbiAgICAgKiBEZXN0cm95cyB0aGUgZHluYW1pY2FsbHktY3JlYXRlZCBTd2FsQ29tcG9uZW50LlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc3dhbFJlZikge1xuICAgICAgICAgICAgdGhpcy5zd2FsUmVmLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsaWNrIGhhbmRsZXIuXG4gICAgICogVGhlIGRpcmVjdGl2ZSBsaXN0ZW5zIGZvciBvbmNsaWNrIGV2ZW50cyBvbiBpdHMgaG9zdCBlbGVtZW50LlxuICAgICAqIFdoZW4gdGhpcyBoYXBwZW5zLCBpdCBzaG93cyB0aGUgPHN3YWw+IGF0dGFjaGVkIHRvIHRoaXMgZGlyZWN0aXZlLlxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSlcbiAgICBwdWJsaWMgb25DbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnN3YWxJbnN0YW5jZSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0aGlzLnN3YWxPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN3YWxJbnN0YW5jZS5zd2FsT3B0aW9ucyA9IHRoaXMuc3dhbE9wdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzd2FsQ2xvc2VkID0gbmV3IFN1YmplY3QoKTtcblxuICAgICAgICB0aGlzLnN3YWxJbnN0YW5jZS5jb25maXJtLmFzT2JzZXJ2YWJsZSgpLnBpcGUodGFrZVVudGlsKHN3YWxDbG9zZWQpKS5zdWJzY3JpYmUodiA9PiB0aGlzLmNvbmZpcm0uZW1pdCh2KSk7XG4gICAgICAgIHRoaXMuc3dhbEluc3RhbmNlLmNhbmNlbC5hc09ic2VydmFibGUoKS5waXBlKHRha2VVbnRpbChzd2FsQ2xvc2VkKSkuc3Vic2NyaWJlKHYgPT4gdGhpcy5jYW5jZWwuZW1pdCh2KSk7XG5cbiAgICAgICAgdGhpcy5zd2FsSW5zdGFuY2UuZmlyZSgpLnRoZW4oKCkgPT4gc3dhbENsb3NlZC5uZXh0KCkpO1xuICAgIH1cbn1cbiJdfQ==