import { __awaiter, __decorate, __param } from "tslib";
import { ChangeDetectionStrategy, Component, EventEmitter, Inject, Input, Output } from '@angular/core';
import { dismissOnDestroyToken, fireOnInitToken } from './di';
import { SweetAlert2LoaderService } from './sweetalert2-loader.service';
/**
 * <swal> component. See the README.md for usage.
 *
 * It contains a bunch of @Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
 * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
 * to SweetAlert2, but also is type-safe.
 *
 * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many @Inputs,
 *     take a look at [swalOptions], that lets you pass a full {@link SweetAlertOptions} object.
 *
 * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.
 *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.
 *     If you are really concerned about performance and/or don't care about the API and its convenient integration
 *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)
 *
 * /!\ Some SweetAlert options aren't @Inputs but @Outputs: onBeforeOpen, onOpen, onClose, onAfterClose and onDestroy
 *     (but without "on*" prefix to respect community standards).
 *     However, preConfirm and inputValidator are still @Inputs because there are not event handlers, there can't be
 *     multiple listeners and we need the values they can/must return.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './sweetalert2-loader.service';
let SwalComponent = class SwalComponent {
    constructor(sweetAlert2Loader, moduleLevelFireOnInit, moduleLevelDismissOnDestroy) {
        this.sweetAlert2Loader = sweetAlert2Loader;
        this.moduleLevelFireOnInit = moduleLevelFireOnInit;
        this.moduleLevelDismissOnDestroy = moduleLevelDismissOnDestroy;
        /**
         * Emits an event when the modal DOM element has been created.
         * Useful to perform DOM mutations before the modal is shown.
         */
        this.beforeOpen = new EventEmitter();
        /**
         * Emits an event when the modal is shown.
         */
        this.open = new EventEmitter();
        /**
         * Emits an event when the modal DOM is rendered.
         */
        this.render = new EventEmitter();
        /**
         * Emits an event when the modal will be closed.
         * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
         */
        this.close = new EventEmitter();
        /**
         * Emits an event after the modal had been closed.
         * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
         */
        this.afterClose = new EventEmitter();
        /**
         * Emits an event after the modal had been closed.
         * The difference between {@link destroy} and {@link afterClose} is that the latter is called for user interactions
         * only (clicks), whereas {@link destroy} is always called, both for user interactions and popup being closed by
         * another popup.
         */
        this.destroy = new EventEmitter();
        /**
         * Emits when the user clicks "Confirm".
         * Bears a value when using "input", resolved "preConfirm", etc.
         *
         * Example:
         *     <swal (confirm)="handleConfirm($event)"></swal>
         *
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
         * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
         * The reason is `undefined` when {@link dismiss} is called.
         *
         * Example:
         *     <swal (cancel)="handleCancel($event)"></swal>
         *
         *     public handleCancel(reason: DismissReason | undefined): void {
         *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
         *         // ... do something
         *     }
         */
        this.cancel = new EventEmitter();
        /**
         * This Set retains the properties that have been changed from @Inputs, so we can know precisely
         * what options we have to send to {@link Swal.fire}.
         */
        this.touchedProps = new Set();
        /**
         * A function of signature `(propName: string): void` that adds a given property name to the list of
         * touched properties, ie. {@link touchedProps}.
         */
        this.markTouched = this.touchedProps.add.bind(this.touchedProps);
        /**
         * Is the SweetAlert2 modal represented by this component currently opened?
         */
        this.isCurrentlyShown = false;
    }
    /**
     * An object of SweetAlert2 native options, useful if:
     *  - you don't want to use the @Inputs for practical/philosophical reasons ;
     *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
     *
     * /!\ Please note that setting this property does NOT erase what has been set before unless you specify the
     *     previous properties you want to erase again.
     *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.
     *
     * /!\ Be aware that the options defined in this object will override the @Inputs of the same name.
     */
    set swalOptions(options) {
        //=> Update properties
        Object.assign(this, options);
        //=> Mark changed properties as touched
        const touchedKeys = Object.keys(options);
        touchedKeys.forEach(this.markTouched);
    }
    /**
     * Computes the options object that will get passed to SweetAlert2.
     * Only the properties that have been set at least once on this component will be returned.
     * Mostly for internal usage.
     */
    get swalOptions() {
        //=> We will compute the options object based on the option keys that are known to have changed.
        //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially
        //   avoiding side effects.
        return [...this.touchedProps].reduce((obj, key) => (Object.assign(Object.assign({}, obj), { [key]: this[key] })), {});
    }
    set swalVisible(visible) {
        visible ? this.fire() : this.dismiss();
    }
    get swalVisible() {
        return this.isCurrentlyShown;
    }
    /**
     * Angular lifecycle hook.
     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
     * causing no delay.
     */
    ngOnInit() {
        //=> Preload SweetAlert2 library in case this component is activated.
        this.sweetAlert2Loader.preloadSweetAlertLibrary();
    }
    /**
     * Angular lifecycle hook.
     * Fires the modal, if the component or module is configured to do so.
     */
    ngAfterViewInit() {
        const fireOnInit = this.swalFireOnInit === undefined
            ? this.moduleLevelFireOnInit
            : this.swalFireOnInit;
        fireOnInit && this.fire();
    }
    /**
     * Angular lifecycle hook.
     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
     */
    ngOnChanges(changes) {
        //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can
        //   send it with the next fire() or update() calls.
        Object.keys(changes)
            //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter
            .filter((key) => !key.startsWith('swal'))
            .forEach(this.markTouched);
        //=> Eventually trigger re-render if the modal is open.
        void this.update();
    }
    /**
     * Angular lifecycle hook.
     * Closes the SweetAlert when the component is destroyed.
     */
    ngOnDestroy() {
        //=> Release the modal if the component is destroyed and if that behaviour is not disabled.
        const dismissOnDestroy = this.swalDismissOnDestroy === undefined
            ? this.moduleLevelDismissOnDestroy
            : this.swalDismissOnDestroy;
        dismissOnDestroy && this.dismiss();
    }
    /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
     */
    fire() {
        return __awaiter(this, void 0, void 0, function* () {
            const swal = yield this.sweetAlert2Loader.swal;
            const userOptions = this.swalOptions;
            //=> Build the SweetAlert2 options
            const options = Object.assign(Object.assign({}, userOptions), { 
                //=> Handle modal lifecycle events
                onBeforeOpen: composeHook(userOptions.onBeforeOpen, (modalElement) => {
                    this.beforeOpen.emit({ modalElement });
                }), onOpen: composeHook(userOptions.onOpen, (modalElement) => {
                    this.isCurrentlyShown = true;
                    this.open.emit({ modalElement });
                }), onRender: composeHook(userOptions.onRender, (modalElement) => {
                    this.render.emit({ modalElement });
                }), onClose: composeHook(userOptions.onClose, (modalElement) => {
                    this.isCurrentlyShown = false;
                    this.close.emit({ modalElement });
                }), onAfterClose: composeHook(userOptions.onAfterClose, () => {
                    this.afterClose.emit();
                }), onDestroy: composeHook(userOptions.onDestroy, () => {
                    this.destroy.emit();
                }) });
            //=> Show the Swal! And wait for confirmation or dimissal.
            const result = yield swal.fire(options);
            //=> Emit on (confirm) or (cancel)
            if ('value' in result) {
                this.confirm.emit(result.value);
            }
            else {
                this.cancel.emit(result.dismiss);
            }
            return result;
            function composeHook(userHook, libHook) {
                return (...args) => (libHook(...args), userHook === null || userHook === void 0 ? void 0 : userHook(...args));
            }
        });
    }
    /**
     * Closes the modal, if opened.
     *
     * @param result The value that the modal will resolve with, triggering either (confirm) or (cancel).
     *               If the argument is not passed, (dimiss) will emit `undefined`.
     *               See {@link Swal.close}
     */
    dismiss(result) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isCurrentlyShown)
                return;
            const swal = yield this.sweetAlert2Loader.swal;
            swal.close(result);
        });
    }
    /**
     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
     * If the modal is not opened, the component options will simply be updated and that's it.
     *
     * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
     *
     * @param options
     */
    update(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options) {
                this.swalOptions = options;
            }
            if (!this.isCurrentlyShown)
                return;
            const swal = yield this.sweetAlert2Loader.swal;
            const allOptions = this.swalOptions;
            const updatableOptions = Object.keys(allOptions)
                .filter(swal.isUpdatableParameter)
                .reduce((obj, key) => (Object.assign(Object.assign({}, obj), { [key]: allOptions[key] })), {});
            swal.update(updatableOptions);
        });
    }
};
SwalComponent.ɵfac = function SwalComponent_Factory(t) { return new (t || SwalComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.SweetAlert2LoaderService), ɵngcc0.ɵɵdirectiveInject(fireOnInitToken), ɵngcc0.ɵɵdirectiveInject(dismissOnDestroyToken)); };
SwalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SwalComponent, selectors: [["swal"]], inputs: { swalOptions: "swalOptions", swalVisible: "swalVisible", title: "title", titleText: "titleText", text: "text", html: "html", footer: "footer", icon: "icon", iconHtml: "iconHtml", backdrop: "backdrop", toast: "toast", target: "target", input: "input", width: "width", padding: "padding", background: "background", position: "position", grow: "grow", showClass: "showClass", hideClass: "hideClass", customClass: "customClass", timer: "timer", timerProgressBar: "timerProgressBar", animation: "animation", heightAuto: "heightAuto", allowOutsideClick: "allowOutsideClick", allowEscapeKey: "allowEscapeKey", allowEnterKey: "allowEnterKey", stopKeydownPropagation: "stopKeydownPropagation", keydownListenerCapture: "keydownListenerCapture", showConfirmButton: "showConfirmButton", showCancelButton: "showCancelButton", confirmButtonText: "confirmButtonText", cancelButtonText: "cancelButtonText", confirmButtonColor: "confirmButtonColor", cancelButtonColor: "cancelButtonColor", confirmButtonAriaLabel: "confirmButtonAriaLabel", cancelButtonAriaLabel: "cancelButtonAriaLabel", buttonsStyling: "buttonsStyling", reverseButtons: "reverseButtons", focusConfirm: "focusConfirm", focusCancel: "focusCancel", showCloseButton: "showCloseButton", closeButtonHtml: "closeButtonHtml", closeButtonAriaLabel: "closeButtonAriaLabel", showLoaderOnConfirm: "showLoaderOnConfirm", preConfirm: "preConfirm", imageUrl: "imageUrl", imageWidth: "imageWidth", imageHeight: "imageHeight", imageAlt: "imageAlt", inputPlaceholder: "inputPlaceholder", inputValue: "inputValue", inputOptions: "inputOptions", inputAutoTrim: "inputAutoTrim", inputAttributes: "inputAttributes", inputValidator: "inputValidator", validationMessage: "validationMessage", progressSteps: "progressSteps", currentProgressStep: "currentProgressStep", progressStepsDistance: "progressStepsDistance", scrollbarPadding: "scrollbarPadding", swalFireOnInit: "swalFireOnInit", swalDismissOnDestroy: "swalDismissOnDestroy" }, outputs: { beforeOpen: "beforeOpen", open: "open", render: "render", close: "close", afterClose: "afterClose", destroy: "destroy", confirm: "confirm", cancel: "cancel" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function SwalComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SwalComponent.ctorParameters = () => [
    { type: SweetAlert2LoaderService },
    { type: Boolean, decorators: [{ type: Inject, args: [fireOnInitToken,] }] },
    { type: Boolean, decorators: [{ type: Inject, args: [dismissOnDestroyToken,] }] }
];
__decorate([
    Input()
], SwalComponent.prototype, "title", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "titleText", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "text", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "html", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "footer", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "icon", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "iconHtml", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "backdrop", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "toast", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "target", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "input", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "width", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "padding", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "background", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "position", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "grow", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "showClass", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "hideClass", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "customClass", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "timer", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "timerProgressBar", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "animation", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "heightAuto", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "allowOutsideClick", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "allowEscapeKey", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "allowEnterKey", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "stopKeydownPropagation", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "keydownListenerCapture", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "showConfirmButton", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "showCancelButton", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "confirmButtonText", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "cancelButtonText", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "confirmButtonColor", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "cancelButtonColor", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "confirmButtonAriaLabel", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "cancelButtonAriaLabel", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "buttonsStyling", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "reverseButtons", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "focusConfirm", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "focusCancel", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "showCloseButton", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "closeButtonHtml", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "closeButtonAriaLabel", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "showLoaderOnConfirm", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "preConfirm", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "imageUrl", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "imageWidth", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "imageHeight", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "imageAlt", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "inputPlaceholder", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "inputValue", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "inputOptions", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "inputAutoTrim", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "inputAttributes", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "inputValidator", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "validationMessage", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "progressSteps", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "currentProgressStep", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "progressStepsDistance", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "scrollbarPadding", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "swalOptions", null);
__decorate([
    Input()
], SwalComponent.prototype, "swalFireOnInit", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "swalDismissOnDestroy", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "swalVisible", null);
__decorate([
    Output()
], SwalComponent.prototype, "beforeOpen", void 0);
__decorate([
    Output()
], SwalComponent.prototype, "open", void 0);
__decorate([
    Output()
], SwalComponent.prototype, "render", void 0);
__decorate([
    Output()
], SwalComponent.prototype, "close", void 0);
__decorate([
    Output()
], SwalComponent.prototype, "afterClose", void 0);
__decorate([
    Output()
], SwalComponent.prototype, "destroy", void 0);
__decorate([
    Output()
], SwalComponent.prototype, "confirm", void 0);
__decorate([
    Output()
], SwalComponent.prototype, "cancel", void 0);
SwalComponent = __decorate([ __param(1, Inject(fireOnInitToken)),
    __param(2, Inject(dismissOnDestroyToken))
], SwalComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SwalComponent, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'swal',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc1.SweetAlert2LoaderService }, { type: Boolean, decorators: [{
                type: Inject,
                args: [fireOnInitToken]
            }] }, { type: Boolean, decorators: [{
                type: Inject,
                args: [dismissOnDestroyToken]
            }] }]; }, { beforeOpen: [{
            type: Output
        }], open: [{
            type: Output
        }], render: [{
            type: Output
        }], close: [{
            type: Output
        }], afterClose: [{
            type: Output
        }], destroy: [{
            type: Output
        }], confirm: [{
            type: Output
        }], cancel: [{
            type: Output
        }], swalOptions: [{
            type: Input
        }], swalVisible: [{
            type: Input
        }], title: [{
            type: Input
        }], titleText: [{
            type: Input
        }], text: [{
            type: Input
        }], html: [{
            type: Input
        }], footer: [{
            type: Input
        }], icon: [{
            type: Input
        }], iconHtml: [{
            type: Input
        }], backdrop: [{
            type: Input
        }], toast: [{
            type: Input
        }], target: [{
            type: Input
        }], input: [{
            type: Input
        }], width: [{
            type: Input
        }], padding: [{
            type: Input
        }], background: [{
            type: Input
        }], position: [{
            type: Input
        }], grow: [{
            type: Input
        }], showClass: [{
            type: Input
        }], hideClass: [{
            type: Input
        }], customClass: [{
            type: Input
        }], timer: [{
            type: Input
        }], timerProgressBar: [{
            type: Input
        }], animation: [{
            type: Input
        }], heightAuto: [{
            type: Input
        }], allowOutsideClick: [{
            type: Input
        }], allowEscapeKey: [{
            type: Input
        }], allowEnterKey: [{
            type: Input
        }], stopKeydownPropagation: [{
            type: Input
        }], keydownListenerCapture: [{
            type: Input
        }], showConfirmButton: [{
            type: Input
        }], showCancelButton: [{
            type: Input
        }], confirmButtonText: [{
            type: Input
        }], cancelButtonText: [{
            type: Input
        }], confirmButtonColor: [{
            type: Input
        }], cancelButtonColor: [{
            type: Input
        }], confirmButtonAriaLabel: [{
            type: Input
        }], cancelButtonAriaLabel: [{
            type: Input
        }], buttonsStyling: [{
            type: Input
        }], reverseButtons: [{
            type: Input
        }], focusConfirm: [{
            type: Input
        }], focusCancel: [{
            type: Input
        }], showCloseButton: [{
            type: Input
        }], closeButtonHtml: [{
            type: Input
        }], closeButtonAriaLabel: [{
            type: Input
        }], showLoaderOnConfirm: [{
            type: Input
        }], preConfirm: [{
            type: Input
        }], imageUrl: [{
            type: Input
        }], imageWidth: [{
            type: Input
        }], imageHeight: [{
            type: Input
        }], imageAlt: [{
            type: Input
        }], inputPlaceholder: [{
            type: Input
        }], inputValue: [{
            type: Input
        }], inputOptions: [{
            type: Input
        }], inputAutoTrim: [{
            type: Input
        }], inputAttributes: [{
            type: Input
        }], inputValidator: [{
            type: Input
        }], validationMessage: [{
            type: Input
        }], progressSteps: [{
            type: Input
        }], currentProgressStep: [{
            type: Input
        }], progressStepsDistance: [{
            type: Input
        }], scrollbarPadding: [{
            type: Input
        }], swalFireOnInit: [{
            type: Input
        }], swalDismissOnDestroy: [{
            type: Input
        }] }); })();
export { SwalComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dhbC5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIkBzd2VldGFsZXJ0Mi9uZ3gtc3dlZXRhbGVydDIvbGliL3N3YWwuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ1ksdUJBQXVCLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUM5RSxNQUFNLEVBQ1QsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLHFCQUFxQixFQUFFLGVBQWUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUU5RCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQU9ILElBQWEsYUFBYSxHQUExQixNQUFhLGFBQWE7QUFBRyxJQXFOekIsWUFDcUIsaUJBQTJDLEVBQ2xCLHFCQUE4QixFQUN4QiwyQkFBb0M7QUFDNUYsUUFIeUIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUEwQjtBQUFDLFFBQ25CLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBUztBQUFDLFFBQ3pCLGdDQUEyQixHQUEzQiwyQkFBMkIsQ0FBUztBQUFDLFFBNUZ6RjtBQUNKO0FBQ0k7QUFFSixXQURPO0FBQ1AsUUFDb0IsZUFBVSxHQUFHLElBQUksWUFBWSxFQUEwQixDQUFDO0FBQzVFLFFBQ0k7QUFDSjtBQUNJLFdBQUc7QUFDUCxRQUNvQixTQUFJLEdBQUcsSUFBSSxZQUFZLEVBQW9CLENBQUM7QUFDaEUsUUFDSTtBQUNKO0FBQ0ksV0FBRztBQUNQLFFBQ29CLFdBQU0sR0FBRyxJQUFJLFlBQVksRUFBc0IsQ0FBQztBQUNwRSxRQUNJO0FBQ0o7QUFDSTtBQUVKLFdBRE87QUFDUCxRQUNvQixVQUFLLEdBQUcsSUFBSSxZQUFZLEVBQXFCLENB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LEtBQUssRUFBRTtBQUFDLDJDQUF1QztBQUN2QztBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDZDQUEyQztBQUMzQztBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDJDQUF1QztBQUN2QztBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLCtDQUErQztBQUMvQztBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLCtDQUErQztBQUMvQztBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDRDQUF5QztBQUN6QztBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDZDQUEyQztBQUMzQztBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDRDQUF5QztBQUN6QztBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDRDQUF5QztBQUN6QztBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDhDQUE2QztBQUM3QztBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLGlEQUFtRDtBQUNuRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLCtDQUErQztBQUMvQztBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDJDQUF1QztBQUN2QztBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLGdEQUFpRDtBQUNqRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLGdEQUFpRDtBQUNqRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLGtEQUFxRDtBQUNyRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDRDQUF5QztBQUN6QztBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHVEQUErRDtBQUUvRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLGdEQUFpRDtBQUNqRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLGlEQUFtRDtBQUNuRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHdEQUFpRTtBQUNqRTtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHFEQUEyRDtBQUMzRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLG9EQUF5RDtBQUN6RDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDZEQUEyRTtBQUMzRTtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDZEQUEyRTtBQUMzRTtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHdEQUFpRTtBQUNqRTtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHVEQUErRDtBQUMvRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHdEQUFpRTtBQUNqRTtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHVEQUErRDtBQUMvRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHlEQUFtRTtBQUNuRTtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHdEQUFpRTtBQUNqRTtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDZEQUEyRTtBQUMzRTtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDREQUF5RTtBQUN6RTtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHFEQUEyRDtBQUMzRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHFEQUEyRDtBQUMzRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLG1EQUF1RDtBQUN2RDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLGtEQUFxRDtBQUNyRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHNEQUE2RDtBQUM3RDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHNEQUE2RDtBQUM3RDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDJEQUF1RTtBQUN2RTtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDBEQUFxRTtBQUNyRTtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLGlEQUFtRDtBQUNuRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLCtDQUErQztBQUMvQztBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLGlEQUFtRDtBQUNuRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLGtEQUFxRDtBQUNyRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLCtDQUErQztBQUMvQztBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHVEQUErRDtBQUMvRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLGlEQUFtRDtBQUNuRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLG1EQUF1RDtBQUN2RDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLG9EQUF5RDtBQUN6RDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHNEQUE2RDtBQUM3RDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHFEQUEyRDtBQUMzRDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHdEQUFpRTtBQUNqRTtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLG9EQUF5RDtBQUN6RDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDBEQUFxRTtBQUNyRTtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDREQUF5RTtBQUN6RTtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHVEQUErRDtBQWN4RTtBQUFhLElBRFosS0FBSyxFQUFFO0FBQ1osZ0RBT0s7QUF3QkQ7QUFBYSxJQURaLEtBQUssRUFBRTtBQUNaLHFEQUFvQztBQU9oQztBQUFhLElBRFosS0FBSyxFQUFFO0FBQ1osMkRBQTBDO0FBR3RDO0FBQWEsSUFEWixLQUFLLEVBQUU7QUFDWixnREFFSztBQVdEO0FBQWEsSUFEWixNQUFNLEVBQUU7QUFDYixpREFBNEU7QUFNeEU7QUFBYSxJQURaLE1BQU0sRUFBRTtBQUNiLDJDQUFnRTtBQU01RDtBQUFhLElBRFosTUFBTSxFQUFFO0FBQ2IsNkNBQW9FO0FBT2hFO0FBQWEsSUFEWixNQUFNLEVBQUU7QUFDYiw0Q0FBa0U7QUFPOUQ7QUFBYSxJQURaLE1BQU0sRUFBRTtBQUNiLGlEQUEwRDtBQVN0RDtBQUFhLElBRFosTUFBTSxFQUFFO0FBQ2IsOENBQXVEO0FBY25EO0FBQWEsSUFEWixNQUFNLEVBQUU7QUFDYiw4Q0FBc0Q7QUFnQmxEO0FBQWEsSUFEWixNQUFNLEVBQUU7QUFDYiw2Q0FBZ0Y7QUFsTW5FLGFBQWEsb0JBTnpCLFNBQVMsQ0FBQyxVQUNQLHpCQUtBLENBdU5LLFdBQUEsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFBO2lDQTVOa0IsU0FDOUMsMUNBMk44QixJQUN6QixXQUFBLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFBO0lBNU4xQixFQUFFLE1BQU0sWkE0Tm1CLEdBeE4xQixhQUFhLENBbVh6QjtHQXRYRyxRQUFRLEVBQUUsRUFBRSxVQUNaLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQztBQUFNLE1BQ2xELENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBcVhGO0FBQUMsU0FwWFksYUFBYTtBQUFJIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBBZnRlclZpZXdJbml0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIEluamVjdCwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsXG4gICAgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IFN3YWwsIHsgU3dlZXRBbGVydE9wdGlvbnMsIFN3ZWV0QWxlcnRSZXN1bHQsIFN3ZWV0QWxlcnRVcGRhdGFibGVQYXJhbWV0ZXJzIH0gZnJvbSAnc3dlZXRhbGVydDInO1xuaW1wb3J0IHsgZGlzbWlzc09uRGVzdHJveVRva2VuLCBmaXJlT25Jbml0VG9rZW4gfSBmcm9tICcuL2RpJztcbmltcG9ydCAqIGFzIGV2ZW50cyBmcm9tICcuL3N3YWwtZXZlbnRzJztcbmltcG9ydCB7IFN3ZWV0QWxlcnQyTG9hZGVyU2VydmljZSB9IGZyb20gJy4vc3dlZXRhbGVydDItbG9hZGVyLnNlcnZpY2UnO1xuXG4vKipcbiAqIDxzd2FsPiBjb21wb25lbnQuIFNlZSB0aGUgUkVBRE1FLm1kIGZvciB1c2FnZS5cbiAqXG4gKiBJdCBjb250YWlucyBhIGJ1bmNoIG9mIEBJbnB1dHMgdGhhdCBoYXZlIGEgcGVyZmVjdCAxOjEgbWFwcGluZyB3aXRoIFN3ZWV0QWxlcnQyIG9wdGlvbnMuXG4gKiBUaGVpciB0eXBlcyBhcmUgZGlyZWN0bHkgY29taW5nIGZyb20gU3dlZXRBbGVydDIgdHlwZXMgZGVmaW50aXRpb25zLCBtZWFuaW5nIHRoYXQgbmd4LXN3ZWV0YWxlcnQyIGlzIHRpZ2h0bHkgY291cGxlZFxuICogdG8gU3dlZXRBbGVydDIsIGJ1dCBhbHNvIGlzIHR5cGUtc2FmZS5cbiAqXG4gKiAoPykgSWYgeW91IHdhbnQgdG8gdXNlIGFuIG9iamVjdCB0aGF0IGRlY2xhcmVzIHRoZSBTd2VldEFsZXJ0MiBvcHRpb25zIGFsbCBhdCBvbmNlIHJhdGhlciB0aGFuIG1hbnkgQElucHV0cyxcbiAqICAgICB0YWtlIGEgbG9vayBhdCBbc3dhbE9wdGlvbnNdLCB0aGF0IGxldHMgeW91IHBhc3MgYSBmdWxsIHtAbGluayBTd2VldEFsZXJ0T3B0aW9uc30gb2JqZWN0LlxuICpcbiAqICg/KSBJZiB5b3UgYXJlIHJlYWRpbmcgdGhlIFR5cGVTY3JpcHQgc291cmNlIG9mIHRoaXMgY29tcG9uZW50LCB5b3UgbWF5IHRoaW5rIHRoYXQgaXQncyBhIGxvdCBvZiBjb2RlLlxuICogICAgIEJlIHN1cmUgdGhhdCBhIGxvdCBvZiB0aGlzIGNvZGUgaXMgdHlwZXMgYW5kIEFuZ3VsYXIgYm9pbGVycGxhdGUuIENvbXBpbGVkIGFuZCBtaW5pZmllZCBjb2RlIGlzIG11Y2ggc21hbGxlci5cbiAqICAgICBJZiB5b3UgYXJlIHJlYWxseSBjb25jZXJuZWQgYWJvdXQgcGVyZm9ybWFuY2UgYW5kL29yIGRvbid0IGNhcmUgYWJvdXQgdGhlIEFQSSBhbmQgaXRzIGNvbnZlbmllbnQgaW50ZWdyYXRpb25cbiAqICAgICB3aXRoIEFuZ3VsYXIgKG5vdGFibHkgY2hhbmdlIGRldGVjdGlvbiBhbmQgdHJhbnNjbHVzaW9uKSwgeW91IG1heSB0b3RhbGx5IHVzZSBTd2VldEFsZXJ0MiBuYXRpdmVseSBhcyB3ZWxsIDspXG4gKlxuICogLyFcXCBTb21lIFN3ZWV0QWxlcnQgb3B0aW9ucyBhcmVuJ3QgQElucHV0cyBidXQgQE91dHB1dHM6IG9uQmVmb3JlT3Blbiwgb25PcGVuLCBvbkNsb3NlLCBvbkFmdGVyQ2xvc2UgYW5kIG9uRGVzdHJveVxuICogICAgIChidXQgd2l0aG91dCBcIm9uKlwiIHByZWZpeCB0byByZXNwZWN0IGNvbW11bml0eSBzdGFuZGFyZHMpLlxuICogICAgIEhvd2V2ZXIsIHByZUNvbmZpcm0gYW5kIGlucHV0VmFsaWRhdG9yIGFyZSBzdGlsbCBASW5wdXRzIGJlY2F1c2UgdGhlcmUgYXJlIG5vdCBldmVudCBoYW5kbGVycywgdGhlcmUgY2FuJ3QgYmVcbiAqICAgICBtdWx0aXBsZSBsaXN0ZW5lcnMgYW5kIHdlIG5lZWQgdGhlIHZhbHVlcyB0aGV5IGNhbi9tdXN0IHJldHVybi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmNvbXBvbmVudC1zZWxlY3RvclxuICAgIHNlbGVjdG9yOiAnc3dhbCcsXG4gICAgdGVtcGxhdGU6ICcnLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFN3YWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGl0bGU6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aXRsZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0aXRsZVRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aXRsZVRleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ3RleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaHRtbDogU3dlZXRBbGVydE9wdGlvbnNbJ2h0bWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9vdGVyOiBTd2VldEFsZXJ0T3B0aW9uc1snZm9vdGVyJ107XG4gICAgQElucHV0KCkgcHVibGljIGljb246IFN3ZWV0QWxlcnRPcHRpb25zWydpY29uJ107XG4gICAgQElucHV0KCkgcHVibGljIGljb25IdG1sOiBTd2VldEFsZXJ0T3B0aW9uc1snaWNvbkh0bWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYmFja2Ryb3A6IFN3ZWV0QWxlcnRPcHRpb25zWydiYWNrZHJvcCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0b2FzdDogU3dlZXRBbGVydE9wdGlvbnNbJ3RvYXN0J107XG4gICAgQElucHV0KCkgcHVibGljIHRhcmdldDogU3dlZXRBbGVydE9wdGlvbnNbJ3RhcmdldCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dDogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0J107XG4gICAgQElucHV0KCkgcHVibGljIHdpZHRoOiBTd2VldEFsZXJ0T3B0aW9uc1snd2lkdGgnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcGFkZGluZzogU3dlZXRBbGVydE9wdGlvbnNbJ3BhZGRpbmcnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYmFja2dyb3VuZDogU3dlZXRBbGVydE9wdGlvbnNbJ2JhY2tncm91bmQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcG9zaXRpb246IFN3ZWV0QWxlcnRPcHRpb25zWydwb3NpdGlvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBncm93OiBTd2VldEFsZXJ0T3B0aW9uc1snZ3JvdyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93Q2xhc3M6IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93Q2xhc3MnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaGlkZUNsYXNzOiBTd2VldEFsZXJ0T3B0aW9uc1snaGlkZUNsYXNzJ107XG4gICAgQElucHV0KCkgcHVibGljIGN1c3RvbUNsYXNzOiBTd2VldEFsZXJ0T3B0aW9uc1snY3VzdG9tQ2xhc3MnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGltZXI6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aW1lciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0aW1lclByb2dyZXNzQmFyOiBTd2VldEFsZXJ0T3B0aW9uc1sndGltZXJQcm9ncmVzc0JhciddO1xuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2Ugc2hvd0NsYXNzIGFuZCBoaWRlQ2xhc3MgaW5zdGVhZCAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBhbmltYXRpb246IFN3ZWV0QWxlcnRPcHRpb25zWydhbmltYXRpb24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaGVpZ2h0QXV0bzogU3dlZXRBbGVydE9wdGlvbnNbJ2hlaWdodEF1dG8nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYWxsb3dPdXRzaWRlQ2xpY2s6IFN3ZWV0QWxlcnRPcHRpb25zWydhbGxvd091dHNpZGVDbGljayddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBhbGxvd0VzY2FwZUtleTogU3dlZXRBbGVydE9wdGlvbnNbJ2FsbG93RXNjYXBlS2V5J107XG4gICAgQElucHV0KCkgcHVibGljIGFsbG93RW50ZXJLZXk6IFN3ZWV0QWxlcnRPcHRpb25zWydhbGxvd0VudGVyS2V5J107XG4gICAgQElucHV0KCkgcHVibGljIHN0b3BLZXlkb3duUHJvcGFnYXRpb246IFN3ZWV0QWxlcnRPcHRpb25zWydzdG9wS2V5ZG93blByb3BhZ2F0aW9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGtleWRvd25MaXN0ZW5lckNhcHR1cmU6IFN3ZWV0QWxlcnRPcHRpb25zWydrZXlkb3duTGlzdGVuZXJDYXB0dXJlJ107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dDb25maXJtQnV0dG9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0NvbmZpcm1CdXR0b24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0NhbmNlbEJ1dHRvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dDYW5jZWxCdXR0b24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY29uZmlybUJ1dHRvblRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydjb25maXJtQnV0dG9uVGV4dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjYW5jZWxCdXR0b25UZXh0OiBTd2VldEFsZXJ0T3B0aW9uc1snY2FuY2VsQnV0dG9uVGV4dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjb25maXJtQnV0dG9uQ29sb3I6IFN3ZWV0QWxlcnRPcHRpb25zWydjb25maXJtQnV0dG9uQ29sb3InXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2FuY2VsQnV0dG9uQ29sb3I6IFN3ZWV0QWxlcnRPcHRpb25zWydjYW5jZWxCdXR0b25Db2xvciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjb25maXJtQnV0dG9uQXJpYUxhYmVsOiBTd2VldEFsZXJ0T3B0aW9uc1snY29uZmlybUJ1dHRvbkFyaWFMYWJlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjYW5jZWxCdXR0b25BcmlhTGFiZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjYW5jZWxCdXR0b25BcmlhTGFiZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYnV0dG9uc1N0eWxpbmc6IFN3ZWV0QWxlcnRPcHRpb25zWydidXR0b25zU3R5bGluZyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyByZXZlcnNlQnV0dG9uczogU3dlZXRBbGVydE9wdGlvbnNbJ3JldmVyc2VCdXR0b25zJ107XG4gICAgQElucHV0KCkgcHVibGljIGZvY3VzQ29uZmlybTogU3dlZXRBbGVydE9wdGlvbnNbJ2ZvY3VzQ29uZmlybSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBmb2N1c0NhbmNlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2ZvY3VzQ2FuY2VsJ107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dDbG9zZUJ1dHRvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dDbG9zZUJ1dHRvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjbG9zZUJ1dHRvbkh0bWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjbG9zZUJ1dHRvbkh0bWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2xvc2VCdXR0b25BcmlhTGFiZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjbG9zZUJ1dHRvbkFyaWFMYWJlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93TG9hZGVyT25Db25maXJtOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0xvYWRlck9uQ29uZmlybSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwcmVDb25maXJtOiBTd2VldEFsZXJ0T3B0aW9uc1sncHJlQ29uZmlybSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZVVybDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlVXJsJ107XG4gICAgQElucHV0KCkgcHVibGljIGltYWdlV2lkdGg6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZVdpZHRoJ107XG4gICAgQElucHV0KCkgcHVibGljIGltYWdlSGVpZ2h0OiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VIZWlnaHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VBbHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZUFsdCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dFBsYWNlaG9sZGVyOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRQbGFjZWhvbGRlciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dFZhbHVlOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRWYWx1ZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dE9wdGlvbnM6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dE9wdGlvbnMnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRBdXRvVHJpbTogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0QXV0b1RyaW0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRBdHRyaWJ1dGVzOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRBdHRyaWJ1dGVzJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0VmFsaWRhdG9yOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRWYWxpZGF0b3InXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdmFsaWRhdGlvbk1lc3NhZ2U6IFN3ZWV0QWxlcnRPcHRpb25zWyd2YWxpZGF0aW9uTWVzc2FnZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwcm9ncmVzc1N0ZXBzOiBTd2VldEFsZXJ0T3B0aW9uc1sncHJvZ3Jlc3NTdGVwcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjdXJyZW50UHJvZ3Jlc3NTdGVwOiBTd2VldEFsZXJ0T3B0aW9uc1snY3VycmVudFByb2dyZXNzU3RlcCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwcm9ncmVzc1N0ZXBzRGlzdGFuY2U6IFN3ZWV0QWxlcnRPcHRpb25zWydwcm9ncmVzc1N0ZXBzRGlzdGFuY2UnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2Nyb2xsYmFyUGFkZGluZzogU3dlZXRBbGVydE9wdGlvbnNbJ3Njcm9sbGJhclBhZGRpbmcnXTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBvZiBTd2VldEFsZXJ0MiBuYXRpdmUgb3B0aW9ucywgdXNlZnVsIGlmOlxuICAgICAqICAtIHlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGUgQElucHV0cyBmb3IgcHJhY3RpY2FsL3BoaWxvc29waGljYWwgcmVhc29ucyA7XG4gICAgICogIC0gdGhlcmUgYXJlIG1pc3NpbmcgQElucHV0cyBiZWNhdXNlIG5neC1zd2VldGFsZXJ0MiBpc24ndCB1cC10by1kYXRlIHdpdGggU3dlZXRBbGVydDIncyBsYXRlc3QgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIC8hXFwgUGxlYXNlIG5vdGUgdGhhdCBzZXR0aW5nIHRoaXMgcHJvcGVydHkgZG9lcyBOT1QgZXJhc2Ugd2hhdCBoYXMgYmVlbiBzZXQgYmVmb3JlIHVubGVzcyB5b3Ugc3BlY2lmeSB0aGVcbiAgICAgKiAgICAgcHJldmlvdXMgcHJvcGVydGllcyB5b3Ugd2FudCB0byBlcmFzZSBhZ2Fpbi5cbiAgICAgKiAgICAgSWUuIHNldHRpbmcgeyB0aXRsZTogJ1RpdGxlJyB9IGFuZCB0aGVuIHsgdGV4dDogJ1RleHQnIH0gd2lsbCBnaXZlIHsgdGl0bGU6ICdUaXRsZScsIHRleHQ6ICdUZXh0JyB9LlxuICAgICAqXG4gICAgICogLyFcXCBCZSBhd2FyZSB0aGF0IHRoZSBvcHRpb25zIGRlZmluZWQgaW4gdGhpcyBvYmplY3Qgd2lsbCBvdmVycmlkZSB0aGUgQElucHV0cyBvZiB0aGUgc2FtZSBuYW1lLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBzd2FsT3B0aW9ucyhvcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9ucykge1xuICAgICAgICAvLz0+IFVwZGF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy89PiBNYXJrIGNoYW5nZWQgcHJvcGVydGllcyBhcyB0b3VjaGVkXG4gICAgICAgIGNvbnN0IHRvdWNoZWRLZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucykgYXMgQXJyYXk8a2V5b2YgU3dlZXRBbGVydE9wdGlvbnM+O1xuICAgICAgICB0b3VjaGVkS2V5cy5mb3JFYWNoKHRoaXMubWFya1RvdWNoZWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBvcHRpb25zIG9iamVjdCB0aGF0IHdpbGwgZ2V0IHBhc3NlZCB0byBTd2VldEFsZXJ0Mi5cbiAgICAgKiBPbmx5IHRoZSBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIHNldCBhdCBsZWFzdCBvbmNlIG9uIHRoaXMgY29tcG9uZW50IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogTW9zdGx5IGZvciBpbnRlcm5hbCB1c2FnZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHN3YWxPcHRpb25zKCk6IFN3ZWV0QWxlcnRPcHRpb25zIHtcbiAgICAgICAgLy89PiBXZSB3aWxsIGNvbXB1dGUgdGhlIG9wdGlvbnMgb2JqZWN0IGJhc2VkIG9uIHRoZSBvcHRpb24ga2V5cyB0aGF0IGFyZSBrbm93biB0byBoYXZlIGNoYW5nZWQuXG4gICAgICAgIC8vICAgVGhhdCBhdm9pZHMgcGFzc2luZyBhIGdpZ2FudGljIG9iamVjdCB0byBTd2VldEFsZXJ0MiwgbWFraW5nIGRlYnVnZ2luZyBlYXNpZXIgYW5kIHBvdGVudGlhbGx5XG4gICAgICAgIC8vICAgYXZvaWRpbmcgc2lkZSBlZmZlY3RzLlxuICAgICAgICByZXR1cm4gWy4uLnRoaXMudG91Y2hlZFByb3BzXS5yZWR1Y2U8U3dlZXRBbGVydE9wdGlvbnM+KFxuICAgICAgICAgICAgKG9iaiwga2V5KSA9PiAoeyAuLi5vYmosIFtrZXldOiB0aGlzW2tleSBhcyBrZXlvZiB0aGlzXSB9KSxcbiAgICAgICAgICAgIHt9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGZpcmUgdGhlIG1vZGFsIGFzIHNvb24gYXMgdGhlIDxzd2FsPiBjb21wb25lbnQgaXMgY3JlYXRlZCBhbmQgaW5pdGlhbGl6ZWQgaW4gdGhlIHZpZXcuXG4gICAgICogV2hlbiBsZWZ0IHVuZGVmaW5lZCAoZGVmYXVsdCksIHRoZSB2YWx1ZSB3aWxsIGJlIGluaGVyaXRlZCBmcm9tIHRoZSBtb2R1bGUgY29uZmlndXJhdGlvbiwgd2hpY2ggaXMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIDxzd2FsICpuZ0lmPVwiZXJyb3JcIiBbdGl0bGVdPVwiZXJyb3IudGl0bGVcIiBbdGV4dF09XCJlcnJvci50ZXh0XCIgaWNvbj1cImVycm9yXCIgW3N3YWxGaXJlT25Jbml0XT1cInRydWVcIj48L3N3YWw+XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc3dhbEZpcmVPbkluaXQ/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBkaXNtaXNzIHRoZSBtb2RhbCB3aGVuIHRoZSA8c3dhbD4gY29tcG9uZW50IGlzIGRlc3Ryb3llZCBieSBBbmd1bGFyIChmb3IgYW55IHJlYXNvbikgb3Igbm90LlxuICAgICAqIFdoZW4gbGVmdCB1bmRlZmluZWQgKGRlZmF1bHQpLCB0aGUgdmFsdWUgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgbW9kdWxlIGNvbmZpZ3VyYXRpb24sIHdoaWNoIGlzIGB0cnVlYC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzd2FsRGlzbWlzc09uRGVzdHJveT86IGJvb2xlYW47XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgc3dhbFZpc2libGUodmlzaWJsZTogYm9vbGVhbikge1xuICAgICAgICB2aXNpYmxlID8gdGhpcy5maXJlKCkgOiB0aGlzLmRpc21pc3MoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHN3YWxWaXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0N1cnJlbnRseVNob3duO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIG1vZGFsIERPTSBlbGVtZW50IGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICogVXNlZnVsIHRvIHBlcmZvcm0gRE9NIG11dGF0aW9ucyBiZWZvcmUgdGhlIG1vZGFsIGlzIHNob3duLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBiZWZvcmVPcGVuID0gbmV3IEV2ZW50RW1pdHRlcjxldmVudHMuQmVmb3JlT3BlbkV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgbW9kYWwgaXMgc2hvd24uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IG9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyPGV2ZW50cy5PcGVuRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBtb2RhbCBET00gaXMgcmVuZGVyZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IHJlbmRlciA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLlJlbmRlckV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgbW9kYWwgd2lsbCBiZSBjbG9zZWQuXG4gICAgICogSWYgeW91IGp1c3Qgd2FudCB0byBrbm93IHdoZW4gdGhlIHVzZXIgZGlzbWlzc2VkIHRoZSBtb2RhbCwgcHJlZmVyIHRoZSBoaWdoZXItbGV2ZWwgKGNhbmNlbCkgb3V0cHV0LlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBjbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLkNsb3NlRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhZnRlciB0aGUgbW9kYWwgaGFkIGJlZW4gY2xvc2VkLlxuICAgICAqIElmIHlvdSBqdXN0IHdhbnQgdG8ga25vdyB3aGVuIHRoZSB1c2VyIGRpc21pc3NlZCB0aGUgbW9kYWwsIHByZWZlciB0aGUgaGlnaGVyLWxldmVsIChjYW5jZWwpIG91dHB1dC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgYWZ0ZXJDbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFmdGVyIHRoZSBtb2RhbCBoYWQgYmVlbiBjbG9zZWQuXG4gICAgICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB7QGxpbmsgZGVzdHJveX0gYW5kIHtAbGluayBhZnRlckNsb3NlfSBpcyB0aGF0IHRoZSBsYXR0ZXIgaXMgY2FsbGVkIGZvciB1c2VyIGludGVyYWN0aW9uc1xuICAgICAqIG9ubHkgKGNsaWNrcyksIHdoZXJlYXMge0BsaW5rIGRlc3Ryb3l9IGlzIGFsd2F5cyBjYWxsZWQsIGJvdGggZm9yIHVzZXIgaW50ZXJhY3Rpb25zIGFuZCBwb3B1cCBiZWluZyBjbG9zZWQgYnlcbiAgICAgKiBhbm90aGVyIHBvcHVwLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBkZXN0cm95ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJDb25maXJtXCIuXG4gICAgICogQmVhcnMgYSB2YWx1ZSB3aGVuIHVzaW5nIFwiaW5wdXRcIiwgcmVzb2x2ZWQgXCJwcmVDb25maXJtXCIsIGV0Yy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIDxzd2FsIChjb25maXJtKT1cImhhbmRsZUNvbmZpcm0oJGV2ZW50KVwiPjwvc3dhbD5cbiAgICAgKlxuICAgICAqICAgICBwdWJsaWMgaGFuZGxlQ29uZmlybShlbWFpbDogc3RyaW5nKTogdm9pZCB7XG4gICAgICogICAgICAgICAvLyAuLi4gc2F2ZSB1c2VyIGVtYWlsXG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgY29uZmlybSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJDYW5jZWxcIiwgb3IgZGlzbWlzc2VzIHRoZSBtb2RhbCBieSBhbnkgb3RoZXIgYWxsb3dlZCB3YXkuXG4gICAgICogQnkgZGVmYXVsdCwgaXQgd2lsbCBlbWl0IGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcmVhc29uIGZvciB3aGljaCB0aGUgU3dlZXRBbGVydCBoYXMgYmVlbiBjbG9zZWQuXG4gICAgICogVGhlIHJlYXNvbiBpcyBgdW5kZWZpbmVkYCB3aGVuIHtAbGluayBkaXNtaXNzfSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgICA8c3dhbCAoY2FuY2VsKT1cImhhbmRsZUNhbmNlbCgkZXZlbnQpXCI+PC9zd2FsPlxuICAgICAqXG4gICAgICogICAgIHB1YmxpYyBoYW5kbGVDYW5jZWwocmVhc29uOiBEaXNtaXNzUmVhc29uIHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgICogICAgICAgICAvLyByZWFzb24gY2FuIGJlICdjYW5jZWwnLCAnb3ZlcmxheScsICdjbG9zZScsICd0aW1lcicgb3IgdW5kZWZpbmVkLlxuICAgICAqICAgICAgICAgLy8gLi4uIGRvIHNvbWV0aGluZ1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGNhbmNlbCA9IG5ldyBFdmVudEVtaXR0ZXI8U3dhbC5EaXNtaXNzUmVhc29uIHwgdW5kZWZpbmVkPigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBTZXQgcmV0YWlucyB0aGUgcHJvcGVydGllcyB0aGF0IGhhdmUgYmVlbiBjaGFuZ2VkIGZyb20gQElucHV0cywgc28gd2UgY2FuIGtub3cgcHJlY2lzZWx5XG4gICAgICogd2hhdCBvcHRpb25zIHdlIGhhdmUgdG8gc2VuZCB0byB7QGxpbmsgU3dhbC5maXJlfS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IHRvdWNoZWRQcm9wcyA9IG5ldyBTZXQ8a2V5b2YgU3dlZXRBbGVydE9wdGlvbnM+KCk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIG9mIHNpZ25hdHVyZSBgKHByb3BOYW1lOiBzdHJpbmcpOiB2b2lkYCB0aGF0IGFkZHMgYSBnaXZlbiBwcm9wZXJ0eSBuYW1lIHRvIHRoZSBsaXN0IG9mXG4gICAgICogdG91Y2hlZCBwcm9wZXJ0aWVzLCBpZS4ge0BsaW5rIHRvdWNoZWRQcm9wc30uXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWFkb25seSBtYXJrVG91Y2hlZCA9IHRoaXMudG91Y2hlZFByb3BzLmFkZC5iaW5kKHRoaXMudG91Y2hlZFByb3BzKTtcblxuICAgIC8qKlxuICAgICAqIElzIHRoZSBTd2VldEFsZXJ0MiBtb2RhbCByZXByZXNlbnRlZCBieSB0aGlzIGNvbXBvbmVudCBjdXJyZW50bHkgb3BlbmVkP1xuICAgICAqL1xuICAgIHByaXZhdGUgaXNDdXJyZW50bHlTaG93biA9IGZhbHNlO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHN3ZWV0QWxlcnQyTG9hZGVyOiBTd2VldEFsZXJ0MkxvYWRlclNlcnZpY2UsXG4gICAgICAgIEBJbmplY3QoZmlyZU9uSW5pdFRva2VuKSBwcml2YXRlIHJlYWRvbmx5IG1vZHVsZUxldmVsRmlyZU9uSW5pdDogYm9vbGVhbixcbiAgICAgICAgQEluamVjdChkaXNtaXNzT25EZXN0cm95VG9rZW4pIHByaXZhdGUgcmVhZG9ubHkgbW9kdWxlTGV2ZWxEaXNtaXNzT25EZXN0cm95OiBib29sZWFuKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBsaWZlY3ljbGUgaG9vay5cbiAgICAgKiBBc2tzIHRoZSBTd2VldEFsZXJ0MiBsb2FkZXIgc2VydmljZSB0byBwcmVsb2FkIHRoZSBTd2VldEFsZXJ0MiBsaWJyYXJ5LCBzbyBpdCBiZWdpbnMgdG8gYmUgbG9hZGVkIG9ubHkgaWYgdGhlcmVcbiAgICAgKiBpcyBhIDxzd2FsPiBjb21wb25lbnQgc29tZXdoZXJlLCBhbmQgaXMgcHJvYmFibHkgZnVsbHkgbG9hZGVkIHdoZW4gdGhlIG1vZGFsIGhhcyB0byBiZSBkaXNwbGF5ZWQsXG4gICAgICogY2F1c2luZyBubyBkZWxheS5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIC8vPT4gUHJlbG9hZCBTd2VldEFsZXJ0MiBsaWJyYXJ5IGluIGNhc2UgdGhpcyBjb21wb25lbnQgaXMgYWN0aXZhdGVkLlxuICAgICAgICB0aGlzLnN3ZWV0QWxlcnQyTG9hZGVyLnByZWxvYWRTd2VldEFsZXJ0TGlicmFyeSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ3VsYXIgbGlmZWN5Y2xlIGhvb2suXG4gICAgICogRmlyZXMgdGhlIG1vZGFsLCBpZiB0aGUgY29tcG9uZW50IG9yIG1vZHVsZSBpcyBjb25maWd1cmVkIHRvIGRvIHNvLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGZpcmVPbkluaXQgPSB0aGlzLnN3YWxGaXJlT25Jbml0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdGhpcy5tb2R1bGVMZXZlbEZpcmVPbkluaXRcbiAgICAgICAgICAgIDogdGhpcy5zd2FsRmlyZU9uSW5pdDtcblxuICAgICAgICBmaXJlT25Jbml0ICYmIHRoaXMuZmlyZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ3VsYXIgbGlmZWN5Y2xlIGhvb2suXG4gICAgICogVXBkYXRlcyB0aGUgU3dlZXRBbGVydCBvcHRpb25zLCBhbmQgaWYgdGhlIG1vZGFsIGlzIG9wZW5lZCwgYXNrcyBTd2VldEFsZXJ0IHRvIHJlbmRlciBpdCBhZ2Fpbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgICAgICAvLz0+IEZvciBlYWNoIGNoYW5nZWQgQElucHV0IHRoYXQgbWF0Y2hlcyBhIFN3ZWV0QWxlcnQyIG9wdGlvbiwgbWFyayBhcyB0b3VjaGVkIHNvIHdlIGNhblxuICAgICAgICAvLyAgIHNlbmQgaXQgd2l0aCB0aGUgbmV4dCBmaXJlKCkgb3IgdXBkYXRlKCkgY2FsbHMuXG4gICAgICAgIE9iamVjdC5rZXlzKGNoYW5nZXMpXG4gICAgICAgICAgICAvLz0+IElmIHRoZSBmaWx0ZXJpbmcgbG9naWMgYmVjb21lcyBtb3JlIGNvbXBsZXggaGVyZSwgd2UgY2FuIHVzZSBTd2FsLmlzVmFsaWRQYXJhbWV0ZXJcbiAgICAgICAgICAgIC5maWx0ZXIoKGtleSk6IGtleSBpcyBrZXlvZiBTd2VldEFsZXJ0T3B0aW9ucyA9PiAha2V5LnN0YXJ0c1dpdGgoJ3N3YWwnKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKHRoaXMubWFya1RvdWNoZWQpO1xuXG4gICAgICAgIC8vPT4gRXZlbnR1YWxseSB0cmlnZ2VyIHJlLXJlbmRlciBpZiB0aGUgbW9kYWwgaXMgb3Blbi5cbiAgICAgICAgdm9pZCB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ3VsYXIgbGlmZWN5Y2xlIGhvb2suXG4gICAgICogQ2xvc2VzIHRoZSBTd2VldEFsZXJ0IHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICAvLz0+IFJlbGVhc2UgdGhlIG1vZGFsIGlmIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGFuZCBpZiB0aGF0IGJlaGF2aW91ciBpcyBub3QgZGlzYWJsZWQuXG4gICAgICAgIGNvbnN0IGRpc21pc3NPbkRlc3Ryb3kgPSB0aGlzLnN3YWxEaXNtaXNzT25EZXN0cm95ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdGhpcy5tb2R1bGVMZXZlbERpc21pc3NPbkRlc3Ryb3lcbiAgICAgICAgICAgIDogdGhpcy5zd2FsRGlzbWlzc09uRGVzdHJveTtcblxuICAgICAgICBkaXNtaXNzT25EZXN0cm95ICYmIHRoaXMuZGlzbWlzcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBTd2VldEFsZXJ0LlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgU3dlZXRBbGVydDIgcHJvbWlzZSBmb3IgY29udmVuaWVuY2UgYW5kIHVzZSBpbiBjb2RlIGJlaGluZCB0ZW1wbGF0ZXMuXG4gICAgICogT3RoZXJ3aXNlLCAoY29uZmlybSk9XCJteUhhbmRsZXIoJGV2ZW50KVwiIGFuZCAoY2FuY2VsKT1cIm15SGFuZGxlcigkZXZlbnQpXCIgY2FuIGJlIHVzZWQgaW4gdGVtcGxhdGVzLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBmaXJlKCk6IFByb21pc2U8U3dlZXRBbGVydFJlc3VsdD4ge1xuICAgICAgICBjb25zdCBzd2FsID0gYXdhaXQgdGhpcy5zd2VldEFsZXJ0MkxvYWRlci5zd2FsO1xuXG4gICAgICAgIGNvbnN0IHVzZXJPcHRpb25zID0gdGhpcy5zd2FsT3B0aW9ucztcblxuICAgICAgICAvLz0+IEJ1aWxkIHRoZSBTd2VldEFsZXJ0MiBvcHRpb25zXG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IFN3ZWV0QWxlcnRPcHRpb25zID0ge1xuICAgICAgICAgICAgLy89PiBNZXJnZSB3aXRoIGNhbGN1bGF0ZWQgb3B0aW9ucyBzZXQgZm9yIHRoYXQgc3BlY2lmaWMgc3dhbFxuICAgICAgICAgICAgLi4udXNlck9wdGlvbnMsXG5cbiAgICAgICAgICAgIC8vPT4gSGFuZGxlIG1vZGFsIGxpZmVjeWNsZSBldmVudHNcbiAgICAgICAgICAgIG9uQmVmb3JlT3BlbjogY29tcG9zZUhvb2sodXNlck9wdGlvbnMub25CZWZvcmVPcGVuLCAobW9kYWxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5iZWZvcmVPcGVuLmVtaXQoeyBtb2RhbEVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9uT3BlbjogY29tcG9zZUhvb2sodXNlck9wdGlvbnMub25PcGVuLCAobW9kYWxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0N1cnJlbnRseVNob3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4uZW1pdCh7IG1vZGFsRWxlbWVudCB9KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb25SZW5kZXI6IGNvbXBvc2VIb29rKHVzZXJPcHRpb25zLm9uUmVuZGVyLCAobW9kYWxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIuZW1pdCh7IG1vZGFsRWxlbWVudCB9KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb25DbG9zZTogY29tcG9zZUhvb2sodXNlck9wdGlvbnMub25DbG9zZSwgKG1vZGFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDdXJyZW50bHlTaG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UuZW1pdCh7IG1vZGFsRWxlbWVudCB9KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb25BZnRlckNsb3NlOiBjb21wb3NlSG9vayh1c2VyT3B0aW9ucy5vbkFmdGVyQ2xvc2UsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFmdGVyQ2xvc2UuZW1pdCgpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvbkRlc3Ryb3k6IGNvbXBvc2VIb29rKHVzZXJPcHRpb25zLm9uRGVzdHJveSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveS5lbWl0KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vPT4gU2hvdyB0aGUgU3dhbCEgQW5kIHdhaXQgZm9yIGNvbmZpcm1hdGlvbiBvciBkaW1pc3NhbC5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3dhbC5maXJlKG9wdGlvbnMpO1xuXG4gICAgICAgIC8vPT4gRW1pdCBvbiAoY29uZmlybSkgb3IgKGNhbmNlbClcbiAgICAgICAgaWYgKCd2YWx1ZScgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpcm0uZW1pdChyZXN1bHQudmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwuZW1pdChyZXN1bHQuZGlzbWlzcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXBvc2VIb29rPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IHZvaWQ+KFxuICAgICAgICAgICAgdXNlckhvb2s6IFQgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICBsaWJIb29rOiBUKTogKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VD4pID0+IHZvaWQge1xuXG4gICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IChsaWJIb29rKC4uLmFyZ3MpLCB1c2VySG9vaz8uKC4uLmFyZ3MpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgbW9kYWwsIGlmIG9wZW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXN1bHQgVGhlIHZhbHVlIHRoYXQgdGhlIG1vZGFsIHdpbGwgcmVzb2x2ZSB3aXRoLCB0cmlnZ2VyaW5nIGVpdGhlciAoY29uZmlybSkgb3IgKGNhbmNlbCkuXG4gICAgICogICAgICAgICAgICAgICBJZiB0aGUgYXJndW1lbnQgaXMgbm90IHBhc3NlZCwgKGRpbWlzcykgd2lsbCBlbWl0IGB1bmRlZmluZWRgLlxuICAgICAqICAgICAgICAgICAgICAgU2VlIHtAbGluayBTd2FsLmNsb3NlfVxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBkaXNtaXNzKHJlc3VsdD86IFN3ZWV0QWxlcnRSZXN1bHQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ3VycmVudGx5U2hvd24pIHJldHVybjtcblxuICAgICAgICBjb25zdCBzd2FsID0gYXdhaXQgdGhpcy5zd2VldEFsZXJ0MkxvYWRlci5zd2FsO1xuICAgICAgICBzd2FsLmNsb3NlKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBTd2VldEFsZXJ0MiBvcHRpb25zIHdoaWxlIHRoZSBtb2RhbCBpcyBvcGVuZWQsIGNhdXNpbmcgdGhlIG1vZGFsIHRvIHJlLXJlbmRlci5cbiAgICAgKiBJZiB0aGUgbW9kYWwgaXMgbm90IG9wZW5lZCwgdGhlIGNvbXBvbmVudCBvcHRpb25zIHdpbGwgc2ltcGx5IGJlIHVwZGF0ZWQgYW5kIHRoYXQncyBpdC5cbiAgICAgKlxuICAgICAqIC8hXFwgUGxlYXNlIG5vdGUgdGhhdCBub3QgYWxsIFN3ZWV0QWxlcnQyIG9wdGlvbnMgYXJlIHVwZGF0YWJsZSB3aGlsZSB0aGUgbW9kYWwgaXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgdXBkYXRlKG9wdGlvbnM/OiBQaWNrPFN3ZWV0QWxlcnRPcHRpb25zLCBTd2VldEFsZXJ0VXBkYXRhYmxlUGFyYW1ldGVycz4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhbE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQ3VycmVudGx5U2hvd24pIHJldHVybjtcblxuICAgICAgICBjb25zdCBzd2FsID0gYXdhaXQgdGhpcy5zd2VldEFsZXJ0MkxvYWRlci5zd2FsO1xuXG4gICAgICAgIGNvbnN0IGFsbE9wdGlvbnMgPSB0aGlzLnN3YWxPcHRpb25zO1xuXG4gICAgICAgIGNvbnN0IHVwZGF0YWJsZU9wdGlvbnMgPSBPYmplY3Qua2V5cyhhbGxPcHRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihzd2FsLmlzVXBkYXRhYmxlUGFyYW1ldGVyKVxuICAgICAgICAgICAgLnJlZHVjZTxQaWNrPFN3ZWV0QWxlcnRPcHRpb25zLCBTd2VldEFsZXJ0VXBkYXRhYmxlUGFyYW1ldGVycz4+KFxuICAgICAgICAgICAgICAgIChvYmosIGtleSkgPT4gKHsgLi4ub2JqLCBba2V5XTogYWxsT3B0aW9uc1trZXldIH0pLFxuICAgICAgICAgICAgICAgIHt9KTtcblxuICAgICAgICBzd2FsLnVwZGF0ZSh1cGRhdGFibGVPcHRpb25zKTtcbiAgICB9XG59XG4iXX0=