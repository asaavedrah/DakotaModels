import { __decorate, __param } from "tslib";
import { Inject, Injectable } from '@angular/core';
import { swalProviderToken } from './di';
import * as ɵngcc0 from '@angular/core';
let SweetAlert2LoaderService = class SweetAlert2LoaderService {
    // Using any because Angular metadata generator does not understand a pure TS type here
    constructor(swalProvider) {
        this.swalProvider = swalProvider;
    }
    get swal() {
        if (!this.swalPromiseCache) {
            this.preloadSweetAlertLibrary();
        }
        return this.swalPromiseCache;
    }
    preloadSweetAlertLibrary() {
        if (this.swalPromiseCache)
            return;
        const libPromise = isLoader(this.swalProvider)
            ? this.swalProvider()
            : Promise.resolve(this.swalProvider);
        this.swalPromiseCache = libPromise.then(value => isDefaultExport(value) ? value : value.default);
        function isLoader(value) {
            return typeof value === 'function' && value.version === undefined;
        }
        function isDefaultExport(value) {
            return typeof value === 'function';
        }
    }
};
SweetAlert2LoaderService.ɵfac = function SweetAlert2LoaderService_Factory(t) { return new (t || SweetAlert2LoaderService)(ɵngcc0.ɵɵinject(swalProviderToken)); };
SweetAlert2LoaderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SweetAlert2LoaderService, factory: function (t) { return SweetAlert2LoaderService.ɵfac(t); } });
SweetAlert2LoaderService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [swalProviderToken,] }] }
];
SweetAlert2LoaderService = __decorate([ __param(0, Inject(swalProviderToken))
], SweetAlert2LoaderService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SweetAlert2LoaderService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [swalProviderToken]
            }] }]; }, null); })();
export { SweetAlert2LoaderService };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dlZXRhbGVydDItbG9hZGVyLnNlcnZpY2UuanMiLCJzb3VyY2VzIjpbIkBzd2VldGFsZXJ0Mi9uZ3gtc3dlZXRhbGVydDIvbGliL3N3ZWV0YWxlcnQyLWxvYWRlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVuRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxNQUFNLENBQUM7O0FBU3pDLElBQWEsd0JBQXdCLEdBQXJDLE1BQWEsd0JBQXdCO0FBQ3JDLElBSUksdUZBQXVGO0FBQzNGLElBQUksWUFBOEMsWUFBaUI7QUFDbkUsUUFBUSxJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztBQUN6QyxJQUFJLENBQUM7QUFDTCxJQUNJLElBQVcsSUFBSTtBQUFLLFFBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7QUFDcEMsWUFBWSxJQUFJLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztBQUM1QyxTQUFTO0FBQ1QsUUFDUSxPQUFPLElBQUksQ0FBQyxnQkFBaUIsQ0FBQztBQUN0QyxJQUFJLENBQUM7QUFDTCxJQUNXLHdCQUF3QjtBQUFLLFFBQ2hDLElBQUksSUFBSSxDQUFDLGdCQUFnQjtBQUFFLFlBQUEsT0FBTztBQUMxQyxRQUNRLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDO0FBQ3RELFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7QUFDakMsWUFBWSxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDakQsUUFDUSxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDekcsUUFDUSxTQUFTLFFBQVEsQ0FBQyxLQUFtQjtBQUFJLFlBQ3JDLE9BQU8sT0FBTyxLQUFLLEtBQUssVUFBVSxJQUFLLEtBQWEsQ0FBQyxPQUFPLEtBQUssU0FBUyxDQUFDO0FBQ3ZGLFFBQVEsQ0FBQztBQUNULFFBQ1EsU0FBUyxlQUFlLENBQUMsS0FBaUI7QUFBSSxZQUMxQyxPQUFPLE9BQU8sS0FBSyxLQUFLLFVBQVUsQ0FBQztBQUMvQyxRQUFRLENBQUM7QUFDVCxJQUFJLENBQUM7QUFDTCxDQUFDOztvS0FBQTtBQUNEO0FBQWtELDRDQTlCMUIsTUFBTSxTQUFDLGlCQUFpQjtBQUFRO0FBTjNDLHdCQUF3QixvQkFEcEMsVUFBVSxFQUFFLGpCQUNULENBTW9CLFdBQUEsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUE7QUFBQyxHQU5yQyx3QkFBd0IsQ0FtQ3BDOzs7Ozs7a0NBQ0Q7QUFBQyxTQXBDWSx3QkFBd0I7QUFDcEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCBTd2FsRGVmYXVsdCwgKiBhcyBTd2FsIGZyb20gJ3N3ZWV0YWxlcnQyJztcbmltcG9ydCB7IHN3YWxQcm92aWRlclRva2VuIH0gZnJvbSAnLi9kaSc7XG5cbmV4cG9ydCB0eXBlIFN3YWxNb2R1bGUgPSB0eXBlb2YgU3dhbERlZmF1bHQgfCB0eXBlb2YgU3dhbDtcblxuZXhwb3J0IHR5cGUgU3dhbFByb3ZpZGVyID0gU3dhbE1vZHVsZUxvYWRlciB8IFN3YWxNb2R1bGU7XG5cbmV4cG9ydCB0eXBlIFN3YWxNb2R1bGVMb2FkZXIgPSAoKSA9PiBQcm9taXNlPFN3YWxNb2R1bGU+O1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU3dlZXRBbGVydDJMb2FkZXJTZXJ2aWNlIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN3YWxQcm92aWRlcjogU3dhbFByb3ZpZGVyO1xuXG4gICAgcHJpdmF0ZSBzd2FsUHJvbWlzZUNhY2hlPzogUHJvbWlzZTx0eXBlb2YgU3dhbERlZmF1bHQ+O1xuXG4gICAgLy8gVXNpbmcgYW55IGJlY2F1c2UgQW5ndWxhciBtZXRhZGF0YSBnZW5lcmF0b3IgZG9lcyBub3QgdW5kZXJzdGFuZCBhIHB1cmUgVFMgdHlwZSBoZXJlXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKEBJbmplY3Qoc3dhbFByb3ZpZGVyVG9rZW4pIHN3YWxQcm92aWRlcjogYW55KSB7XG4gICAgICAgIHRoaXMuc3dhbFByb3ZpZGVyID0gc3dhbFByb3ZpZGVyO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgc3dhbCgpOiBQcm9taXNlPHR5cGVvZiBTd2FsRGVmYXVsdD4ge1xuICAgICAgICBpZiAoIXRoaXMuc3dhbFByb21pc2VDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5wcmVsb2FkU3dlZXRBbGVydExpYnJhcnkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnN3YWxQcm9taXNlQ2FjaGUhO1xuICAgIH1cblxuICAgIHB1YmxpYyBwcmVsb2FkU3dlZXRBbGVydExpYnJhcnkoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN3YWxQcm9taXNlQ2FjaGUpIHJldHVybjtcblxuICAgICAgICBjb25zdCBsaWJQcm9taXNlID0gaXNMb2FkZXIodGhpcy5zd2FsUHJvdmlkZXIpXG4gICAgICAgICAgICA/IHRoaXMuc3dhbFByb3ZpZGVyKClcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKHRoaXMuc3dhbFByb3ZpZGVyKTtcblxuICAgICAgICB0aGlzLnN3YWxQcm9taXNlQ2FjaGUgPSBsaWJQcm9taXNlLnRoZW4odmFsdWUgPT4gaXNEZWZhdWx0RXhwb3J0KHZhbHVlKSA/IHZhbHVlIDogdmFsdWUuZGVmYXVsdCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaXNMb2FkZXIodmFsdWU6IFN3YWxQcm92aWRlcik6IHZhbHVlIGlzIFN3YWxNb2R1bGVMb2FkZXIge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAodmFsdWUgYXMgYW55KS52ZXJzaW9uID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc0RlZmF1bHRFeHBvcnQodmFsdWU6IFN3YWxNb2R1bGUpOiB2YWx1ZSBpcyB0eXBlb2YgU3dhbERlZmF1bHQge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==