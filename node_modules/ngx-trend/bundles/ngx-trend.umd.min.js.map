{"version":3,"sources":["../../node_modules/tslib/tslib.es6.js","../src/lib/helpers/math.helpers.ts","../src/lib/trend/trend.component.ts","../src/lib/helpers/misc.helpers.ts","../src/lib/trend/trend.helpers.ts","../src/lib/helpers/DOM.helpers.ts","../src/lib/trend/trend.module.ts"],"names":["Object","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","__spread","arguments","length","concat","normalize","min","max","scaleMin","scaleMax","moveTo","to","from","radius","Math","sqrt","x","y","unitVector","getDistanceBetween","p1","p2","pow","TrendComponent","this","autoDraw","autoDrawDuration","autoDrawEasing","padding","stroke","strokeLinecap","strokeWidth","gradient","svgHeight","svgWidth","animationState","id","round","random","gradientId","prototype","ngOnChanges","_this","data","plainValues","map","point","viewBoxWidth","width","viewBoxHeight","height","viewBox","root","location","href","split","hash","pathStroke","undefined","gradientTrimmed","slice","reverse","val","idx","stopColor","offset","minX","maxX","minY","maxY","boundariesX","boundariesY","normalizedData","normalizedValues","apply","index","setTimeout","lineLength","pathEl","nativeElement","getTotalLength","d","smooth","_a","firstPoint","otherPoints","reduce","path","p3","prev","isCollinear","distanceFromPrev","distanceFromNext","threshold","radiusForPoint","before","after","join","buildSmoothPath","buildLinearPath","Component","args","selector","template","animations","trigger","state","style","display","transition","animate","keyframes","stroke-dasharray","stroke-dashoffset","Input","ViewChild","NgModule","imports","CommonModule","exports","declarations"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/* eslint-disable no-restricted-properties */\n\n/** normalize\n * This lets us translate a value from one scale to another.\n *\n * @param value - Our initial value to translate\n * @param min - the current minimum value possible\n * @param max - the current maximum value possible\n * @param scaleMin - the min value of the scale we're translating to\n * @param scaleMax - the max value of the scale we're translating to\n * @returns the value on its new scale\n */\nexport function normalize(\n  value: number,\n  min: number,\n  max: number,\n  scaleMin = 0,\n  scaleMax = 1,\n): number {\n  // If the `min` and `max` are the same value, it means our dataset is flat.\n  // For now, let's assume that flat data should be aligned to the bottom.\n  if (min === max) {\n    return scaleMin;\n  }\n\n  return scaleMin + (value - min) * (scaleMax - scaleMin) / (max - min);\n}\n\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n/** moveTo\n * the coordinate that lies at a midpoint between 2 lines, based on the radius\n *\n * @param to - Our initial point\n * @param to.x - The x value of our initial point\n * @param to.y - The y value of our initial point\n * @param from - Our final point\n * @param from.x - The x value of our final point\n * @param from.y - The y value of our final point\n * @param radius - The distance away from the final point\n * @returns an object holding the x/y coordinates of the midpoint.\n */\nexport function moveTo(to: Point, from: Point, radius: number): Point {\n  const length = Math.sqrt((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y));\n  const unitVector = { x: (to.x - from.x) / length, y: (to.y - from.y) / length };\n\n  return {\n    x: from.x + unitVector.x * radius,\n    y: from.y + unitVector.y * radius,\n  };\n}\n\n/** getDistanceBetween\n * Simple formula derived from pythagoras to calculate the distance between\n * 2 points on a plane.\n *\n * @param p1 - Our initial point\n * @param p1.x - The x value of our initial point\n * @param p1.y - The y value of our initial point\n * @param p2 - Our final point\n * @param p2.x - The x value of our final point\n * @param p2.y - The y value of our final point\n * @returns the distance between the points.\n */\nexport const getDistanceBetween = (p1: Point, p2: Point): number =>\n  Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n\n/** checkForCollinearPoints\n * Figure out if the midpoint fits perfectly on a line between the two others.\n *\n * @param p1 - Our initial point\n * @param p1.x - The x value of our initial point\n * @param p1.y - The y value of our initial point\n * @param p2 - Our mid-point\n * @param p2.x - The x value of our mid-point\n * @param p2.y - The y value of our mid-point\n * @param p3 - Our final point\n * @param p3.x - The x value of our final point\n * @param p3.y - The y value of our final point\n * @returns whether or not p2 sits on the line between p1 and p3.\n */\nexport const checkForCollinearPoints = (p1: Point, p2: Point, p3: Point): boolean =>\n  (p1.y - p2.y) * (p1.x - p3.x) === (p1.y - p3.y) * (p1.x - p2.x);\n","import { animate, keyframes, state, style, transition, trigger } from '@angular/animations';\nimport { Component, ElementRef, Input, OnChanges, ViewChild } from '@angular/core';\n\nimport { buildLinearPath, buildSmoothPath } from '../helpers/DOM.helpers';\nimport { normalize } from '../helpers/math.helpers';\nimport { generateId } from '../helpers/misc.helpers';\nimport { normalizeDataset } from './trend.helpers';\n\n@Component({\n  selector: 'ngx-trend',\n  template: `\n    <svg\n      *ngIf=\"data && data.length >= 2\"\n      [attr.width]=\"svgWidth\"\n      [attr.height]=\"svgHeight\"\n      [attr.stroke]=\"stroke\"\n      [attr.stroke-width]=\"strokeWidth\"\n      [attr.stroke-linecap]=\"strokeLinecap\"\n      [attr.viewBox]=\"viewBox\"\n      [attr.preserveAspectRatio]=\"preserveAspectRatio\"\n    >\n      <defs *ngIf=\"gradient && gradient.length\">\n        <linearGradient [attr.id]=\"gradientId\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n          <stop\n            *ngFor=\"let g of gradientTrimmed\"\n            [attr.key]=\"g.idx\"\n            [attr.offset]=\"g.offset\"\n            [attr.stop-color]=\"g.stopColor\"\n          />\n        </linearGradient>\n      </defs>\n      <path\n        fill=\"none\"\n        #pathEl\n        [attr.stroke]=\"pathStroke\"\n        [attr.d]=\"d\"\n        [@pathAnimaiton]=\"{\n          value: animationState,\n          params: {\n            autoDrawDuration: autoDrawDuration,\n            autoDrawEasing: autoDrawEasing,\n            lineLength: lineLength\n          }\n        }\"\n      />\n    </svg>\n  `,\n  animations: [\n    trigger('pathAnimaiton', [\n      state('inactive', style({ display: 'none' })),\n      transition('* => active', [\n        style({ display: 'initial' }),\n        // We do the animation using the dash array/offset trick\n        // https://css-tricks.com/svg-line-animation-works/\n        animate(\n          '{{ autoDrawDuration }}ms {{ autoDrawEasing }}',\n          keyframes([\n            style({\n              'stroke-dasharray': '{{ lineLength }}px',\n              'stroke-dashoffset': '{{ lineLength }}px',\n            }),\n            style({\n              'stroke-dasharray': '{{ lineLength }}px',\n              'stroke-dashoffset': 0,\n            }),\n          ]),\n        ),\n        // One unfortunate side-effect of the auto-draw is that the line is\n        // actually 1 big dash, the same length as the line itself. If the\n        // line length changes (eg. radius change, new data), that dash won't\n        // be the same length anymore. We can fix that by removing those\n        // properties once the auto-draw is completed.\n        style({\n          'stroke-dashoffset': '',\n          'stroke-dasharray': '',\n        }),\n      ]),\n    ]),\n  ],\n})\nexport class TrendComponent implements OnChanges {\n  id: number;\n  @Input() data?: Array<(number | { value: number })>;\n  @Input() smooth?: boolean;\n  @Input() autoDraw = false;\n  @Input() autoDrawDuration = 2000;\n  @Input() autoDrawEasing = 'ease';\n  @Input() width?: number;\n  @Input() height?: number;\n  @Input() padding = 8;\n  @Input() radius = 10;\n  @Input() stroke = 'black';\n  @Input() strokeLinecap = '';\n  @Input() strokeWidth = 1;\n  @Input() gradient: string[] = [];\n  @Input() preserveAspectRatio?: string;\n  @Input() svgHeight: string | number = '25%';\n  @Input() svgWidth: string | number = '100%';\n  @ViewChild('pathEl') pathEl!: ElementRef;\n  gradientTrimmed!: Array<{ idx: number; stopColor: string; offset: number }>;\n  d: any;\n  viewBox!: string;\n  pathStroke: any;\n  gradientId: string;\n  lineLength!: number;\n  animationState = '';\n\n  constructor() {\n    this.id = generateId();\n    this.gradientId = `ngx-trend-vertical-gradient-${this.id}`;\n  }\n  ngOnChanges(): void {\n    // We need at least 2 points to draw a graph.\n    if (!this.data || this.data.length < 2) {\n      return;\n    }\n\n    // `data` can either be an array of numbers:\n    // [1, 2, 3]\n    // or, an array of objects containing a value:\n    // [{ value: 1 }, { value: 2 }, { value: 3 }]\n    //\n    // For now, we're just going to convert the second form to the first.\n    // Later on, if/when we support tooltips, we may adjust.\n    const plainValues = this.data.map(point => {\n      if (typeof point === 'number') {\n        return point;\n      }\n      return point.value;\n    });\n\n    // Our viewbox needs to be in absolute units, so we'll default to 300x75\n    // Our SVG can be a %, though; this is what makes it scalable.\n    // By defaulting to percentages, the SVG will grow to fill its parent\n    // container, preserving a 1/4 aspect ratio.\n    const viewBoxWidth = this.width || 300;\n    const viewBoxHeight = this.height || 75;\n    this.svgWidth = this.width || '100%';\n    this.svgHeight = this.height || '25%';\n    this.viewBox = `0 0 ${viewBoxWidth} ${viewBoxHeight}`;\n    const root = location.href.split(location.hash || '#')[0];\n    this.pathStroke =\n      this.gradient && this.gradient.length ? `url('${root}#${this.gradientId}')` : undefined;\n\n    this.gradientTrimmed = this.gradient\n      .slice()\n      .reverse()\n      .map((val, idx) => {\n        return {\n          idx,\n          stopColor: val,\n          offset: normalize(idx, 0, this.gradient.length - 1 || 1),\n        };\n      });\n\n    const normalizedValues = normalizeDataset(\n      plainValues,\n      this.padding,\n      viewBoxWidth - this.padding,\n      // NOTE: Because SVGs are indexed from the top left, but most data is\n      // indexed from the bottom left, we're inverting the Y min/max.\n      viewBoxHeight - this.padding,\n      this.padding,\n    );\n\n    if (this.autoDraw && this.animationState !== 'active') {\n      this.animationState = 'inactive';\n      setTimeout(() => {\n        this.lineLength = this.pathEl.nativeElement.getTotalLength();\n        this.animationState = 'active';\n      });\n    }\n\n    this.d = this.smooth\n      ? buildSmoothPath(normalizedValues, this.radius)\n      : buildLinearPath(normalizedValues);\n  }\n}\n","export const generateId = () => Math.round(Math.random() * Math.pow(10, 16));\n","import { normalize } from '../helpers/math.helpers';\n\nexport function normalizeDataset(\n  data: number[],\n  minX: number,\n  maxX: number,\n  minY: number,\n  maxY: number,\n): Array<{ x: number; y: number }> {\n  // For the X axis, we want to normalize it based on its index in the array.\n  // For the Y axis, we want to normalize it based on the element's value.\n  //\n  // X axis is easy: just evenly-space each item in the array.\n  // For the Y axis, we first need to find the min and max of our array,\n  // and then normalize those values between 0 and 1.\n  const boundariesX = { min: 0, max: data.length - 1 };\n  const boundariesY = { min: Math.min(...data), max: Math.max(...data) };\n\n  const normalizedData = data.map((point, index) => ({\n    x: normalize(index, boundariesX.min, boundariesX.max, minX, maxX),\n    y: normalize(point, boundariesY.min, boundariesY.max, minY, maxY),\n  }));\n\n  // According to the SVG spec, paths with a height/width of `0` can't have\n  // linear gradients applied. This means that our lines are invisible when\n  // the dataset is flat (eg. [0, 0, 0, 0]).\n  //\n  // The hacky solution is to apply a very slight offset to the first point of\n  // the dataset. As ugly as it is, it's the best solution we can find (there\n  // are ways within the SVG spec of changing it, but not without causing\n  // breaking changes).\n  if (boundariesY.min === boundariesY.max) {\n    normalizedData[0].y += 0.0001;\n  }\n\n  return normalizedData;\n}\n","import {\n  checkForCollinearPoints,\n  getDistanceBetween,\n  moveTo,\n  Point,\n} from './math.helpers';\n\nexport const buildLinearPath = (data: Point[]) =>\n  data.reduce((path, point, index) => {\n    // The very first instruction needs to be a \"move\".\n    // The rest will be a \"line\".\n    const isFirstInstruction = index === 0;\n    const instruction = isFirstInstruction ? 'M' : 'L';\n\n    return `${path}${instruction} ${point.x},${point.y}\\n`;\n  }, '');\n\nexport function buildSmoothPath(data: Point[], radius: number): string {\n  const [firstPoint, ...otherPoints] = data;\n\n  return otherPoints.reduce((path, point, index) => {\n    const next = otherPoints[index + 1];\n    const prev = otherPoints[index - 1] || firstPoint;\n\n    const isCollinear = next && checkForCollinearPoints(prev, point, next);\n\n    if (!next || isCollinear) {\n      // The very last line in the sequence can just be a regular line.\n      return `${path}\\nL ${point.x},${point.y}`;\n    }\n\n    const distanceFromPrev = getDistanceBetween(prev, point);\n    const distanceFromNext = getDistanceBetween(next, point);\n    const threshold = Math.min(distanceFromPrev, distanceFromNext);\n\n    const isTooCloseForRadius = threshold / 2 < radius;\n\n    const radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;\n\n    const before = moveTo(prev, point, radiusForPoint);\n    const after = moveTo(next, point, radiusForPoint);\n\n    return [\n      path,\n      `L ${before.x},${before.y}`,\n      `S ${point.x},${point.y} ${after.x},${after.y}`,\n    ].join('\\n');\n  }, `M ${firstPoint.x},${firstPoint.y}`);\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\n\nimport { TrendComponent } from './trend.component';\n\n@NgModule({\n  imports: [CommonModule],\n  exports: [TrendComponent],\n  declarations: [TrendComponent],\n})\nexport class TrendModule {\n}\n"]}