(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/common'),exports, require('@angular/animations'), require('@angular/core'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-trend', ['@angular/core','@angular/common','exports', '@angular/animations', '@angular/core', '@angular/common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ng.core,global.ng.common,global['ngx-trend'] = {}, global.ng.animations, global.ng.core, global.ng.common));
}(this, (function (ɵngcc0,ɵngcc1,exports, animations, core, common) { 
var _c0 = ["pathEl"];
function TrendComponent__svg_svg_0__svg_defs_1__svg_stop_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "stop");
} if (rf & 2) {
    var g_r4 = ctx.$implicit;
    ɵngcc0.ɵɵattribute("key", g_r4.idx)("offset", g_r4.offset)("stop-color", g_r4.stopColor);
} }
function TrendComponent__svg_svg_0__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelementStart(1, "linearGradient", 3);
    ɵngcc0.ɵɵtemplate(2, TrendComponent__svg_svg_0__svg_defs_1__svg_stop_2_Template, 1, 3, "stop", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("id", ctx_r1.gradientId);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.gradientTrimmed);
} }
var _c1 = function (a0, a1, a2) { return { autoDrawDuration: a0, autoDrawEasing: a1, lineLength: a2 }; };
var _c2 = function (a0, a1) { return { value: a0, params: a1 }; };
function TrendComponent__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "svg");
    ɵngcc0.ɵɵtemplate(1, TrendComponent__svg_svg_0__svg_defs_1_Template, 3, 2, "defs", 0);
    ɵngcc0.ɵɵelement(2, "path", 1, 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("width", ctx_r0.svgWidth)("height", ctx_r0.svgHeight)("stroke", ctx_r0.stroke)("stroke-width", ctx_r0.strokeWidth)("stroke-linecap", ctx_r0.strokeLinecap)("viewBox", ctx_r0.viewBox)("preserveAspectRatio", ctx_r0.preserveAspectRatio);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.gradient && ctx_r0.gradient.length);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("@pathAnimaiton", ɵngcc0.ɵɵpureFunction2(15, _c2, ctx_r0.animationState, ɵngcc0.ɵɵpureFunction3(11, _c1, ctx_r0.autoDrawDuration, ctx_r0.autoDrawEasing, ctx_r0.lineLength)));
    ɵngcc0.ɵɵattribute("stroke", ctx_r0.pathStroke)("d", ctx_r0.d);
} }
'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /* eslint-disable no-restricted-properties */
    /** normalize
     * This lets us translate a value from one scale to another.
     *
     * @param value - Our initial value to translate
     * @param min - the current minimum value possible
     * @param max - the current maximum value possible
     * @param scaleMin - the min value of the scale we're translating to
     * @param scaleMax - the max value of the scale we're translating to
     * @returns the value on its new scale
     */
    function normalize(value, min, max, scaleMin, scaleMax) {
        if (scaleMin === void 0) { scaleMin = 0; }
        if (scaleMax === void 0) { scaleMax = 1; }
        // If the `min` and `max` are the same value, it means our dataset is flat.
        // For now, let's assume that flat data should be aligned to the bottom.
        if (min === max) {
            return scaleMin;
        }
        return scaleMin + (value - min) * (scaleMax - scaleMin) / (max - min);
    }
    /** moveTo
     * the coordinate that lies at a midpoint between 2 lines, based on the radius
     *
     * @param to - Our initial point
     * @param to.x - The x value of our initial point
     * @param to.y - The y value of our initial point
     * @param from - Our final point
     * @param from.x - The x value of our final point
     * @param from.y - The y value of our final point
     * @param radius - The distance away from the final point
     * @returns an object holding the x/y coordinates of the midpoint.
     */
    function moveTo(to, from, radius) {
        var length = Math.sqrt((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y));
        var unitVector = { x: (to.x - from.x) / length, y: (to.y - from.y) / length };
        return {
            x: from.x + unitVector.x * radius,
            y: from.y + unitVector.y * radius,
        };
    }
    /** getDistanceBetween
     * Simple formula derived from pythagoras to calculate the distance between
     * 2 points on a plane.
     *
     * @param p1 - Our initial point
     * @param p1.x - The x value of our initial point
     * @param p1.y - The y value of our initial point
     * @param p2 - Our final point
     * @param p2.x - The x value of our final point
     * @param p2.y - The y value of our final point
     * @returns the distance between the points.
     */
    var getDistanceBetween = function (p1, p2) { return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)); };
    /** checkForCollinearPoints
     * Figure out if the midpoint fits perfectly on a line between the two others.
     *
     * @param p1 - Our initial point
     * @param p1.x - The x value of our initial point
     * @param p1.y - The y value of our initial point
     * @param p2 - Our mid-point
     * @param p2.x - The x value of our mid-point
     * @param p2.y - The y value of our mid-point
     * @param p3 - Our final point
     * @param p3.x - The x value of our final point
     * @param p3.y - The y value of our final point
     * @returns whether or not p2 sits on the line between p1 and p3.
     */
    var checkForCollinearPoints = function (p1, p2, p3) { return (p1.y - p2.y) * (p1.x - p3.x) === (p1.y - p3.y) * (p1.x - p2.x); };

    var buildLinearPath = function (data) { return data.reduce(function (path, point, index) {
        // The very first instruction needs to be a "move".
        // The rest will be a "line".
        var isFirstInstruction = index === 0;
        var instruction = isFirstInstruction ? 'M' : 'L';
        return "" + path + instruction + " " + point.x + "," + point.y + "\n";
    }, ''); };
    function buildSmoothPath(data, radius) {
        var _a = __read(data), firstPoint = _a[0], otherPoints = _a.slice(1);
        return otherPoints.reduce(function (path, point, index) {
            var next = otherPoints[index + 1];
            var prev = otherPoints[index - 1] || firstPoint;
            var isCollinear = next && checkForCollinearPoints(prev, point, next);
            if (!next || isCollinear) {
                // The very last line in the sequence can just be a regular line.
                return path + "\nL " + point.x + "," + point.y;
            }
            var distanceFromPrev = getDistanceBetween(prev, point);
            var distanceFromNext = getDistanceBetween(next, point);
            var threshold = Math.min(distanceFromPrev, distanceFromNext);
            var isTooCloseForRadius = threshold / 2 < radius;
            var radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;
            var before = moveTo(prev, point, radiusForPoint);
            var after = moveTo(next, point, radiusForPoint);
            return [
                path,
                "L " + before.x + "," + before.y,
                "S " + point.x + "," + point.y + " " + after.x + "," + after.y,
            ].join('\n');
        }, "M " + firstPoint.x + "," + firstPoint.y);
    }

    var generateId = function () { return Math.round(Math.random() * Math.pow(10, 16)); };

    function normalizeDataset(data, minX, maxX, minY, maxY) {
        // For the X axis, we want to normalize it based on its index in the array.
        // For the Y axis, we want to normalize it based on the element's value.
        //
        // X axis is easy: just evenly-space each item in the array.
        // For the Y axis, we first need to find the min and max of our array,
        // and then normalize those values between 0 and 1.
        var boundariesX = { min: 0, max: data.length - 1 };
        var boundariesY = { min: Math.min.apply(Math, __spread(data)), max: Math.max.apply(Math, __spread(data)) };
        var normalizedData = data.map(function (point, index) { return ({
            x: normalize(index, boundariesX.min, boundariesX.max, minX, maxX),
            y: normalize(point, boundariesY.min, boundariesY.max, minY, maxY),
        }); });
        // According to the SVG spec, paths with a height/width of `0` can't have
        // linear gradients applied. This means that our lines are invisible when
        // the dataset is flat (eg. [0, 0, 0, 0]).
        //
        // The hacky solution is to apply a very slight offset to the first point of
        // the dataset. As ugly as it is, it's the best solution we can find (there
        // are ways within the SVG spec of changing it, but not without causing
        // breaking changes).
        if (boundariesY.min === boundariesY.max) {
            normalizedData[0].y += 0.0001;
        }
        return normalizedData;
    }

    var TrendComponent = /** @class */ (function () {
        function TrendComponent() {
            this.autoDraw = false;
            this.autoDrawDuration = 2000;
            this.autoDrawEasing = 'ease';
            this.padding = 8;
            this.radius = 10;
            this.stroke = 'black';
            this.strokeLinecap = '';
            this.strokeWidth = 1;
            this.gradient = [];
            this.svgHeight = '25%';
            this.svgWidth = '100%';
            this.animationState = '';
            this.id = generateId();
            this.gradientId = "ngx-trend-vertical-gradient-" + this.id;
        }
        TrendComponent.prototype.ngOnChanges = function () {
            var _this = this;
            // We need at least 2 points to draw a graph.
            if (!this.data || this.data.length < 2) {
                return;
            }
            // `data` can either be an array of numbers:
            // [1, 2, 3]
            // or, an array of objects containing a value:
            // [{ value: 1 }, { value: 2 }, { value: 3 }]
            //
            // For now, we're just going to convert the second form to the first.
            // Later on, if/when we support tooltips, we may adjust.
            var plainValues = this.data.map(function (point) {
                if (typeof point === 'number') {
                    return point;
                }
                return point.value;
            });
            // Our viewbox needs to be in absolute units, so we'll default to 300x75
            // Our SVG can be a %, though; this is what makes it scalable.
            // By defaulting to percentages, the SVG will grow to fill its parent
            // container, preserving a 1/4 aspect ratio.
            var viewBoxWidth = this.width || 300;
            var viewBoxHeight = this.height || 75;
            this.svgWidth = this.width || '100%';
            this.svgHeight = this.height || '25%';
            this.viewBox = "0 0 " + viewBoxWidth + " " + viewBoxHeight;
            var root = location.href.split(location.hash || '#')[0];
            this.pathStroke =
                this.gradient && this.gradient.length ? "url('" + root + "#" + this.gradientId + "')" : undefined;
            this.gradientTrimmed = this.gradient
                .slice()
                .reverse()
                .map(function (val, idx) {
                return {
                    idx: idx,
                    stopColor: val,
                    offset: normalize(idx, 0, _this.gradient.length - 1 || 1),
                };
            });
            var normalizedValues = normalizeDataset(plainValues, this.padding, viewBoxWidth - this.padding, 
            // NOTE: Because SVGs are indexed from the top left, but most data is
            // indexed from the bottom left, we're inverting the Y min/max.
            viewBoxHeight - this.padding, this.padding);
            if (this.autoDraw && this.animationState !== 'active') {
                this.animationState = 'inactive';
                setTimeout(function () {
                    _this.lineLength = _this.pathEl.nativeElement.getTotalLength();
                    _this.animationState = 'active';
                });
            }
            this.d = this.smooth
                ? buildSmoothPath(normalizedValues, this.radius)
                : buildLinearPath(normalizedValues);
        };
TrendComponent.ɵfac = function TrendComponent_Factory(t) { return new (t || TrendComponent)(); };
TrendComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TrendComponent, selectors: [["ngx-trend"]], viewQuery: function TrendComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pathEl = _t.first);
    } }, inputs: { autoDraw: "autoDraw", autoDrawDuration: "autoDrawDuration", autoDrawEasing: "autoDrawEasing", padding: "padding", radius: "radius", stroke: "stroke", strokeLinecap: "strokeLinecap", strokeWidth: "strokeWidth", gradient: "gradient", svgHeight: "svgHeight", svgWidth: "svgWidth", data: "data", smooth: "smooth", width: "width", height: "height", preserveAspectRatio: "preserveAspectRatio" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [[4, "ngIf"], ["fill", "none"], ["pathEl", ""], ["x1", "0%", "y1", "0%", "x2", "0%", "y2", "100%"], [4, "ngFor", "ngForOf"]], template: function TrendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TrendComponent__svg_svg_0_Template, 4, 18, "svg", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.data && ctx.data.length >= 2);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf], encapsulation: 2, data: { animation: [
            animations.trigger('pathAnimaiton', [
                animations.state('inactive', animations.style({ display: 'none' })),
                animations.transition('* => active', [
                    animations.style({ display: 'initial' }),
                    // We do the animation using the dash array/offset trick
                    // https://css-tricks.com/svg-line-animation-works/
                    animations.animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', animations.keyframes([
                        animations.style({
                            'stroke-dasharray': '{{ lineLength }}px',
                            'stroke-dashoffset': '{{ lineLength }}px'
                        }),
                        animations.style({
                            'stroke-dasharray': '{{ lineLength }}px',
                            'stroke-dashoffset': 0
                        }),
                    ])),
                    // One unfortunate side-effect of the auto-draw is that the line is
                    // actually 1 big dash, the same length as the line itself. If the
                    // line length changes (eg. radius change, new data), that dash won't
                    // be the same length anymore. We can fix that by removing those
                    // properties once the auto-draw is completed.
                    animations.style({
                        'stroke-dashoffset': '',
                        'stroke-dasharray': ''
                    }),
                ]),
            ]),
        ] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TrendComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-trend',
                template: "\n    <svg\n      *ngIf=\"data && data.length >= 2\"\n      [attr.width]=\"svgWidth\"\n      [attr.height]=\"svgHeight\"\n      [attr.stroke]=\"stroke\"\n      [attr.stroke-width]=\"strokeWidth\"\n      [attr.stroke-linecap]=\"strokeLinecap\"\n      [attr.viewBox]=\"viewBox\"\n      [attr.preserveAspectRatio]=\"preserveAspectRatio\"\n    >\n      <defs *ngIf=\"gradient && gradient.length\">\n        <linearGradient [attr.id]=\"gradientId\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n          <stop\n            *ngFor=\"let g of gradientTrimmed\"\n            [attr.key]=\"g.idx\"\n            [attr.offset]=\"g.offset\"\n            [attr.stop-color]=\"g.stopColor\"\n          />\n        </linearGradient>\n      </defs>\n      <path\n        fill=\"none\"\n        #pathEl\n        [attr.stroke]=\"pathStroke\"\n        [attr.d]=\"d\"\n        [@pathAnimaiton]=\"{\n          value: animationState,\n          params: {\n            autoDrawDuration: autoDrawDuration,\n            autoDrawEasing: autoDrawEasing,\n            lineLength: lineLength\n          }\n        }\"\n      />\n    </svg>\n  ",
                animations: [
                    animations.trigger('pathAnimaiton', [
                        animations.state('inactive', animations.style({ display: 'none' })),
                        animations.transition('* => active', [
                            animations.style({ display: 'initial' }),
                            // We do the animation using the dash array/offset trick
                            // https://css-tricks.com/svg-line-animation-works/
                            animations.animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', animations.keyframes([
                                animations.style({
                                    'stroke-dasharray': '{{ lineLength }}px',
                                    'stroke-dashoffset': '{{ lineLength }}px'
                                }),
                                animations.style({
                                    'stroke-dasharray': '{{ lineLength }}px',
                                    'stroke-dashoffset': 0
                                }),
                            ])),
                            // One unfortunate side-effect of the auto-draw is that the line is
                            // actually 1 big dash, the same length as the line itself. If the
                            // line length changes (eg. radius change, new data), that dash won't
                            // be the same length anymore. We can fix that by removing those
                            // properties once the auto-draw is completed.
                            animations.style({
                                'stroke-dashoffset': '',
                                'stroke-dasharray': ''
                            }),
                        ]),
                    ]),
                ]
            }]
    }], function () { return []; }, { autoDraw: [{
            type: core.Input
        }], autoDrawDuration: [{
            type: core.Input
        }], autoDrawEasing: [{
            type: core.Input
        }], padding: [{
            type: core.Input
        }], radius: [{
            type: core.Input
        }], stroke: [{
            type: core.Input
        }], strokeLinecap: [{
            type: core.Input
        }], strokeWidth: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], svgHeight: [{
            type: core.Input
        }], svgWidth: [{
            type: core.Input
        }], data: [{
            type: core.Input
        }], smooth: [{
            type: core.Input
        }], width: [{
            type: core.Input
        }], height: [{
            type: core.Input
        }], preserveAspectRatio: [{
            type: core.Input
        }], pathEl: [{
            type: core.ViewChild,
            args: ['pathEl']
        }] }); })();
        return TrendComponent;
    }());
    TrendComponent.ctorParameters = function () { return []; };
    TrendComponent.propDecorators = {
        data: [{ type: core.Input }],
        smooth: [{ type: core.Input }],
        autoDraw: [{ type: core.Input }],
        autoDrawDuration: [{ type: core.Input }],
        autoDrawEasing: [{ type: core.Input }],
        width: [{ type: core.Input }],
        height: [{ type: core.Input }],
        padding: [{ type: core.Input }],
        radius: [{ type: core.Input }],
        stroke: [{ type: core.Input }],
        strokeLinecap: [{ type: core.Input }],
        strokeWidth: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        preserveAspectRatio: [{ type: core.Input }],
        svgHeight: [{ type: core.Input }],
        svgWidth: [{ type: core.Input }],
        pathEl: [{ type: core.ViewChild, args: ['pathEl',] }]
    };

    var TrendModule = /** @class */ (function () {
        function TrendModule() {
        }
TrendModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TrendModule });
TrendModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TrendModule_Factory(t) { return new (t || TrendModule)(); }, imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TrendModule, { declarations: [TrendComponent], imports: [ɵngcc1.CommonModule], exports: [TrendComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TrendModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                exports: [TrendComponent],
                declarations: [TrendComponent]
            }]
    }], function () { return []; }, null); })();
        return TrendModule;
    }());

    /**
     * Generated bundle index. Do not edit.
     */

    exports.TrendComponent = TrendComponent;
    exports.TrendModule = TrendModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ngx-trend.umd.js.map