import { animate, keyframes, state, style, transition, trigger } from '@angular/animations';
import { Component, Input, ViewChild } from '@angular/core';
import { buildLinearPath, buildSmoothPath } from '../helpers/DOM.helpers';
import { normalize } from '../helpers/math.helpers';
import { generateId } from '../helpers/misc.helpers';
import { normalizeDataset } from './trend.helpers';
export class TrendComponent {
    constructor() {
        this.autoDraw = false;
        this.autoDrawDuration = 2000;
        this.autoDrawEasing = 'ease';
        this.padding = 8;
        this.radius = 10;
        this.stroke = 'black';
        this.strokeLinecap = '';
        this.strokeWidth = 1;
        this.gradient = [];
        this.svgHeight = '25%';
        this.svgWidth = '100%';
        this.animationState = '';
        this.id = generateId();
        this.gradientId = `ngx-trend-vertical-gradient-${this.id}`;
    }
    ngOnChanges() {
        // We need at least 2 points to draw a graph.
        if (!this.data || this.data.length < 2) {
            return;
        }
        // `data` can either be an array of numbers:
        // [1, 2, 3]
        // or, an array of objects containing a value:
        // [{ value: 1 }, { value: 2 }, { value: 3 }]
        //
        // For now, we're just going to convert the second form to the first.
        // Later on, if/when we support tooltips, we may adjust.
        const plainValues = this.data.map(point => {
            if (typeof point === 'number') {
                return point;
            }
            return point.value;
        });
        // Our viewbox needs to be in absolute units, so we'll default to 300x75
        // Our SVG can be a %, though; this is what makes it scalable.
        // By defaulting to percentages, the SVG will grow to fill its parent
        // container, preserving a 1/4 aspect ratio.
        const viewBoxWidth = this.width || 300;
        const viewBoxHeight = this.height || 75;
        this.svgWidth = this.width || '100%';
        this.svgHeight = this.height || '25%';
        this.viewBox = `0 0 ${viewBoxWidth} ${viewBoxHeight}`;
        const root = location.href.split(location.hash || '#')[0];
        this.pathStroke =
            this.gradient && this.gradient.length ? `url('${root}#${this.gradientId}')` : undefined;
        this.gradientTrimmed = this.gradient
            .slice()
            .reverse()
            .map((val, idx) => {
            return {
                idx,
                stopColor: val,
                offset: normalize(idx, 0, this.gradient.length - 1 || 1),
            };
        });
        const normalizedValues = normalizeDataset(plainValues, this.padding, viewBoxWidth - this.padding, 
        // NOTE: Because SVGs are indexed from the top left, but most data is
        // indexed from the bottom left, we're inverting the Y min/max.
        viewBoxHeight - this.padding, this.padding);
        if (this.autoDraw && this.animationState !== 'active') {
            this.animationState = 'inactive';
            setTimeout(() => {
                this.lineLength = this.pathEl.nativeElement.getTotalLength();
                this.animationState = 'active';
            });
        }
        this.d = this.smooth
            ? buildSmoothPath(normalizedValues, this.radius)
            : buildLinearPath(normalizedValues);
    }
}
TrendComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-trend',
                template: `
    <svg
      *ngIf="data && data.length >= 2"
      [attr.width]="svgWidth"
      [attr.height]="svgHeight"
      [attr.stroke]="stroke"
      [attr.stroke-width]="strokeWidth"
      [attr.stroke-linecap]="strokeLinecap"
      [attr.viewBox]="viewBox"
      [attr.preserveAspectRatio]="preserveAspectRatio"
    >
      <defs *ngIf="gradient && gradient.length">
        <linearGradient [attr.id]="gradientId" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop
            *ngFor="let g of gradientTrimmed"
            [attr.key]="g.idx"
            [attr.offset]="g.offset"
            [attr.stop-color]="g.stopColor"
          />
        </linearGradient>
      </defs>
      <path
        fill="none"
        #pathEl
        [attr.stroke]="pathStroke"
        [attr.d]="d"
        [@pathAnimaiton]="{
          value: animationState,
          params: {
            autoDrawDuration: autoDrawDuration,
            autoDrawEasing: autoDrawEasing,
            lineLength: lineLength
          }
        }"
      />
    </svg>
  `,
                animations: [
                    trigger('pathAnimaiton', [
                        state('inactive', style({ display: 'none' })),
                        transition('* => active', [
                            style({ display: 'initial' }),
                            // We do the animation using the dash array/offset trick
                            // https://css-tricks.com/svg-line-animation-works/
                            animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', keyframes([
                                style({
                                    'stroke-dasharray': '{{ lineLength }}px',
                                    'stroke-dashoffset': '{{ lineLength }}px',
                                }),
                                style({
                                    'stroke-dasharray': '{{ lineLength }}px',
                                    'stroke-dashoffset': 0,
                                }),
                            ])),
                            // One unfortunate side-effect of the auto-draw is that the line is
                            // actually 1 big dash, the same length as the line itself. If the
                            // line length changes (eg. radius change, new data), that dash won't
                            // be the same length anymore. We can fix that by removing those
                            // properties once the auto-draw is completed.
                            style({
                                'stroke-dashoffset': '',
                                'stroke-dasharray': '',
                            }),
                        ]),
                    ]),
                ]
            },] }
];
TrendComponent.ctorParameters = () => [];
TrendComponent.propDecorators = {
    data: [{ type: Input }],
    smooth: [{ type: Input }],
    autoDraw: [{ type: Input }],
    autoDrawDuration: [{ type: Input }],
    autoDrawEasing: [{ type: Input }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    padding: [{ type: Input }],
    radius: [{ type: Input }],
    stroke: [{ type: Input }],
    strokeLinecap: [{ type: Input }],
    strokeWidth: [{ type: Input }],
    gradient: [{ type: Input }],
    preserveAspectRatio: [{ type: Input }],
    svgHeight: [{ type: Input }],
    svgWidth: [{ type: Input }],
    pathEl: [{ type: ViewChild, args: ['pathEl',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlbmQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Ii4uLy4uL3NyYy9saWIvIiwic291cmNlcyI6WyJ0cmVuZC90cmVuZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDNUYsT0FBTyxFQUFFLFNBQVMsRUFBYyxLQUFLLEVBQWEsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRW5GLE9BQU8sRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDMUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3BELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNyRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQTBFbkQsTUFBTSxPQUFPLGNBQWM7SUEyQnpCO1FBdkJTLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDakIscUJBQWdCLEdBQUcsSUFBSSxDQUFDO1FBQ3hCLG1CQUFjLEdBQUcsTUFBTSxDQUFDO1FBR3hCLFlBQU8sR0FBRyxDQUFDLENBQUM7UUFDWixXQUFNLEdBQUcsRUFBRSxDQUFDO1FBQ1osV0FBTSxHQUFHLE9BQU8sQ0FBQztRQUNqQixrQkFBYSxHQUFHLEVBQUUsQ0FBQztRQUNuQixnQkFBVyxHQUFHLENBQUMsQ0FBQztRQUNoQixhQUFRLEdBQWEsRUFBRSxDQUFDO1FBRXhCLGNBQVMsR0FBb0IsS0FBSyxDQUFDO1FBQ25DLGFBQVEsR0FBb0IsTUFBTSxDQUFDO1FBUTVDLG1CQUFjLEdBQUcsRUFBRSxDQUFDO1FBR2xCLElBQUksQ0FBQyxFQUFFLEdBQUcsVUFBVSxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLFVBQVUsR0FBRywrQkFBK0IsSUFBSSxDQUFD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LEtBQUs7d0JBQ0wsS0FBSzt1QkFDTCxLQUFLO3FCQUNMLFNBQVMsU0FBQyxRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYW5pbWF0ZSwga2V5ZnJhbWVzLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIE9uQ2hhbmdlcywgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGJ1aWxkTGluZWFyUGF0aCwgYnVpbGRTbW9vdGhQYXRoIH0gZnJvbSAnLi4vaGVscGVycy9ET00uaGVscGVycyc7XG5pbXBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuLi9oZWxwZXJzL21hdGguaGVscGVycyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vaGVscGVycy9taXNjLmhlbHBlcnMnO1xuaW1wb3J0IHsgbm9ybWFsaXplRGF0YXNldCB9IGZyb20gJy4vdHJlbmQuaGVscGVycyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25neC10cmVuZCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgPHN2Z1xuICAgICAgKm5nSWY9XCJkYXRhICYmIGRhdGEubGVuZ3RoID49IDJcIlxuICAgICAgW2F0dHIud2lkdGhdPVwic3ZnV2lkdGhcIlxuICAgICAgW2F0dHIuaGVpZ2h0XT1cInN2Z0hlaWdodFwiXG4gICAgICBbYXR0ci5zdHJva2VdPVwic3Ryb2tlXCJcbiAgICAgIFthdHRyLnN0cm9rZS13aWR0aF09XCJzdHJva2VXaWR0aFwiXG4gICAgICBbYXR0ci5zdHJva2UtbGluZWNhcF09XCJzdHJva2VMaW5lY2FwXCJcbiAgICAgIFthdHRyLnZpZXdCb3hdPVwidmlld0JveFwiXG4gICAgICBbYXR0ci5wcmVzZXJ2ZUFzcGVjdFJhdGlvXT1cInByZXNlcnZlQXNwZWN0UmF0aW9cIlxuICAgID5cbiAgICAgIDxkZWZzICpuZ0lmPVwiZ3JhZGllbnQgJiYgZ3JhZGllbnQubGVuZ3RoXCI+XG4gICAgICAgIDxsaW5lYXJHcmFkaWVudCBbYXR0ci5pZF09XCJncmFkaWVudElkXCIgeDE9XCIwJVwiIHkxPVwiMCVcIiB4Mj1cIjAlXCIgeTI9XCIxMDAlXCI+XG4gICAgICAgICAgPHN0b3BcbiAgICAgICAgICAgICpuZ0Zvcj1cImxldCBnIG9mIGdyYWRpZW50VHJpbW1lZFwiXG4gICAgICAgICAgICBbYXR0ci5rZXldPVwiZy5pZHhcIlxuICAgICAgICAgICAgW2F0dHIub2Zmc2V0XT1cImcub2Zmc2V0XCJcbiAgICAgICAgICAgIFthdHRyLnN0b3AtY29sb3JdPVwiZy5zdG9wQ29sb3JcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICA8L2RlZnM+XG4gICAgICA8cGF0aFxuICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICNwYXRoRWxcbiAgICAgICAgW2F0dHIuc3Ryb2tlXT1cInBhdGhTdHJva2VcIlxuICAgICAgICBbYXR0ci5kXT1cImRcIlxuICAgICAgICBbQHBhdGhBbmltYWl0b25dPVwie1xuICAgICAgICAgIHZhbHVlOiBhbmltYXRpb25TdGF0ZSxcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIGF1dG9EcmF3RHVyYXRpb246IGF1dG9EcmF3RHVyYXRpb24sXG4gICAgICAgICAgICBhdXRvRHJhd0Vhc2luZzogYXV0b0RyYXdFYXNpbmcsXG4gICAgICAgICAgICBsaW5lTGVuZ3RoOiBsaW5lTGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICB9XCJcbiAgICAgIC8+XG4gICAgPC9zdmc+XG4gIGAsXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCdwYXRoQW5pbWFpdG9uJywgW1xuICAgICAgc3RhdGUoJ2luYWN0aXZlJywgc3R5bGUoeyBkaXNwbGF5OiAnbm9uZScgfSkpLFxuICAgICAgdHJhbnNpdGlvbignKiA9PiBhY3RpdmUnLCBbXG4gICAgICAgIHN0eWxlKHsgZGlzcGxheTogJ2luaXRpYWwnIH0pLFxuICAgICAgICAvLyBXZSBkbyB0aGUgYW5pbWF0aW9uIHVzaW5nIHRoZSBkYXNoIGFycmF5L29mZnNldCB0cmlja1xuICAgICAgICAvLyBodHRwczovL2Nzcy10cmlja3MuY29tL3N2Zy1saW5lLWFuaW1hdGlvbi13b3Jrcy9cbiAgICAgICAgYW5pbWF0ZShcbiAgICAgICAgICAne3sgYXV0b0RyYXdEdXJhdGlvbiB9fW1zIHt7IGF1dG9EcmF3RWFzaW5nIH19JyxcbiAgICAgICAgICBrZXlmcmFtZXMoW1xuICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICd7eyBsaW5lTGVuZ3RoIH19cHgnLFxuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAne3sgbGluZUxlbmd0aCB9fXB4JyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICd7eyBsaW5lTGVuZ3RoIH19cHgnLFxuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAwLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgXSksXG4gICAgICAgICksXG4gICAgICAgIC8vIE9uZSB1bmZvcnR1bmF0ZSBzaWRlLWVmZmVjdCBvZiB0aGUgYXV0by1kcmF3IGlzIHRoYXQgdGhlIGxpbmUgaXNcbiAgICAgICAgLy8gYWN0dWFsbHkgMSBiaWcgZGFzaCwgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBsaW5lIGl0c2VsZi4gSWYgdGhlXG4gICAgICAgIC8vIGxpbmUgbGVuZ3RoIGNoYW5nZXMgKGVnLiByYWRpdXMgY2hhbmdlLCBuZXcgZGF0YSksIHRoYXQgZGFzaCB3b24ndFxuICAgICAgICAvLyBiZSB0aGUgc2FtZSBsZW5ndGggYW55bW9yZS4gV2UgY2FuIGZpeCB0aGF0IGJ5IHJlbW92aW5nIHRob3NlXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb25jZSB0aGUgYXV0by1kcmF3IGlzIGNvbXBsZXRlZC5cbiAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICdzdHJva2UtZGFzaG9mZnNldCc6ICcnLFxuICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogJycsXG4gICAgICAgIH0pLFxuICAgICAgXSksXG4gICAgXSksXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIFRyZW5kQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgaWQ6IG51bWJlcjtcbiAgQElucHV0KCkgZGF0YT86IEFycmF5PChudW1iZXIgfCB7IHZhbHVlOiBudW1iZXIgfSk+O1xuICBASW5wdXQoKSBzbW9vdGg/OiBib29sZWFuO1xuICBASW5wdXQoKSBhdXRvRHJhdyA9IGZhbHNlO1xuICBASW5wdXQoKSBhdXRvRHJhd0R1cmF0aW9uID0gMjAwMDtcbiAgQElucHV0KCkgYXV0b0RyYXdFYXNpbmcgPSAnZWFzZSc7XG4gIEBJbnB1dCgpIHdpZHRoPzogbnVtYmVyO1xuICBASW5wdXQoKSBoZWlnaHQ/OiBudW1iZXI7XG4gIEBJbnB1dCgpIHBhZGRpbmcgPSA4O1xuICBASW5wdXQoKSByYWRpdXMgPSAxMDtcbiAgQElucHV0KCkgc3Ryb2tlID0gJ2JsYWNrJztcbiAgQElucHV0KCkgc3Ryb2tlTGluZWNhcCA9ICcnO1xuICBASW5wdXQoKSBzdHJva2VXaWR0aCA9IDE7XG4gIEBJbnB1dCgpIGdyYWRpZW50OiBzdHJpbmdbXSA9IFtdO1xuICBASW5wdXQoKSBwcmVzZXJ2ZUFzcGVjdFJhdGlvPzogc3RyaW5nO1xuICBASW5wdXQoKSBzdmdIZWlnaHQ6IHN0cmluZyB8IG51bWJlciA9ICcyNSUnO1xuICBASW5wdXQoKSBzdmdXaWR0aDogc3RyaW5nIHwgbnVtYmVyID0gJzEwMCUnO1xuICBAVmlld0NoaWxkKCdwYXRoRWwnKSBwYXRoRWwhOiBFbGVtZW50UmVmO1xuICBncmFkaWVudFRyaW1tZWQhOiBBcnJheTx7IGlkeDogbnVtYmVyOyBzdG9wQ29sb3I6IHN0cmluZzsgb2Zmc2V0OiBudW1iZXIgfT47XG4gIGQ6IGFueTtcbiAgdmlld0JveCE6IHN0cmluZztcbiAgcGF0aFN0cm9rZTogYW55O1xuICBncmFkaWVudElkOiBzdHJpbmc7XG4gIGxpbmVMZW5ndGghOiBudW1iZXI7XG4gIGFuaW1hdGlvblN0YXRlID0gJyc7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICB0aGlzLmdyYWRpZW50SWQgPSBgbmd4LXRyZW5kLXZlcnRpY2FsLWdyYWRpZW50LSR7dGhpcy5pZH1gO1xuICB9XG4gIG5nT25DaGFuZ2VzKCk6IHZvaWQge1xuICAgIC8vIFdlIG5lZWQgYXQgbGVhc3QgMiBwb2ludHMgdG8gZHJhdyBhIGdyYXBoLlxuICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGF0YS5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYGRhdGFgIGNhbiBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbnVtYmVyczpcbiAgICAvLyBbMSwgMiwgM11cbiAgICAvLyBvciwgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGEgdmFsdWU6XG4gICAgLy8gW3sgdmFsdWU6IDEgfSwgeyB2YWx1ZTogMiB9LCB7IHZhbHVlOiAzIH1dXG4gICAgLy9cbiAgICAvLyBGb3Igbm93LCB3ZSdyZSBqdXN0IGdvaW5nIHRvIGNvbnZlcnQgdGhlIHNlY29uZCBmb3JtIHRvIHRoZSBmaXJzdC5cbiAgICAvLyBMYXRlciBvbiwgaWYvd2hlbiB3ZSBzdXBwb3J0IHRvb2x0aXBzLCB3ZSBtYXkgYWRqdXN0LlxuICAgIGNvbnN0IHBsYWluVmFsdWVzID0gdGhpcy5kYXRhLm1hcChwb2ludCA9PiB7XG4gICAgICBpZiAodHlwZW9mIHBvaW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9pbnQudmFsdWU7XG4gICAgfSk7XG5cbiAgICAvLyBPdXIgdmlld2JveCBuZWVkcyB0byBiZSBpbiBhYnNvbHV0ZSB1bml0cywgc28gd2UnbGwgZGVmYXVsdCB0byAzMDB4NzVcbiAgICAvLyBPdXIgU1ZHIGNhbiBiZSBhICUsIHRob3VnaDsgdGhpcyBpcyB3aGF0IG1ha2VzIGl0IHNjYWxhYmxlLlxuICAgIC8vIEJ5IGRlZmF1bHRpbmcgdG8gcGVyY2VudGFnZXMsIHRoZSBTVkcgd2lsbCBncm93IHRvIGZpbGwgaXRzIHBhcmVudFxuICAgIC8vIGNvbnRhaW5lciwgcHJlc2VydmluZyBhIDEvNCBhc3BlY3QgcmF0aW8uXG4gICAgY29uc3Qgdmlld0JveFdpZHRoID0gdGhpcy53aWR0aCB8fCAzMDA7XG4gICAgY29uc3Qgdmlld0JveEhlaWdodCA9IHRoaXMuaGVpZ2h0IHx8IDc1O1xuICAgIHRoaXMuc3ZnV2lkdGggPSB0aGlzLndpZHRoIHx8ICcxMDAlJztcbiAgICB0aGlzLnN2Z0hlaWdodCA9IHRoaXMuaGVpZ2h0IHx8ICcyNSUnO1xuICAgIHRoaXMudmlld0JveCA9IGAwIDAgJHt2aWV3Qm94V2lkdGh9ICR7dmlld0JveEhlaWdodH1gO1xuICAgIGNvbnN0IHJvb3QgPSBsb2NhdGlvbi5ocmVmLnNwbGl0KGxvY2F0aW9uLmhhc2ggfHwgJyMnKVswXTtcbiAgICB0aGlzLnBhdGhTdHJva2UgPVxuICAgICAgdGhpcy5ncmFkaWVudCAmJiB0aGlzLmdyYWRpZW50Lmxlbmd0aCA/IGB1cmwoJyR7cm9vdH0jJHt0aGlzLmdyYWRpZW50SWR9JylgIDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5ncmFkaWVudFRyaW1tZWQgPSB0aGlzLmdyYWRpZW50XG4gICAgICAuc2xpY2UoKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLm1hcCgodmFsLCBpZHgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgc3RvcENvbG9yOiB2YWwsXG4gICAgICAgICAgb2Zmc2V0OiBub3JtYWxpemUoaWR4LCAwLCB0aGlzLmdyYWRpZW50Lmxlbmd0aCAtIDEgfHwgMSksXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZXMgPSBub3JtYWxpemVEYXRhc2V0KFxuICAgICAgcGxhaW5WYWx1ZXMsXG4gICAgICB0aGlzLnBhZGRpbmcsXG4gICAgICB2aWV3Qm94V2lkdGggLSB0aGlzLnBhZGRpbmcsXG4gICAgICAvLyBOT1RFOiBCZWNhdXNlIFNWR3MgYXJlIGluZGV4ZWQgZnJvbSB0aGUgdG9wIGxlZnQsIGJ1dCBtb3N0IGRhdGEgaXNcbiAgICAgIC8vIGluZGV4ZWQgZnJvbSB0aGUgYm90dG9tIGxlZnQsIHdlJ3JlIGludmVydGluZyB0aGUgWSBtaW4vbWF4LlxuICAgICAgdmlld0JveEhlaWdodCAtIHRoaXMucGFkZGluZyxcbiAgICAgIHRoaXMucGFkZGluZyxcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuYXV0b0RyYXcgJiYgdGhpcy5hbmltYXRpb25TdGF0ZSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSAnaW5hY3RpdmUnO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IHRoaXMucGF0aEVsLm5hdGl2ZUVsZW1lbnQuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9ICdhY3RpdmUnO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5kID0gdGhpcy5zbW9vdGhcbiAgICAgID8gYnVpbGRTbW9vdGhQYXRoKG5vcm1hbGl6ZWRWYWx1ZXMsIHRoaXMucmFkaXVzKVxuICAgICAgOiBidWlsZExpbmVhclBhdGgobm9ybWFsaXplZFZhbHVlcyk7XG4gIH1cbn1cbiJdfQ==