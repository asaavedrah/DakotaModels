import { animate, keyframes, state, style, transition, trigger } from '@angular/animations';
import { Component, Input, ViewChild } from '@angular/core';
import { buildLinearPath, buildSmoothPath } from '../helpers/DOM.helpers';
import { normalize } from '../helpers/math.helpers';
import { generateId } from '../helpers/misc.helpers';
import { normalizeDataset } from './trend.helpers';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["pathEl"];
function TrendComponent__svg_svg_0__svg_defs_1__svg_stop_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "stop");
} if (rf & 2) {
    const g_r4 = ctx.$implicit;
    ɵngcc0.ɵɵattribute("key", g_r4.idx)("offset", g_r4.offset)("stop-color", g_r4.stopColor);
} }
function TrendComponent__svg_svg_0__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelementStart(1, "linearGradient", 3);
    ɵngcc0.ɵɵtemplate(2, TrendComponent__svg_svg_0__svg_defs_1__svg_stop_2_Template, 1, 3, "stop", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("id", ctx_r1.gradientId);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.gradientTrimmed);
} }
const _c1 = function (a0, a1, a2) { return { autoDrawDuration: a0, autoDrawEasing: a1, lineLength: a2 }; };
const _c2 = function (a0, a1) { return { value: a0, params: a1 }; };
function TrendComponent__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "svg");
    ɵngcc0.ɵɵtemplate(1, TrendComponent__svg_svg_0__svg_defs_1_Template, 3, 2, "defs", 0);
    ɵngcc0.ɵɵelement(2, "path", 1, 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("width", ctx_r0.svgWidth)("height", ctx_r0.svgHeight)("stroke", ctx_r0.stroke)("stroke-width", ctx_r0.strokeWidth)("stroke-linecap", ctx_r0.strokeLinecap)("viewBox", ctx_r0.viewBox)("preserveAspectRatio", ctx_r0.preserveAspectRatio);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.gradient && ctx_r0.gradient.length);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("@pathAnimaiton", ɵngcc0.ɵɵpureFunction2(15, _c2, ctx_r0.animationState, ɵngcc0.ɵɵpureFunction3(11, _c1, ctx_r0.autoDrawDuration, ctx_r0.autoDrawEasing, ctx_r0.lineLength)));
    ɵngcc0.ɵɵattribute("stroke", ctx_r0.pathStroke)("d", ctx_r0.d);
} }
export class TrendComponent {
    constructor() {
        this.autoDraw = false;
        this.autoDrawDuration = 2000;
        this.autoDrawEasing = 'ease';
        this.padding = 8;
        this.radius = 10;
        this.stroke = 'black';
        this.strokeLinecap = '';
        this.strokeWidth = 1;
        this.gradient = [];
        this.svgHeight = '25%';
        this.svgWidth = '100%';
        this.animationState = '';
        this.id = generateId();
        this.gradientId = `ngx-trend-vertical-gradient-${this.id}`;
    }
    ngOnChanges() {
        // We need at least 2 points to draw a graph.
        if (!this.data || this.data.length < 2) {
            return;
        }
        // `data` can either be an array of numbers:
        // [1, 2, 3]
        // or, an array of objects containing a value:
        // [{ value: 1 }, { value: 2 }, { value: 3 }]
        //
        // For now, we're just going to convert the second form to the first.
        // Later on, if/when we support tooltips, we may adjust.
        const plainValues = this.data.map(point => {
            if (typeof point === 'number') {
                return point;
            }
            return point.value;
        });
        // Our viewbox needs to be in absolute units, so we'll default to 300x75
        // Our SVG can be a %, though; this is what makes it scalable.
        // By defaulting to percentages, the SVG will grow to fill its parent
        // container, preserving a 1/4 aspect ratio.
        const viewBoxWidth = this.width || 300;
        const viewBoxHeight = this.height || 75;
        this.svgWidth = this.width || '100%';
        this.svgHeight = this.height || '25%';
        this.viewBox = `0 0 ${viewBoxWidth} ${viewBoxHeight}`;
        const root = location.href.split(location.hash || '#')[0];
        this.pathStroke =
            this.gradient && this.gradient.length ? `url('${root}#${this.gradientId}')` : undefined;
        this.gradientTrimmed = this.gradient
            .slice()
            .reverse()
            .map((val, idx) => {
            return {
                idx,
                stopColor: val,
                offset: normalize(idx, 0, this.gradient.length - 1 || 1),
            };
        });
        const normalizedValues = normalizeDataset(plainValues, this.padding, viewBoxWidth - this.padding, 
        // NOTE: Because SVGs are indexed from the top left, but most data is
        // indexed from the bottom left, we're inverting the Y min/max.
        viewBoxHeight - this.padding, this.padding);
        if (this.autoDraw && this.animationState !== 'active') {
            this.animationState = 'inactive';
            setTimeout(() => {
                this.lineLength = this.pathEl.nativeElement.getTotalLength();
                this.animationState = 'active';
            });
        }
        this.d = this.smooth
            ? buildSmoothPath(normalizedValues, this.radius)
            : buildLinearPath(normalizedValues);
    }
}
TrendComponent.ɵfac = function TrendComponent_Factory(t) { return new (t || TrendComponent)(); };
TrendComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TrendComponent, selectors: [["ngx-trend"]], viewQuery: function TrendComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pathEl = _t.first);
    } }, inputs: { autoDraw: "autoDraw", autoDrawDuration: "autoDrawDuration", autoDrawEasing: "autoDrawEasing", padding: "padding", radius: "radius", stroke: "stroke", strokeLinecap: "strokeLinecap", strokeWidth: "strokeWidth", gradient: "gradient", svgHeight: "svgHeight", svgWidth: "svgWidth", data: "data", smooth: "smooth", width: "width", height: "height", preserveAspectRatio: "preserveAspectRatio" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [[4, "ngIf"], ["fill", "none"], ["pathEl", ""], ["x1", "0%", "y1", "0%", "x2", "0%", "y2", "100%"], [4, "ngFor", "ngForOf"]], template: function TrendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TrendComponent__svg_svg_0_Template, 4, 18, "svg", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.data && ctx.data.length >= 2);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf], encapsulation: 2, data: { animation: [
            trigger('pathAnimaiton', [
                state('inactive', style({ display: 'none' })),
                transition('* => active', [
                    style({ display: 'initial' }),
                    // We do the animation using the dash array/offset trick
                    // https://css-tricks.com/svg-line-animation-works/
                    animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', keyframes([
                        style({
                            'stroke-dasharray': '{{ lineLength }}px',
                            'stroke-dashoffset': '{{ lineLength }}px'
                        }),
                        style({
                            'stroke-dasharray': '{{ lineLength }}px',
                            'stroke-dashoffset': 0
                        }),
                    ])),
                    // One unfortunate side-effect of the auto-draw is that the line is
                    // actually 1 big dash, the same length as the line itself. If the
                    // line length changes (eg. radius change, new data), that dash won't
                    // be the same length anymore. We can fix that by removing those
                    // properties once the auto-draw is completed.
                    style({
                        'stroke-dashoffset': '',
                        'stroke-dasharray': ''
                    }),
                ]),
            ]),
        ] } });
TrendComponent.ctorParameters = () => [];
TrendComponent.propDecorators = {
    data: [{ type: Input }],
    smooth: [{ type: Input }],
    autoDraw: [{ type: Input }],
    autoDrawDuration: [{ type: Input }],
    autoDrawEasing: [{ type: Input }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    padding: [{ type: Input }],
    radius: [{ type: Input }],
    stroke: [{ type: Input }],
    strokeLinecap: [{ type: Input }],
    strokeWidth: [{ type: Input }],
    gradient: [{ type: Input }],
    preserveAspectRatio: [{ type: Input }],
    svgHeight: [{ type: Input }],
    svgWidth: [{ type: Input }],
    pathEl: [{ type: ViewChild, args: ['pathEl',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TrendComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-trend',
                template: `
    <svg
      *ngIf="data && data.length >= 2"
      [attr.width]="svgWidth"
      [attr.height]="svgHeight"
      [attr.stroke]="stroke"
      [attr.stroke-width]="strokeWidth"
      [attr.stroke-linecap]="strokeLinecap"
      [attr.viewBox]="viewBox"
      [attr.preserveAspectRatio]="preserveAspectRatio"
    >
      <defs *ngIf="gradient && gradient.length">
        <linearGradient [attr.id]="gradientId" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop
            *ngFor="let g of gradientTrimmed"
            [attr.key]="g.idx"
            [attr.offset]="g.offset"
            [attr.stop-color]="g.stopColor"
          />
        </linearGradient>
      </defs>
      <path
        fill="none"
        #pathEl
        [attr.stroke]="pathStroke"
        [attr.d]="d"
        [@pathAnimaiton]="{
          value: animationState,
          params: {
            autoDrawDuration: autoDrawDuration,
            autoDrawEasing: autoDrawEasing,
            lineLength: lineLength
          }
        }"
      />
    </svg>
  `,
                animations: [
                    trigger('pathAnimaiton', [
                        state('inactive', style({ display: 'none' })),
                        transition('* => active', [
                            style({ display: 'initial' }),
                            // We do the animation using the dash array/offset trick
                            // https://css-tricks.com/svg-line-animation-works/
                            animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', keyframes([
                                style({
                                    'stroke-dasharray': '{{ lineLength }}px',
                                    'stroke-dashoffset': '{{ lineLength }}px'
                                }),
                                style({
                                    'stroke-dasharray': '{{ lineLength }}px',
                                    'stroke-dashoffset': 0
                                }),
                            ])),
                            // One unfortunate side-effect of the auto-draw is that the line is
                            // actually 1 big dash, the same length as the line itself. If the
                            // line length changes (eg. radius change, new data), that dash won't
                            // be the same length anymore. We can fix that by removing those
                            // properties once the auto-draw is completed.
                            style({
                                'stroke-dashoffset': '',
                                'stroke-dasharray': ''
                            }),
                        ]),
                    ]),
                ]
            }]
    }], function () { return []; }, { autoDraw: [{
            type: Input
        }], autoDrawDuration: [{
            type: Input
        }], autoDrawEasing: [{
            type: Input
        }], padding: [{
            type: Input
        }], radius: [{
            type: Input
        }], stroke: [{
            type: Input
        }], strokeLinecap: [{
            type: Input
        }], strokeWidth: [{
            type: Input
        }], gradient: [{
            type: Input
        }], svgHeight: [{
            type: Input
        }], svgWidth: [{
            type: Input
        }], data: [{
            type: Input
        }], smooth: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], preserveAspectRatio: [{
            type: Input
        }], pathEl: [{
            type: ViewChild,
            args: ['pathEl']
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlbmQuY29tcG9uZW50LmpzIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbGliL3RyZW5kL3RyZW5kLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUM1RixPQUFPLEVBQUUsU0FBUyxFQUFjLEtBQUssRUFBYSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFbkYsT0FBTyxFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUMxRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDcEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3JELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEVuRCxNQUFNLE9BQU8sY0FBYztBQUFHLElBMkI1QjtBQUNGLFFBeEJXLGFBQVEsR0FBRyxLQUFLLENBQUM7QUFDNUIsUUFBVyxxQkFBZ0IsR0FBRyxJQUFJLENBQUM7QUFDbkMsUUFBVyxtQkFBYyxHQUFHLE1BQU0sQ0FBQztBQUNuQyxRQUVXLFlBQU8sR0FBRyxDQUFDLENBQUM7QUFDdkIsUUFBVyxXQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ3ZCLFFBQVcsV0FBTSxHQUFHLE9BQU8sQ0FBQztBQUM1QixRQUFXLGtCQUFhLEdBQUcsRUFBRSxDQUFDO0FBQzlCLFFBQVcsZ0JBQVcsR0FBRyxDQUFDLENBQUM7QUFDM0IsUUFBVyxhQUFRLEdBQWEsRUFBRSxDQUFDO0FBQ25DLFFBQ1csY0FBUyxHQUFvQixLQUFLLENBQUM7QUFDOUMsUUFBVyxhQUFRLEdBQW9CLE1BQU0sQ0FBQztBQUM5QyxRQU9FLG1CQUFjLEdBQUcs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O2lDQUN2QixDQUFDO2NBQ0gsQ0FBQyxDQUNIO2tCQUNEOzREQUFtRTtDQUNuRSxrRUFBa0U7U0FDbEUscUVBQXFFO2lCQUNyRSxnRUFBZ0U7eUJBQ2hFO0lBQThDO0tBQzlDLEtBQUssQ0FBQyxrQ0FDSjtlQUFtQixFQUFFLEVBQUU7TUFDdkI7QUFBa0IsRUFBRSxFQUFFO2VBQ3ZCO0FBQUMsZUFLTDtXQUpFLENBQUMsdUJBQ0gsQ0FBQyxwQ0FHQTthQUZILGNBQ0YsM0JBQytDO0FBRS9CLG1CQUFkLEtBQUs7QUFBSyxxQkFDVixLQUFLO0FBQUssdUJBQ1YsS0FBSztBQUFLLCtCQUNWLEtBQUs7QUFBSyw2QkFDVixLQUFLO0FBQUssb0JBQ1YsS0FBSztBQUFLLHFCQUNWLEtBQUs7QUFBSyxzQkFDVixLQUFLO0FBQUsscUJBQ1YsS0FBSztBQUFLLHFCQUNWLEtBQUs7QUFBSyw0QkFDVixLQUFLO0FBQUssMEJBQ1YsS0FBSztBQUFLLHVCQUNWLEtBQUs7QUFBSyxrQ0FDVixLQUFLO0FBQUssd0JBQ1YsS0FBSztBQUFLLHVCQUNWLEtBQUs7QUFBSyxxQkFDVixTQUFTLFNBQUMsUUFBUTtBQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYW5pbWF0ZSwga2V5ZnJhbWVzLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIE9uQ2hhbmdlcywgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGJ1aWxkTGluZWFyUGF0aCwgYnVpbGRTbW9vdGhQYXRoIH0gZnJvbSAnLi4vaGVscGVycy9ET00uaGVscGVycyc7XG5pbXBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuLi9oZWxwZXJzL21hdGguaGVscGVycyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vaGVscGVycy9taXNjLmhlbHBlcnMnO1xuaW1wb3J0IHsgbm9ybWFsaXplRGF0YXNldCB9IGZyb20gJy4vdHJlbmQuaGVscGVycyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25neC10cmVuZCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgPHN2Z1xuICAgICAgKm5nSWY9XCJkYXRhICYmIGRhdGEubGVuZ3RoID49IDJcIlxuICAgICAgW2F0dHIud2lkdGhdPVwic3ZnV2lkdGhcIlxuICAgICAgW2F0dHIuaGVpZ2h0XT1cInN2Z0hlaWdodFwiXG4gICAgICBbYXR0ci5zdHJva2VdPVwic3Ryb2tlXCJcbiAgICAgIFthdHRyLnN0cm9rZS13aWR0aF09XCJzdHJva2VXaWR0aFwiXG4gICAgICBbYXR0ci5zdHJva2UtbGluZWNhcF09XCJzdHJva2VMaW5lY2FwXCJcbiAgICAgIFthdHRyLnZpZXdCb3hdPVwidmlld0JveFwiXG4gICAgICBbYXR0ci5wcmVzZXJ2ZUFzcGVjdFJhdGlvXT1cInByZXNlcnZlQXNwZWN0UmF0aW9cIlxuICAgID5cbiAgICAgIDxkZWZzICpuZ0lmPVwiZ3JhZGllbnQgJiYgZ3JhZGllbnQubGVuZ3RoXCI+XG4gICAgICAgIDxsaW5lYXJHcmFkaWVudCBbYXR0ci5pZF09XCJncmFkaWVudElkXCIgeDE9XCIwJVwiIHkxPVwiMCVcIiB4Mj1cIjAlXCIgeTI9XCIxMDAlXCI+XG4gICAgICAgICAgPHN0b3BcbiAgICAgICAgICAgICpuZ0Zvcj1cImxldCBnIG9mIGdyYWRpZW50VHJpbW1lZFwiXG4gICAgICAgICAgICBbYXR0ci5rZXldPVwiZy5pZHhcIlxuICAgICAgICAgICAgW2F0dHIub2Zmc2V0XT1cImcub2Zmc2V0XCJcbiAgICAgICAgICAgIFthdHRyLnN0b3AtY29sb3JdPVwiZy5zdG9wQ29sb3JcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICA8L2RlZnM+XG4gICAgICA8cGF0aFxuICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICNwYXRoRWxcbiAgICAgICAgW2F0dHIuc3Ryb2tlXT1cInBhdGhTdHJva2VcIlxuICAgICAgICBbYXR0ci5kXT1cImRcIlxuICAgICAgICBbQHBhdGhBbmltYWl0b25dPVwie1xuICAgICAgICAgIHZhbHVlOiBhbmltYXRpb25TdGF0ZSxcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIGF1dG9EcmF3RHVyYXRpb246IGF1dG9EcmF3RHVyYXRpb24sXG4gICAgICAgICAgICBhdXRvRHJhd0Vhc2luZzogYXV0b0RyYXdFYXNpbmcsXG4gICAgICAgICAgICBsaW5lTGVuZ3RoOiBsaW5lTGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICB9XCJcbiAgICAgIC8+XG4gICAgPC9zdmc+XG4gIGAsXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCdwYXRoQW5pbWFpdG9uJywgW1xuICAgICAgc3RhdGUoJ2luYWN0aXZlJywgc3R5bGUoeyBkaXNwbGF5OiAnbm9uZScgfSkpLFxuICAgICAgdHJhbnNpdGlvbignKiA9PiBhY3RpdmUnLCBbXG4gICAgICAgIHN0eWxlKHsgZGlzcGxheTogJ2luaXRpYWwnIH0pLFxuICAgICAgICAvLyBXZSBkbyB0aGUgYW5pbWF0aW9uIHVzaW5nIHRoZSBkYXNoIGFycmF5L29mZnNldCB0cmlja1xuICAgICAgICAvLyBodHRwczovL2Nzcy10cmlja3MuY29tL3N2Zy1saW5lLWFuaW1hdGlvbi13b3Jrcy9cbiAgICAgICAgYW5pbWF0ZShcbiAgICAgICAgICAne3sgYXV0b0RyYXdEdXJhdGlvbiB9fW1zIHt7IGF1dG9EcmF3RWFzaW5nIH19JyxcbiAgICAgICAgICBrZXlmcmFtZXMoW1xuICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICd7eyBsaW5lTGVuZ3RoIH19cHgnLFxuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAne3sgbGluZUxlbmd0aCB9fXB4JyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICd7eyBsaW5lTGVuZ3RoIH19cHgnLFxuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAwLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgXSksXG4gICAgICAgICksXG4gICAgICAgIC8vIE9uZSB1bmZvcnR1bmF0ZSBzaWRlLWVmZmVjdCBvZiB0aGUgYXV0by1kcmF3IGlzIHRoYXQgdGhlIGxpbmUgaXNcbiAgICAgICAgLy8gYWN0dWFsbHkgMSBiaWcgZGFzaCwgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBsaW5lIGl0c2VsZi4gSWYgdGhlXG4gICAgICAgIC8vIGxpbmUgbGVuZ3RoIGNoYW5nZXMgKGVnLiByYWRpdXMgY2hhbmdlLCBuZXcgZGF0YSksIHRoYXQgZGFzaCB3b24ndFxuICAgICAgICAvLyBiZSB0aGUgc2FtZSBsZW5ndGggYW55bW9yZS4gV2UgY2FuIGZpeCB0aGF0IGJ5IHJlbW92aW5nIHRob3NlXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb25jZSB0aGUgYXV0by1kcmF3IGlzIGNvbXBsZXRlZC5cbiAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICdzdHJva2UtZGFzaG9mZnNldCc6ICcnLFxuICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogJycsXG4gICAgICAgIH0pLFxuICAgICAgXSksXG4gICAgXSksXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIFRyZW5kQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgaWQ6IG51bWJlcjtcbiAgQElucHV0KCkgZGF0YT86IEFycmF5PChudW1iZXIgfCB7IHZhbHVlOiBudW1iZXIgfSk+O1xuICBASW5wdXQoKSBzbW9vdGg/OiBib29sZWFuO1xuICBASW5wdXQoKSBhdXRvRHJhdyA9IGZhbHNlO1xuICBASW5wdXQoKSBhdXRvRHJhd0R1cmF0aW9uID0gMjAwMDtcbiAgQElucHV0KCkgYXV0b0RyYXdFYXNpbmcgPSAnZWFzZSc7XG4gIEBJbnB1dCgpIHdpZHRoPzogbnVtYmVyO1xuICBASW5wdXQoKSBoZWlnaHQ/OiBudW1iZXI7XG4gIEBJbnB1dCgpIHBhZGRpbmcgPSA4O1xuICBASW5wdXQoKSByYWRpdXMgPSAxMDtcbiAgQElucHV0KCkgc3Ryb2tlID0gJ2JsYWNrJztcbiAgQElucHV0KCkgc3Ryb2tlTGluZWNhcCA9ICcnO1xuICBASW5wdXQoKSBzdHJva2VXaWR0aCA9IDE7XG4gIEBJbnB1dCgpIGdyYWRpZW50OiBzdHJpbmdbXSA9IFtdO1xuICBASW5wdXQoKSBwcmVzZXJ2ZUFzcGVjdFJhdGlvPzogc3RyaW5nO1xuICBASW5wdXQoKSBzdmdIZWlnaHQ6IHN0cmluZyB8IG51bWJlciA9ICcyNSUnO1xuICBASW5wdXQoKSBzdmdXaWR0aDogc3RyaW5nIHwgbnVtYmVyID0gJzEwMCUnO1xuICBAVmlld0NoaWxkKCdwYXRoRWwnKSBwYXRoRWwhOiBFbGVtZW50UmVmO1xuICBncmFkaWVudFRyaW1tZWQhOiBBcnJheTx7IGlkeDogbnVtYmVyOyBzdG9wQ29sb3I6IHN0cmluZzsgb2Zmc2V0OiBudW1iZXIgfT47XG4gIGQ6IGFueTtcbiAgdmlld0JveCE6IHN0cmluZztcbiAgcGF0aFN0cm9rZTogYW55O1xuICBncmFkaWVudElkOiBzdHJpbmc7XG4gIGxpbmVMZW5ndGghOiBudW1iZXI7XG4gIGFuaW1hdGlvblN0YXRlID0gJyc7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICB0aGlzLmdyYWRpZW50SWQgPSBgbmd4LXRyZW5kLXZlcnRpY2FsLWdyYWRpZW50LSR7dGhpcy5pZH1gO1xuICB9XG4gIG5nT25DaGFuZ2VzKCk6IHZvaWQge1xuICAgIC8vIFdlIG5lZWQgYXQgbGVhc3QgMiBwb2ludHMgdG8gZHJhdyBhIGdyYXBoLlxuICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGF0YS5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYGRhdGFgIGNhbiBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbnVtYmVyczpcbiAgICAvLyBbMSwgMiwgM11cbiAgICAvLyBvciwgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGEgdmFsdWU6XG4gICAgLy8gW3sgdmFsdWU6IDEgfSwgeyB2YWx1ZTogMiB9LCB7IHZhbHVlOiAzIH1dXG4gICAgLy9cbiAgICAvLyBGb3Igbm93LCB3ZSdyZSBqdXN0IGdvaW5nIHRvIGNvbnZlcnQgdGhlIHNlY29uZCBmb3JtIHRvIHRoZSBmaXJzdC5cbiAgICAvLyBMYXRlciBvbiwgaWYvd2hlbiB3ZSBzdXBwb3J0IHRvb2x0aXBzLCB3ZSBtYXkgYWRqdXN0LlxuICAgIGNvbnN0IHBsYWluVmFsdWVzID0gdGhpcy5kYXRhLm1hcChwb2ludCA9PiB7XG4gICAgICBpZiAodHlwZW9mIHBvaW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9pbnQudmFsdWU7XG4gICAgfSk7XG5cbiAgICAvLyBPdXIgdmlld2JveCBuZWVkcyB0byBiZSBpbiBhYnNvbHV0ZSB1bml0cywgc28gd2UnbGwgZGVmYXVsdCB0byAzMDB4NzVcbiAgICAvLyBPdXIgU1ZHIGNhbiBiZSBhICUsIHRob3VnaDsgdGhpcyBpcyB3aGF0IG1ha2VzIGl0IHNjYWxhYmxlLlxuICAgIC8vIEJ5IGRlZmF1bHRpbmcgdG8gcGVyY2VudGFnZXMsIHRoZSBTVkcgd2lsbCBncm93IHRvIGZpbGwgaXRzIHBhcmVudFxuICAgIC8vIGNvbnRhaW5lciwgcHJlc2VydmluZyBhIDEvNCBhc3BlY3QgcmF0aW8uXG4gICAgY29uc3Qgdmlld0JveFdpZHRoID0gdGhpcy53aWR0aCB8fCAzMDA7XG4gICAgY29uc3Qgdmlld0JveEhlaWdodCA9IHRoaXMuaGVpZ2h0IHx8IDc1O1xuICAgIHRoaXMuc3ZnV2lkdGggPSB0aGlzLndpZHRoIHx8ICcxMDAlJztcbiAgICB0aGlzLnN2Z0hlaWdodCA9IHRoaXMuaGVpZ2h0IHx8ICcyNSUnO1xuICAgIHRoaXMudmlld0JveCA9IGAwIDAgJHt2aWV3Qm94V2lkdGh9ICR7dmlld0JveEhlaWdodH1gO1xuICAgIGNvbnN0IHJvb3QgPSBsb2NhdGlvbi5ocmVmLnNwbGl0KGxvY2F0aW9uLmhhc2ggfHwgJyMnKVswXTtcbiAgICB0aGlzLnBhdGhTdHJva2UgPVxuICAgICAgdGhpcy5ncmFkaWVudCAmJiB0aGlzLmdyYWRpZW50Lmxlbmd0aCA/IGB1cmwoJyR7cm9vdH0jJHt0aGlzLmdyYWRpZW50SWR9JylgIDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5ncmFkaWVudFRyaW1tZWQgPSB0aGlzLmdyYWRpZW50XG4gICAgICAuc2xpY2UoKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLm1hcCgodmFsLCBpZHgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgc3RvcENvbG9yOiB2YWwsXG4gICAgICAgICAgb2Zmc2V0OiBub3JtYWxpemUoaWR4LCAwLCB0aGlzLmdyYWRpZW50Lmxlbmd0aCAtIDEgfHwgMSksXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZXMgPSBub3JtYWxpemVEYXRhc2V0KFxuICAgICAgcGxhaW5WYWx1ZXMsXG4gICAgICB0aGlzLnBhZGRpbmcsXG4gICAgICB2aWV3Qm94V2lkdGggLSB0aGlzLnBhZGRpbmcsXG4gICAgICAvLyBOT1RFOiBCZWNhdXNlIFNWR3MgYXJlIGluZGV4ZWQgZnJvbSB0aGUgdG9wIGxlZnQsIGJ1dCBtb3N0IGRhdGEgaXNcbiAgICAgIC8vIGluZGV4ZWQgZnJvbSB0aGUgYm90dG9tIGxlZnQsIHdlJ3JlIGludmVydGluZyB0aGUgWSBtaW4vbWF4LlxuICAgICAgdmlld0JveEhlaWdodCAtIHRoaXMucGFkZGluZyxcbiAgICAgIHRoaXMucGFkZGluZyxcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuYXV0b0RyYXcgJiYgdGhpcy5hbmltYXRpb25TdGF0ZSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSAnaW5hY3RpdmUnO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IHRoaXMucGF0aEVsLm5hdGl2ZUVsZW1lbnQuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9ICdhY3RpdmUnO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5kID0gdGhpcy5zbW9vdGhcbiAgICAgID8gYnVpbGRTbW9vdGhQYXRoKG5vcm1hbGl6ZWRWYWx1ZXMsIHRoaXMucmFkaXVzKVxuICAgICAgOiBidWlsZExpbmVhclBhdGgobm9ybWFsaXplZFZhbHVlcyk7XG4gIH1cbn1cbiJdfQ==