{"ast":null,"code":"import _slicedToArray from \"C:/Users/DTI_UCH/Desktop/template_angularjs10/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:/Users/DTI_UCH/Desktop/template_angularjs10/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/DTI_UCH/Desktop/template_angularjs10/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { isPlatformBrowser } from '@angular/common';\nimport { Directive, Renderer2, ElementRef, Output, Input, EventEmitter, NgZone, Inject, PLATFORM_ID, NgModule } from '@angular/core';\nimport { Subject, Observable, merge, EMPTY, fromEvent } from 'rxjs';\nimport { map, mergeMap, takeUntil, filter, pairwise, take, share, auditTime, switchMap, startWith, tap } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @hidden\n * @type {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar IS_TOUCH_DEVICE = /*@__PURE__*/function () {\n  // In case we're in Node.js environment.\n  if (typeof window === 'undefined') {\n    return false;\n  } else {\n    return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;\n  }\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} value1\n * @param {?} value2\n * @param {?=} precision\n * @return {?}\n */\n\n\nfunction isNumberCloseTo(value1, value2) {\n  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n\n  /** @type {?} */\n  var diff = Math.abs(value1 - value2);\n  return diff < precision;\n}\n/**\n * @param {?} startingRect\n * @param {?} edges\n * @param {?} clientX\n * @param {?} clientY\n * @return {?}\n */\n\n\nfunction getNewBoundingRectangle(startingRect, edges, clientX, clientY) {\n  /** @type {?} */\n  var newBoundingRect = {\n    top: startingRect.top,\n    bottom: startingRect.bottom,\n    left: startingRect.left,\n    right: startingRect.right\n  };\n\n  if (edges.top) {\n    newBoundingRect.top += clientY;\n  }\n\n  if (edges.bottom) {\n    newBoundingRect.bottom += clientY;\n  }\n\n  if (edges.left) {\n    newBoundingRect.left += clientX;\n  }\n\n  if (edges.right) {\n    newBoundingRect.right += clientX;\n  }\n\n  newBoundingRect.height = newBoundingRect.bottom - newBoundingRect.top;\n  newBoundingRect.width = newBoundingRect.right - newBoundingRect.left;\n  return newBoundingRect;\n}\n/**\n * @param {?} element\n * @param {?} ghostElementPositioning\n * @return {?}\n */\n\n\nfunction getElementRect(element, ghostElementPositioning) {\n  /** @type {?} */\n  var translateX = 0;\n  /** @type {?} */\n\n  var translateY = 0;\n  /** @type {?} */\n\n  var style = element.nativeElement.style;\n  /** @type {?} */\n\n  var transformProperties = ['transform', '-ms-transform', '-moz-transform', '-o-transform'];\n  /** @type {?} */\n\n  var transform = transformProperties.map(function (property) {\n    return style[property];\n  }).find(function (value) {\n    return !!value;\n  });\n\n  if (transform && transform.includes('translate')) {\n    translateX = transform.replace(/.*translate3?d?\\((-?[0-9]*)px, (-?[0-9]*)px.*/, '$1');\n    translateY = transform.replace(/.*translate3?d?\\((-?[0-9]*)px, (-?[0-9]*)px.*/, '$2');\n  }\n\n  if (ghostElementPositioning === 'absolute') {\n    return {\n      height: element.nativeElement.offsetHeight,\n      width: element.nativeElement.offsetWidth,\n      top: element.nativeElement.offsetTop - translateY,\n      bottom: element.nativeElement.offsetHeight + element.nativeElement.offsetTop - translateY,\n      left: element.nativeElement.offsetLeft - translateX,\n      right: element.nativeElement.offsetWidth + element.nativeElement.offsetLeft - translateX\n    };\n  } else {\n    /** @type {?} */\n    var boundingRect = element.nativeElement.getBoundingClientRect();\n    return {\n      height: boundingRect.height,\n      width: boundingRect.width,\n      top: boundingRect.top - translateY,\n      bottom: boundingRect.bottom - translateY,\n      left: boundingRect.left - translateX,\n      right: boundingRect.right - translateX,\n      scrollTop: element.nativeElement.scrollTop,\n      scrollLeft: element.nativeElement.scrollLeft\n    };\n  }\n}\n/**\n * @param {?} __0\n * @return {?}\n */\n\n\nfunction isWithinBoundingY(_ref) {\n  var clientY = _ref.clientY,\n      rect = _ref.rect;\n  return clientY >= rect.top && clientY <= rect.bottom;\n}\n/**\n * @param {?} __0\n * @return {?}\n */\n\n\nfunction isWithinBoundingX(_ref2) {\n  var clientX = _ref2.clientX,\n      rect = _ref2.rect;\n  return clientX >= rect.left && clientX <= rect.right;\n}\n/**\n * @param {?} __0\n * @return {?}\n */\n\n\nfunction getResizeEdges(_ref3) {\n  var clientX = _ref3.clientX,\n      clientY = _ref3.clientY,\n      elm = _ref3.elm,\n      allowedEdges = _ref3.allowedEdges,\n      cursorPrecision = _ref3.cursorPrecision;\n\n  /** @type {?} */\n  var elmPosition = elm.nativeElement.getBoundingClientRect();\n  /** @type {?} */\n\n  var edges = {};\n\n  if (allowedEdges.left && isNumberCloseTo(clientX, elmPosition.left, cursorPrecision) && isWithinBoundingY({\n    clientY: clientY,\n    rect: elmPosition\n  })) {\n    edges.left = true;\n  }\n\n  if (allowedEdges.right && isNumberCloseTo(clientX, elmPosition.right, cursorPrecision) && isWithinBoundingY({\n    clientY: clientY,\n    rect: elmPosition\n  })) {\n    edges.right = true;\n  }\n\n  if (allowedEdges.top && isNumberCloseTo(clientY, elmPosition.top, cursorPrecision) && isWithinBoundingX({\n    clientX: clientX,\n    rect: elmPosition\n  })) {\n    edges.top = true;\n  }\n\n  if (allowedEdges.bottom && isNumberCloseTo(clientY, elmPosition.bottom, cursorPrecision) && isWithinBoundingX({\n    clientX: clientX,\n    rect: elmPosition\n  })) {\n    edges.bottom = true;\n  }\n\n  return edges;\n}\n/** @type {?} */\n\n\nvar DEFAULT_RESIZE_CURSORS = /*@__PURE__*/Object.freeze({\n  topLeft: 'nw-resize',\n  topRight: 'ne-resize',\n  bottomLeft: 'sw-resize',\n  bottomRight: 'se-resize',\n  leftOrRight: 'col-resize',\n  topOrBottom: 'row-resize'\n});\n/**\n * @param {?} edges\n * @param {?} cursors\n * @return {?}\n */\n\nfunction getResizeCursor(edges, cursors) {\n  if (edges.left && edges.top) {\n    return cursors.topLeft;\n  } else if (edges.right && edges.top) {\n    return cursors.topRight;\n  } else if (edges.left && edges.bottom) {\n    return cursors.bottomLeft;\n  } else if (edges.right && edges.bottom) {\n    return cursors.bottomRight;\n  } else if (edges.left || edges.right) {\n    return cursors.leftOrRight;\n  } else if (edges.top || edges.bottom) {\n    return cursors.topOrBottom;\n  } else {\n    return '';\n  }\n}\n/**\n * @param {?} __0\n * @return {?}\n */\n\n\nfunction getEdgesDiff(_ref4) {\n  var edges = _ref4.edges,\n      initialRectangle = _ref4.initialRectangle,\n      newRectangle = _ref4.newRectangle;\n\n  /** @type {?} */\n  var edgesDiff = {};\n  Object.keys(edges).forEach(function (edge) {\n    edgesDiff[edge] = (newRectangle[edge] || 0) - (initialRectangle[edge] || 0);\n  });\n  return edgesDiff;\n}\n/** @type {?} */\n\n\nvar RESIZE_ACTIVE_CLASS = 'resize-active';\n/** @type {?} */\n\nvar RESIZE_LEFT_HOVER_CLASS = 'resize-left-hover';\n/** @type {?} */\n\nvar RESIZE_RIGHT_HOVER_CLASS = 'resize-right-hover';\n/** @type {?} */\n\nvar RESIZE_TOP_HOVER_CLASS = 'resize-top-hover';\n/** @type {?} */\n\nvar RESIZE_BOTTOM_HOVER_CLASS = 'resize-bottom-hover';\n/** @type {?} */\n\nvar RESIZE_GHOST_ELEMENT_CLASS = 'resize-ghost-element';\n/** @type {?} */\n\nvar MOUSE_MOVE_THROTTLE_MS = 50;\n\nvar ResizableDirective = /*@__PURE__*/function () {\n  var ResizableDirective = /*#__PURE__*/function () {\n    /**\n     * @hidden\n     * @param {?} platformId\n     * @param {?} renderer\n     * @param {?} elm\n     * @param {?} zone\n     */\n    function ResizableDirective(platformId, renderer, elm, zone) {\n      _classCallCheck(this, ResizableDirective);\n\n      this.platformId = platformId;\n      this.renderer = renderer;\n      this.elm = elm;\n      this.zone = zone;\n      /**\n       * The edges that an element can be resized from. Pass an object like `{top: true, bottom: false}`. By default no edges can be resized.\n       * @deprecated use a resize handle instead that positions itself to the side of the element you would like to resize\n       */\n\n      this.resizeEdges = {};\n      /**\n       * Set to `true` to enable a temporary resizing effect of the element in between the `resizeStart` and `resizeEnd` events.\n       */\n\n      this.enableGhostResize = false;\n      /**\n       * A snap grid that resize events will be locked to.\n       *\n       * e.g. to only allow the element to be resized every 10px set it to `{left: 10, right: 10}`\n       */\n\n      this.resizeSnapGrid = {};\n      /**\n       * The mouse cursors that will be set on the resize edges\n       */\n\n      this.resizeCursors = DEFAULT_RESIZE_CURSORS;\n      /**\n       * Mouse over thickness to active cursor.\n       * @deprecated invalid when you migrate to use resize handles instead of setting resizeEdges on the element\n       */\n\n      this.resizeCursorPrecision = 3;\n      /**\n       * Define the positioning of the ghost element (can be fixed or absolute)\n       */\n\n      this.ghostElementPositioning = 'fixed';\n      /**\n       * Allow elements to be resized to negative dimensions\n       */\n\n      this.allowNegativeResizes = false;\n      /**\n       * The mouse move throttle in milliseconds, default: 50 ms\n       */\n\n      this.mouseMoveThrottleMS = MOUSE_MOVE_THROTTLE_MS;\n      /**\n       * Called when the mouse is pressed and a resize event is about to begin. `$event` is a `ResizeEvent` object.\n       */\n\n      this.resizeStart = new EventEmitter();\n      /**\n       * Called as the mouse is dragged after a resize event has begun. `$event` is a `ResizeEvent` object.\n       */\n\n      this.resizing = new EventEmitter();\n      /**\n       * Called after the mouse is released after a resize event. `$event` is a `ResizeEvent` object.\n       */\n\n      this.resizeEnd = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.mouseup = new Subject();\n      /**\n       * @hidden\n       */\n\n      this.mousedown = new Subject();\n      /**\n       * @hidden\n       */\n\n      this.mousemove = new Subject();\n      this.destroy$ = new Subject();\n      this.resizeEdges$ = new Subject();\n      this.pointerEventListeners = PointerEventListeners.getInstance(renderer, zone);\n    }\n    /**\n     * @hidden\n     * @return {?}\n     */\n\n\n    _createClass(ResizableDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this = this;\n\n        /** @type {?} */\n        var mousedown$ = merge(this.pointerEventListeners.pointerDown, this.mousedown);\n        /** @type {?} */\n\n        var mousemove$ = merge(this.pointerEventListeners.pointerMove, this.mousemove).pipe(tap(function (_ref5) {\n          var event = _ref5.event;\n\n          if (currentResize) {\n            event.preventDefault();\n          }\n        }), share());\n        /** @type {?} */\n\n        var mouseup$ = merge(this.pointerEventListeners.pointerUp, this.mouseup);\n        /** @type {?} */\n\n        var currentResize;\n        /** @type {?} */\n\n        var removeGhostElement = function removeGhostElement() {\n          if (currentResize && currentResize.clonedNode) {\n            _this.elm.nativeElement.parentElement.removeChild(currentResize.clonedNode);\n\n            _this.renderer.setStyle(_this.elm.nativeElement, 'visibility', 'inherit');\n          }\n        };\n        /** @type {?} */\n\n\n        var getResizeCursors = function getResizeCursors() {\n          return Object.assign({}, DEFAULT_RESIZE_CURSORS, _this.resizeCursors);\n        };\n\n        this.resizeEdges$.pipe(startWith(this.resizeEdges), map(function () {\n          return _this.resizeEdges && Object.keys(_this.resizeEdges).some(function (edge) {\n            return !!_this.resizeEdges[edge];\n          });\n        }), switchMap(function (legacyResizeEdgesEnabled) {\n          return legacyResizeEdgesEnabled ? mousemove$ : EMPTY;\n        }), auditTime(this.mouseMoveThrottleMS), takeUntil(this.destroy$)).subscribe(function (_ref6) {\n          var clientX = _ref6.clientX,\n              clientY = _ref6.clientY;\n\n          /** @type {?} */\n          var resizeEdges = getResizeEdges({\n            clientX: clientX,\n            clientY: clientY,\n            elm: _this.elm,\n            allowedEdges: _this.resizeEdges,\n            cursorPrecision: _this.resizeCursorPrecision\n          });\n          /** @type {?} */\n\n          var resizeCursors = getResizeCursors();\n\n          if (!currentResize) {\n            /** @type {?} */\n            var cursor = getResizeCursor(resizeEdges, resizeCursors);\n\n            _this.renderer.setStyle(_this.elm.nativeElement, 'cursor', cursor);\n          }\n\n          _this.setElementClass(_this.elm, RESIZE_LEFT_HOVER_CLASS, resizeEdges.left === true);\n\n          _this.setElementClass(_this.elm, RESIZE_RIGHT_HOVER_CLASS, resizeEdges.right === true);\n\n          _this.setElementClass(_this.elm, RESIZE_TOP_HOVER_CLASS, resizeEdges.top === true);\n\n          _this.setElementClass(_this.elm, RESIZE_BOTTOM_HOVER_CLASS, resizeEdges.bottom === true);\n        });\n        /** @type {?} */\n\n        var mousedrag = mousedown$.pipe(mergeMap(function (startCoords) {\n          /**\n           * @param {?} moveCoords\n           * @return {?}\n           */\n          function getDiff(moveCoords) {\n            return {\n              clientX: moveCoords.clientX - startCoords.clientX,\n              clientY: moveCoords.clientY - startCoords.clientY\n            };\n          }\n          /** @type {?} */\n\n\n          var getSnapGrid = function getSnapGrid() {\n            /** @type {?} */\n            var snapGrid = {\n              x: 1,\n              y: 1\n            };\n\n            if (currentResize) {\n              if (_this.resizeSnapGrid.left && currentResize.edges.left) {\n                snapGrid.x = +_this.resizeSnapGrid.left;\n              } else if (_this.resizeSnapGrid.right && currentResize.edges.right) {\n                snapGrid.x = +_this.resizeSnapGrid.right;\n              }\n\n              if (_this.resizeSnapGrid.top && currentResize.edges.top) {\n                snapGrid.y = +_this.resizeSnapGrid.top;\n              } else if (_this.resizeSnapGrid.bottom && currentResize.edges.bottom) {\n                snapGrid.y = +_this.resizeSnapGrid.bottom;\n              }\n            }\n\n            return snapGrid;\n          };\n          /**\n           * @param {?} coords\n           * @param {?} snapGrid\n           * @return {?}\n           */\n\n\n          function getGrid(coords, snapGrid) {\n            return {\n              x: Math.ceil(coords.clientX / snapGrid.x),\n              y: Math.ceil(coords.clientY / snapGrid.y)\n            };\n          }\n\n          return (\n            /** @type {?} */\n            merge(mousemove$.pipe(take(1)).pipe(map(function (coords) {\n              return [, coords];\n            })), mousemove$.pipe(pairwise())).pipe(map(function (_ref7) {\n              var _ref8 = _slicedToArray(_ref7, 2),\n                  previousCoords = _ref8[0],\n                  newCoords = _ref8[1];\n\n              return [previousCoords ? getDiff(previousCoords) : previousCoords, getDiff(newCoords)];\n            })).pipe(filter(function (_ref9) {\n              var _ref10 = _slicedToArray(_ref9, 2),\n                  previousCoords = _ref10[0],\n                  newCoords = _ref10[1];\n\n              if (!previousCoords) {\n                return true;\n              }\n              /** @type {?} */\n\n\n              var snapGrid = getSnapGrid();\n              /** @type {?} */\n\n              var previousGrid = getGrid(previousCoords, snapGrid);\n              /** @type {?} */\n\n              var newGrid = getGrid(newCoords, snapGrid);\n              return previousGrid.x !== newGrid.x || previousGrid.y !== newGrid.y;\n            })).pipe(map(function (_ref11) {\n              var _ref12 = _slicedToArray(_ref11, 2),\n                  newCoords = _ref12[1];\n\n              /** @type {?} */\n              var snapGrid = getSnapGrid();\n              return {\n                clientX: Math.round(newCoords.clientX / snapGrid.x) * snapGrid.x,\n                clientY: Math.round(newCoords.clientY / snapGrid.y) * snapGrid.y\n              };\n            })).pipe(takeUntil(merge(mouseup$, mousedown$)))\n          );\n        })).pipe(filter(function () {\n          return !!currentResize;\n        }));\n        mousedrag.pipe(map(function (_ref13) {\n          var clientX = _ref13.clientX,\n              clientY = _ref13.clientY;\n          return getNewBoundingRectangle(\n          /** @type {?} */\n          currentResize.startingRect,\n          /** @type {?} */\n          currentResize.edges, clientX, clientY);\n        })).pipe(filter(function (newBoundingRect) {\n          return _this.allowNegativeResizes || !!(newBoundingRect.height && newBoundingRect.width && newBoundingRect.height > 0 && newBoundingRect.width > 0);\n        })).pipe(filter(function (newBoundingRect) {\n          return _this.validateResize ? _this.validateResize({\n            rectangle: newBoundingRect,\n            edges: getEdgesDiff({\n              edges:\n              /** @type {?} */\n              currentResize.edges,\n              initialRectangle:\n              /** @type {?} */\n              currentResize.startingRect,\n              newRectangle: newBoundingRect\n            })\n          }) : true;\n        }), takeUntil(this.destroy$)).subscribe(function (newBoundingRect) {\n          if (currentResize && currentResize.clonedNode) {\n            _this.renderer.setStyle(currentResize.clonedNode, 'height', \"\".concat(newBoundingRect.height, \"px\"));\n\n            _this.renderer.setStyle(currentResize.clonedNode, 'width', \"\".concat(newBoundingRect.width, \"px\"));\n\n            _this.renderer.setStyle(currentResize.clonedNode, 'top', \"\".concat(newBoundingRect.top, \"px\"));\n\n            _this.renderer.setStyle(currentResize.clonedNode, 'left', \"\".concat(newBoundingRect.left, \"px\"));\n          }\n\n          if (_this.resizing.observers.length > 0) {\n            _this.zone.run(function () {\n              _this.resizing.emit({\n                edges: getEdgesDiff({\n                  edges:\n                  /** @type {?} */\n                  currentResize.edges,\n                  initialRectangle:\n                  /** @type {?} */\n                  currentResize.startingRect,\n                  newRectangle: newBoundingRect\n                }),\n                rectangle: newBoundingRect\n              });\n            });\n          }\n\n          /** @type {?} */\n          currentResize.currentRect = newBoundingRect;\n        });\n        mousedown$.pipe(map(function (_ref14) {\n          var clientX = _ref14.clientX,\n              clientY = _ref14.clientY,\n              edges = _ref14.edges;\n          return edges || getResizeEdges({\n            clientX: clientX,\n            clientY: clientY,\n            elm: _this.elm,\n            allowedEdges: _this.resizeEdges,\n            cursorPrecision: _this.resizeCursorPrecision\n          });\n        })).pipe(filter(function (edges) {\n          return Object.keys(edges).length > 0;\n        }), takeUntil(this.destroy$)).subscribe(function (edges) {\n          if (currentResize) {\n            removeGhostElement();\n          }\n          /** @type {?} */\n\n\n          var startingRect = getElementRect(_this.elm, _this.ghostElementPositioning);\n          currentResize = {\n            edges: edges,\n            startingRect: startingRect,\n            currentRect: startingRect\n          };\n          /** @type {?} */\n\n          var resizeCursors = getResizeCursors();\n          /** @type {?} */\n\n          var cursor = getResizeCursor(currentResize.edges, resizeCursors);\n\n          _this.renderer.setStyle(document.body, 'cursor', cursor);\n\n          _this.setElementClass(_this.elm, RESIZE_ACTIVE_CLASS, true);\n\n          if (_this.enableGhostResize) {\n            currentResize.clonedNode = _this.elm.nativeElement.cloneNode(true);\n\n            _this.elm.nativeElement.parentElement.appendChild(currentResize.clonedNode);\n\n            _this.renderer.setStyle(_this.elm.nativeElement, 'visibility', 'hidden');\n\n            _this.renderer.setStyle(currentResize.clonedNode, 'position', _this.ghostElementPositioning);\n\n            _this.renderer.setStyle(currentResize.clonedNode, 'left', \"\".concat(currentResize.startingRect.left, \"px\"));\n\n            _this.renderer.setStyle(currentResize.clonedNode, 'top', \"\".concat(currentResize.startingRect.top, \"px\"));\n\n            _this.renderer.setStyle(currentResize.clonedNode, 'height', \"\".concat(currentResize.startingRect.height, \"px\"));\n\n            _this.renderer.setStyle(currentResize.clonedNode, 'width', \"\".concat(currentResize.startingRect.width, \"px\"));\n\n            _this.renderer.setStyle(currentResize.clonedNode, 'cursor', getResizeCursor(currentResize.edges, resizeCursors));\n\n            _this.renderer.addClass(currentResize.clonedNode, RESIZE_GHOST_ELEMENT_CLASS);\n\n            /** @type {?} */\n            currentResize.clonedNode.scrollTop =\n            /** @type {?} */\n            currentResize.startingRect.scrollTop;\n\n            /** @type {?} */\n            currentResize.clonedNode.scrollLeft =\n            /** @type {?} */\n            currentResize.startingRect.scrollLeft;\n          }\n\n          if (_this.resizeStart.observers.length > 0) {\n            _this.zone.run(function () {\n              _this.resizeStart.emit({\n                edges: getEdgesDiff({\n                  edges: edges,\n                  initialRectangle: startingRect,\n                  newRectangle: startingRect\n                }),\n                rectangle: getNewBoundingRectangle(startingRect, {}, 0, 0)\n              });\n            });\n          }\n        });\n        mouseup$.pipe(takeUntil(this.destroy$)).subscribe(function () {\n          if (currentResize) {\n            _this.renderer.removeClass(_this.elm.nativeElement, RESIZE_ACTIVE_CLASS);\n\n            _this.renderer.setStyle(document.body, 'cursor', '');\n\n            _this.renderer.setStyle(_this.elm.nativeElement, 'cursor', '');\n\n            if (_this.resizeEnd.observers.length > 0) {\n              _this.zone.run(function () {\n                _this.resizeEnd.emit({\n                  edges: getEdgesDiff({\n                    edges:\n                    /** @type {?} */\n                    currentResize.edges,\n                    initialRectangle:\n                    /** @type {?} */\n                    currentResize.startingRect,\n                    newRectangle:\n                    /** @type {?} */\n                    currentResize.currentRect\n                  }),\n                  rectangle:\n                  /** @type {?} */\n                  currentResize.currentRect\n                });\n              });\n            }\n\n            removeGhostElement();\n            currentResize = null;\n          }\n        });\n      }\n      /**\n       * @hidden\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        if (changes.resizeEdges) {\n          this.resizeEdges$.next(this.resizeEdges);\n        }\n      }\n      /**\n       * @hidden\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        // browser check for angular universal, because it doesn't know what document is\n        if (isPlatformBrowser(this.platformId)) {\n          this.renderer.setStyle(document.body, 'cursor', '');\n        }\n\n        this.mousedown.complete();\n        this.mouseup.complete();\n        this.mousemove.complete();\n        this.resizeEdges$.complete();\n        this.destroy$.next();\n      }\n      /**\n       * @private\n       * @param {?} elm\n       * @param {?} name\n       * @param {?} add\n       * @return {?}\n       */\n\n    }, {\n      key: \"setElementClass\",\n      value: function setElementClass(elm, name, add) {\n        if (add) {\n          this.renderer.addClass(elm.nativeElement, name);\n        } else {\n          this.renderer.removeClass(elm.nativeElement, name);\n        }\n      }\n    }]);\n\n    return ResizableDirective;\n  }();\n\n  ResizableDirective.ɵfac = function ResizableDirective_Factory(t) {\n    return new (t || ResizableDirective)(ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  ResizableDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ResizableDirective,\n    selectors: [[\"\", \"mwlResizable\", \"\"]],\n    inputs: {\n      resizeEdges: \"resizeEdges\",\n      enableGhostResize: \"enableGhostResize\",\n      resizeSnapGrid: \"resizeSnapGrid\",\n      resizeCursors: \"resizeCursors\",\n      resizeCursorPrecision: \"resizeCursorPrecision\",\n      ghostElementPositioning: \"ghostElementPositioning\",\n      allowNegativeResizes: \"allowNegativeResizes\",\n      mouseMoveThrottleMS: \"mouseMoveThrottleMS\",\n      validateResize: \"validateResize\"\n    },\n    outputs: {\n      resizeStart: \"resizeStart\",\n      resizing: \"resizing\",\n      resizeEnd: \"resizeEnd\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return ResizableDirective;\n}();\n\nvar PointerEventListeners = /*#__PURE__*/function () {\n  /**\n   * @param {?} renderer\n   * @param {?} zone\n   */\n  function PointerEventListeners(renderer, zone) {\n    _classCallCheck(this, PointerEventListeners);\n\n    this.pointerDown = new Observable(function (observer) {\n      /** @type {?} */\n      var unsubscribeMouseDown;\n      /** @type {?} */\n\n      var unsubscribeTouchStart;\n      zone.runOutsideAngular(function () {\n        unsubscribeMouseDown = renderer.listen('document', 'mousedown', function (event) {\n          observer.next({\n            clientX: event.clientX,\n            clientY: event.clientY,\n            event: event\n          });\n        });\n\n        if (IS_TOUCH_DEVICE) {\n          unsubscribeTouchStart = renderer.listen('document', 'touchstart', function (event) {\n            observer.next({\n              clientX: event.touches[0].clientX,\n              clientY: event.touches[0].clientY,\n              event: event\n            });\n          });\n        }\n      });\n      return function () {\n        unsubscribeMouseDown();\n\n        if (IS_TOUCH_DEVICE) {\n          /** @type {?} */\n          unsubscribeTouchStart();\n        }\n      };\n    }).pipe(share());\n    this.pointerMove = new Observable(function (observer) {\n      /** @type {?} */\n      var unsubscribeMouseMove;\n      /** @type {?} */\n\n      var unsubscribeTouchMove;\n      zone.runOutsideAngular(function () {\n        unsubscribeMouseMove = renderer.listen('document', 'mousemove', function (event) {\n          observer.next({\n            clientX: event.clientX,\n            clientY: event.clientY,\n            event: event\n          });\n        });\n\n        if (IS_TOUCH_DEVICE) {\n          unsubscribeTouchMove = renderer.listen('document', 'touchmove', function (event) {\n            observer.next({\n              clientX: event.targetTouches[0].clientX,\n              clientY: event.targetTouches[0].clientY,\n              event: event\n            });\n          });\n        }\n      });\n      return function () {\n        unsubscribeMouseMove();\n\n        if (IS_TOUCH_DEVICE) {\n          /** @type {?} */\n          unsubscribeTouchMove();\n        }\n      };\n    }).pipe(share());\n    this.pointerUp = new Observable(function (observer) {\n      /** @type {?} */\n      var unsubscribeMouseUp;\n      /** @type {?} */\n\n      var unsubscribeTouchEnd;\n      /** @type {?} */\n\n      var unsubscribeTouchCancel;\n      zone.runOutsideAngular(function () {\n        unsubscribeMouseUp = renderer.listen('document', 'mouseup', function (event) {\n          observer.next({\n            clientX: event.clientX,\n            clientY: event.clientY,\n            event: event\n          });\n        });\n\n        if (IS_TOUCH_DEVICE) {\n          unsubscribeTouchEnd = renderer.listen('document', 'touchend', function (event) {\n            observer.next({\n              clientX: event.changedTouches[0].clientX,\n              clientY: event.changedTouches[0].clientY,\n              event: event\n            });\n          });\n          unsubscribeTouchCancel = renderer.listen('document', 'touchcancel', function (event) {\n            observer.next({\n              clientX: event.changedTouches[0].clientX,\n              clientY: event.changedTouches[0].clientY,\n              event: event\n            });\n          });\n        }\n      });\n      return function () {\n        unsubscribeMouseUp();\n\n        if (IS_TOUCH_DEVICE) {\n          /** @type {?} */\n          unsubscribeTouchEnd();\n\n          /** @type {?} */\n          unsubscribeTouchCancel();\n        }\n      };\n    }).pipe(share());\n  }\n\n  _createClass(PointerEventListeners, null, [{\n    key: \"getInstance\",\n    value: // tslint:disable-line\n\n    /**\n     * @param {?} renderer\n     * @param {?} zone\n     * @return {?}\n     */\n    function getInstance(renderer, zone) {\n      if (!PointerEventListeners.instance) {\n        PointerEventListeners.instance = new PointerEventListeners(renderer, zone);\n      }\n\n      return PointerEventListeners.instance;\n    }\n  }]);\n\n  return PointerEventListeners;\n}();\n\nvar ResizeHandleDirective = /*@__PURE__*/function () {\n  var ResizeHandleDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} renderer\n     * @param {?} element\n     * @param {?} zone\n     * @param {?} resizable\n     */\n    function ResizeHandleDirective(renderer, element, zone, resizable) {\n      _classCallCheck(this, ResizeHandleDirective);\n\n      this.renderer = renderer;\n      this.element = element;\n      this.zone = zone;\n      this.resizable = resizable;\n      /**\n       * The `Edges` object that contains the edges of the parent element that dragging the handle will trigger a resize on\n       */\n\n      this.resizeEdges = {};\n      this.eventListeners = {};\n      this.destroy$ = new Subject();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(ResizeHandleDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this2 = this;\n\n        this.zone.runOutsideAngular(function () {\n          _this2.listenOnTheHost('mousedown').subscribe(function (event) {\n            _this2.onMousedown(event, event.clientX, event.clientY);\n          });\n\n          _this2.listenOnTheHost('mouseup').subscribe(function (event) {\n            _this2.onMouseup(event.clientX, event.clientY);\n          });\n\n          if (IS_TOUCH_DEVICE) {\n            _this2.listenOnTheHost('touchstart').subscribe(function (event) {\n              _this2.onMousedown(event, event.touches[0].clientX, event.touches[0].clientY);\n            });\n\n            merge(_this2.listenOnTheHost('touchend'), _this2.listenOnTheHost('touchcancel')).subscribe(function (event) {\n              _this2.onMouseup(event.changedTouches[0].clientX, event.changedTouches[0].clientY);\n            });\n          }\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.destroy$.next();\n        this.unsubscribeEventListeners();\n      }\n      /**\n       * @hidden\n       * @param {?} event\n       * @param {?} clientX\n       * @param {?} clientY\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMousedown\",\n      value: function onMousedown(event, clientX, clientY) {\n        var _this3 = this;\n\n        event.preventDefault();\n\n        if (!this.eventListeners.touchmove) {\n          this.eventListeners.touchmove = this.renderer.listen(this.element.nativeElement, 'touchmove', function (touchMoveEvent) {\n            _this3.onMousemove(touchMoveEvent, touchMoveEvent.targetTouches[0].clientX, touchMoveEvent.targetTouches[0].clientY);\n          });\n        }\n\n        if (!this.eventListeners.mousemove) {\n          this.eventListeners.mousemove = this.renderer.listen(this.element.nativeElement, 'mousemove', function (mouseMoveEvent) {\n            _this3.onMousemove(mouseMoveEvent, mouseMoveEvent.clientX, mouseMoveEvent.clientY);\n          });\n        }\n\n        this.resizable.mousedown.next({\n          clientX: clientX,\n          clientY: clientY,\n          edges: this.resizeEdges\n        });\n      }\n      /**\n       * @hidden\n       * @param {?} clientX\n       * @param {?} clientY\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMouseup\",\n      value: function onMouseup(clientX, clientY) {\n        this.unsubscribeEventListeners();\n        this.resizable.mouseup.next({\n          clientX: clientX,\n          clientY: clientY,\n          edges: this.resizeEdges\n        });\n      }\n      /**\n       * @private\n       * @param {?} event\n       * @param {?} clientX\n       * @param {?} clientY\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMousemove\",\n      value: function onMousemove(event, clientX, clientY) {\n        this.resizable.mousemove.next({\n          clientX: clientX,\n          clientY: clientY,\n          edges: this.resizeEdges,\n          event: event\n        });\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeEventListeners\",\n      value: function unsubscribeEventListeners() {\n        var _this4 = this;\n\n        Object.keys(this.eventListeners).forEach(function (type) {\n          /** @type {?} */\n          _this4.eventListeners[type]();\n\n          delete _this4.eventListeners[type];\n        });\n      }\n      /**\n       * @private\n       * @template T\n       * @param {?} eventName\n       * @return {?}\n       */\n\n    }, {\n      key: \"listenOnTheHost\",\n      value: function listenOnTheHost(eventName) {\n        return fromEvent(this.element.nativeElement, eventName).pipe(takeUntil(this.destroy$));\n      }\n    }]);\n\n    return ResizeHandleDirective;\n  }();\n\n  ResizeHandleDirective.ɵfac = function ResizeHandleDirective_Factory(t) {\n    return new (t || ResizeHandleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ResizableDirective));\n  };\n\n  ResizeHandleDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ResizeHandleDirective,\n    selectors: [[\"\", \"mwlResizeHandle\", \"\"]],\n    inputs: {\n      resizeEdges: \"resizeEdges\"\n    }\n  });\n  return ResizeHandleDirective;\n}();\n\nvar ResizableModule = /*@__PURE__*/function () {\n  var ResizableModule = function ResizableModule() {\n    _classCallCheck(this, ResizableModule);\n  };\n\n  ResizableModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: ResizableModule\n  });\n  ResizableModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    factory: function ResizableModule_Factory(t) {\n      return new (t || ResizableModule)();\n    }\n  });\n  return ResizableModule;\n}();\n/*@__PURE__*/\n\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ResizableModule, {\n    declarations: [ResizableDirective, ResizeHandleDirective],\n    exports: [ResizableDirective, ResizeHandleDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { ResizableDirective, ResizeHandleDirective, ResizableModule };","map":null,"metadata":{},"sourceType":"module"}