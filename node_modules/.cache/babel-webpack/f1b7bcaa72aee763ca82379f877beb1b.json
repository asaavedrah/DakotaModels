{"ast":null,"code":"import _slicedToArray from \"C:/Users/DTI_UCH/Desktop/template_angularjs10/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createClass from \"C:/Users/DTI_UCH/Desktop/template_angularjs10/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"C:/Users/DTI_UCH/Desktop/template_angularjs10/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { Subject, Observable, merge, ReplaySubject, combineLatest, fromEvent } from 'rxjs';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\nimport { Injectable, Directive, ElementRef, Input, Renderer2, Output, EventEmitter, NgZone, Inject, ViewContainerRef, Optional, NgModule, defineInjectable } from '@angular/core';\nimport { map, mergeMap, takeUntil, take, takeLast, pairwise, share, filter, count, startWith, distinctUntilChanged } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar DraggableHelper = /*@__PURE__*/function () {\n  var DraggableHelper = function DraggableHelper() {\n    _classCallCheck(this, DraggableHelper);\n\n    this.currentDrag = new Subject();\n  };\n\n  DraggableHelper.ɵfac = function DraggableHelper_Factory(t) {\n    return new (t || DraggableHelper)();\n  };\n\n  DraggableHelper.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DraggableHelper,\n    factory: DraggableHelper.ɵfac,\n    providedIn: 'root'\n  });\n  /** @nocollapse */\n\n  DraggableHelper.ngInjectableDef = /*@__PURE__*/defineInjectable({\n    factory: function DraggableHelper_Factory() {\n      return new DraggableHelper();\n    },\n    token: DraggableHelper,\n    providedIn: \"root\"\n  });\n  return DraggableHelper;\n}();\n\nvar DraggableScrollContainerDirective = /*@__PURE__*/function () {\n  var DraggableScrollContainerDirective =\n  /**\n   * @hidden\n   * @param {?} elementRef\n   */\n  function DraggableScrollContainerDirective(elementRef) {\n    _classCallCheck(this, DraggableScrollContainerDirective);\n\n    this.elementRef = elementRef;\n    /**\n     * Trigger the DragStart after a long touch in scrollable container when true\n     * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n     */\n\n    this.activeLongPressDrag = false;\n    /**\n     * Configuration of a long touch\n     * Duration in ms of a long touch before activating DragStart\n     * Delta of the\n     * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n     */\n\n    this.longPressConfig = {\n      duration: 300,\n      delta: 30\n    };\n  };\n\n  DraggableScrollContainerDirective.ɵfac = function DraggableScrollContainerDirective_Factory(t) {\n    return new (t || DraggableScrollContainerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  DraggableScrollContainerDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DraggableScrollContainerDirective,\n    selectors: [[\"\", \"mwlDraggableScrollContainer\", \"\"]],\n    inputs: {\n      activeLongPressDrag: \"activeLongPressDrag\",\n      longPressConfig: \"longPressConfig\"\n    }\n  });\n  return DraggableScrollContainerDirective;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} renderer\n * @param {?} element\n * @param {?} classToAdd\n * @return {?}\n */\n\n\nfunction addClass(renderer, element, classToAdd) {\n  if (classToAdd) {\n    classToAdd.split(' ').forEach(\n    /**\n    * @param {?} className\n    * @return {?}\n    */\n    function (className) {\n      return renderer.addClass(element.nativeElement, className);\n    });\n  }\n}\n/**\n * @param {?} renderer\n * @param {?} element\n * @param {?} classToRemove\n * @return {?}\n */\n\n\nfunction removeClass(renderer, element, classToRemove) {\n  if (classToRemove) {\n    classToRemove.split(' ').forEach(\n    /**\n    * @param {?} className\n    * @return {?}\n    */\n    function (className) {\n      return renderer.removeClass(element.nativeElement, className);\n    });\n  }\n}\n\nvar DraggableDirective = /*@__PURE__*/function () {\n  var DraggableDirective = /*#__PURE__*/function () {\n    /**\n     * @hidden\n     * @param {?} element\n     * @param {?} renderer\n     * @param {?} draggableHelper\n     * @param {?} zone\n     * @param {?} vcr\n     * @param {?} scrollContainer\n     * @param {?} document\n     */\n    function DraggableDirective(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n      _classCallCheck(this, DraggableDirective);\n\n      this.element = element;\n      this.renderer = renderer;\n      this.draggableHelper = draggableHelper;\n      this.zone = zone;\n      this.vcr = vcr;\n      this.scrollContainer = scrollContainer;\n      this.document = document;\n      /**\n       * The axis along which the element is draggable\n       */\n\n      this.dragAxis = {\n        x: true,\n        y: true\n      };\n      /**\n       * Snap all drags to an x / y grid\n       */\n\n      this.dragSnapGrid = {};\n      /**\n       * Show a ghost element that shows the drag when dragging\n       */\n\n      this.ghostDragEnabled = true;\n      /**\n       * Show the original element when ghostDragEnabled is true\n       */\n\n      this.showOriginalElementWhileDragging = false;\n      /**\n       * The cursor to use when hovering over a draggable element\n       */\n\n      this.dragCursor = '';\n      /*\n         * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n         */\n\n      this.autoScroll = {\n        margin: 20\n      };\n      /**\n       * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n       */\n\n      this.dragPointerDown = new EventEmitter();\n      /**\n       * Called when the element has started to be dragged.\n       * Only called after at least one mouse or touch move event.\n       * If you call $event.cancelDrag$.emit() it will cancel the current drag\n       */\n\n      this.dragStart = new EventEmitter();\n      /**\n       * Called after the ghost element has been created\n       */\n\n      this.ghostElementCreated = new EventEmitter();\n      /**\n       * Called when the element is being dragged\n       */\n\n      this.dragging = new EventEmitter();\n      /**\n       * Called after the element is dragged\n       */\n\n      this.dragEnd = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.pointerDown$ = new Subject();\n      /**\n       * @hidden\n       */\n\n      this.pointerMove$ = new Subject();\n      /**\n       * @hidden\n       */\n\n      this.pointerUp$ = new Subject();\n      this.eventListenerSubscriptions = {};\n      this.destroy$ = new Subject();\n      this.timeLongPress = {\n        timerBegin: 0,\n        timerEnd: 0\n      };\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(DraggableDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this = this;\n\n        this.checkEventListeners();\n        /** @type {?} */\n\n        var pointerDragged$ = this.pointerDown$.pipe(filter(\n        /**\n        * @return {?}\n        */\n        function () {\n          return _this.canDrag();\n        }), mergeMap(\n        /**\n        * @param {?} pointerDownEvent\n        * @return {?}\n        */\n        function (pointerDownEvent) {\n          // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n          // stop mouse events propagating up the chain\n          if (pointerDownEvent.event.stopPropagation && !_this.scrollContainer) {\n            pointerDownEvent.event.stopPropagation();\n          } // hack to prevent text getting selected in safari while dragging\n\n          /** @type {?} */\n\n\n          var globalDragStyle = _this.renderer.createElement('style');\n\n          _this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n\n          _this.renderer.appendChild(globalDragStyle, _this.renderer.createText(\"\\n          body * {\\n           -moz-user-select: none;\\n           -ms-user-select: none;\\n           -webkit-user-select: none;\\n           user-select: none;\\n          }\\n        \"));\n\n          requestAnimationFrame(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this.document.head.appendChild(globalDragStyle);\n          });\n          /** @type {?} */\n\n          var startScrollPosition = _this.getScrollPosition();\n          /** @type {?} */\n\n\n          var scrollContainerScroll$ = new Observable(\n          /**\n          * @param {?} observer\n          * @return {?}\n          */\n          function (observer) {\n            /** @type {?} */\n            var scrollContainer = _this.scrollContainer ? _this.scrollContainer.elementRef.nativeElement : 'window';\n            return _this.renderer.listen(scrollContainer, 'scroll',\n            /**\n            * @param {?} e\n            * @return {?}\n            */\n            function (e) {\n              return observer.next(e);\n            });\n          }).pipe(startWith(startScrollPosition), map(\n          /**\n          * @return {?}\n          */\n          function () {\n            return _this.getScrollPosition();\n          }));\n          /** @type {?} */\n\n          var currentDrag$ = new Subject();\n          /** @type {?} */\n\n          var cancelDrag$ = new ReplaySubject();\n\n          _this.zone.run(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this.dragPointerDown.next({\n              x: 0,\n              y: 0\n            });\n          });\n          /** @type {?} */\n\n\n          var dragComplete$ = merge(_this.pointerUp$, _this.pointerDown$, cancelDrag$, _this.destroy$).pipe(share());\n          /** @type {?} */\n\n          var pointerMove = combineLatest([_this.pointerMove$, scrollContainerScroll$]).pipe(map(\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                pointerMoveEvent = _ref2[0],\n                scroll = _ref2[1];\n\n            return {\n              currentDrag$: currentDrag$,\n              transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n              transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n              clientX: pointerMoveEvent.clientX,\n              clientY: pointerMoveEvent.clientY,\n              scrollLeft: scroll.left,\n              scrollTop: scroll.top,\n              target: pointerMoveEvent.event.target\n            };\n          }), map(\n          /**\n          * @param {?} moveData\n          * @return {?}\n          */\n          function (moveData) {\n            if (_this.dragSnapGrid.x) {\n              moveData.transformX = Math.round(moveData.transformX / _this.dragSnapGrid.x) * _this.dragSnapGrid.x;\n            }\n\n            if (_this.dragSnapGrid.y) {\n              moveData.transformY = Math.round(moveData.transformY / _this.dragSnapGrid.y) * _this.dragSnapGrid.y;\n            }\n\n            return moveData;\n          }), map(\n          /**\n          * @param {?} moveData\n          * @return {?}\n          */\n          function (moveData) {\n            if (!_this.dragAxis.x) {\n              moveData.transformX = 0;\n            }\n\n            if (!_this.dragAxis.y) {\n              moveData.transformY = 0;\n            }\n\n            return moveData;\n          }), map(\n          /**\n          * @param {?} moveData\n          * @return {?}\n          */\n          function (moveData) {\n            /** @type {?} */\n            var scrollX = moveData.scrollLeft - startScrollPosition.left;\n            /** @type {?} */\n\n            var scrollY = moveData.scrollTop - startScrollPosition.top;\n            return Object.assign({}, moveData, {\n              x: moveData.transformX + scrollX,\n              y: moveData.transformY + scrollY\n            });\n          }), filter(\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          function (_ref3) {\n            var x = _ref3.x,\n                y = _ref3.y,\n                transformX = _ref3.transformX,\n                transformY = _ref3.transformY;\n            return !_this.validateDrag || _this.validateDrag({\n              x: x,\n              y: y,\n              transform: {\n                x: transformX,\n                y: transformY\n              }\n            });\n          }), takeUntil(dragComplete$), share());\n          /** @type {?} */\n\n          var dragStarted$ = pointerMove.pipe(take(1), share());\n          /** @type {?} */\n\n          var dragEnded$ = pointerMove.pipe(takeLast(1), share());\n          dragStarted$.subscribe(\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          function (_ref4) {\n            var clientX = _ref4.clientX,\n                clientY = _ref4.clientY,\n                x = _ref4.x,\n                y = _ref4.y;\n\n            _this.zone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              _this.dragStart.next({\n                cancelDrag$: cancelDrag$\n              });\n            });\n\n            _this.scroller = autoScroll([_this.scrollContainer ? _this.scrollContainer.elementRef.nativeElement : _this.document.defaultView], Object.assign({}, _this.autoScroll, {\n              autoScroll: function autoScroll() {\n                return true;\n              }\n            }));\n            addClass(_this.renderer, _this.element, _this.dragActiveClass);\n\n            if (_this.ghostDragEnabled) {\n              /** @type {?} */\n              var rect = _this.element.nativeElement.getBoundingClientRect();\n              /** @type {?} */\n\n\n              var clone =\n              /** @type {?} */\n              _this.element.nativeElement.cloneNode(true);\n\n              if (!_this.showOriginalElementWhileDragging) {\n                _this.renderer.setStyle(_this.element.nativeElement, 'visibility', 'hidden');\n              }\n\n              if (_this.ghostElementAppendTo) {\n                _this.ghostElementAppendTo.appendChild(clone);\n              } else {\n                /** @type {?} */\n                _this.element.nativeElement.parentNode.insertBefore(clone, _this.element.nativeElement.nextSibling);\n              }\n\n              _this.ghostElement = clone;\n              _this.document.body.style.cursor = _this.dragCursor;\n\n              _this.setElementStyles(clone, {\n                position: 'fixed',\n                top: \"\".concat(rect.top, \"px\"),\n                left: \"\".concat(rect.left, \"px\"),\n                width: \"\".concat(rect.width, \"px\"),\n                height: \"\".concat(rect.height, \"px\"),\n                cursor: _this.dragCursor,\n                margin: '0',\n                willChange: 'transform',\n                pointerEvents: 'none'\n              });\n\n              if (_this.ghostElementTemplate) {\n                /** @type {?} */\n                var viewRef = _this.vcr.createEmbeddedView(_this.ghostElementTemplate);\n\n                clone.innerHTML = '';\n                viewRef.rootNodes.filter(\n                /**\n                * @param {?} node\n                * @return {?}\n                */\n                function (node) {\n                  return node instanceof Node;\n                }).forEach(\n                /**\n                * @param {?} node\n                * @return {?}\n                */\n                function (node) {\n                  clone.appendChild(node);\n                });\n                dragEnded$.subscribe(\n                /**\n                * @return {?}\n                */\n                function () {\n                  _this.vcr.remove(_this.vcr.indexOf(viewRef));\n                });\n              }\n\n              _this.zone.run(\n              /**\n              * @return {?}\n              */\n              function () {\n                _this.ghostElementCreated.emit({\n                  clientX: clientX - x,\n                  clientY: clientY - y,\n                  element: clone\n                });\n              });\n\n              dragEnded$.subscribe(\n              /**\n              * @return {?}\n              */\n              function () {\n                /** @type {?} */\n                clone.parentElement.removeChild(clone);\n                _this.ghostElement = null;\n\n                _this.renderer.setStyle(_this.element.nativeElement, 'visibility', '');\n              });\n            }\n\n            _this.draggableHelper.currentDrag.next(currentDrag$);\n          });\n          dragEnded$.pipe(mergeMap(\n          /**\n          * @param {?} dragEndData\n          * @return {?}\n          */\n          function (dragEndData) {\n            /** @type {?} */\n            var dragEndData$ = cancelDrag$.pipe(count(), take(1), map(\n            /**\n            * @param {?} calledCount\n            * @return {?}\n            */\n            function (calledCount) {\n              return Object.assign({}, dragEndData, {\n                dragCancelled: calledCount > 0\n              });\n            }));\n            cancelDrag$.complete();\n            return dragEndData$;\n          })).subscribe(\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          function (_ref5) {\n            var x = _ref5.x,\n                y = _ref5.y,\n                dragCancelled = _ref5.dragCancelled;\n\n            _this.scroller.destroy();\n\n            _this.zone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              _this.dragEnd.next({\n                x: x,\n                y: y,\n                dragCancelled: dragCancelled\n              });\n            });\n\n            removeClass(_this.renderer, _this.element, _this.dragActiveClass);\n            currentDrag$.complete();\n          });\n          merge(dragComplete$, dragEnded$).pipe(take(1)).subscribe(\n          /**\n          * @return {?}\n          */\n          function () {\n            requestAnimationFrame(\n            /**\n            * @return {?}\n            */\n            function () {\n              _this.document.head.removeChild(globalDragStyle);\n            });\n          });\n          return pointerMove;\n        }), share());\n        merge(pointerDragged$.pipe(take(1), map(\n        /**\n        * @param {?} value\n        * @return {?}\n        */\n        function (value) {\n          return [, value];\n        })), pointerDragged$.pipe(pairwise())).pipe(filter(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref6) {\n          var _ref7 = _slicedToArray(_ref6, 2),\n              previous = _ref7[0],\n              next = _ref7[1];\n\n          if (!previous) {\n            return true;\n          }\n\n          return previous.x !== next.x || previous.y !== next.y;\n        }), map(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref8) {\n          var _ref9 = _slicedToArray(_ref8, 2),\n              previous = _ref9[0],\n              next = _ref9[1];\n\n          return next;\n        })).subscribe(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref10) {\n          var x = _ref10.x,\n              y = _ref10.y,\n              currentDrag$ = _ref10.currentDrag$,\n              clientX = _ref10.clientX,\n              clientY = _ref10.clientY,\n              transformX = _ref10.transformX,\n              transformY = _ref10.transformY,\n              target = _ref10.target;\n\n          _this.zone.run(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this.dragging.next({\n              x: x,\n              y: y\n            });\n          });\n\n          requestAnimationFrame(\n          /**\n          * @return {?}\n          */\n          function () {\n            if (_this.ghostElement) {\n              /** @type {?} */\n              var transform = \"translate3d(\".concat(transformX, \"px, \").concat(transformY, \"px, 0px)\");\n\n              _this.setElementStyles(_this.ghostElement, {\n                transform: transform,\n                '-webkit-transform': transform,\n                '-ms-transform': transform,\n                '-moz-transform': transform,\n                '-o-transform': transform\n              });\n            }\n          });\n          currentDrag$.next({\n            clientX: clientX,\n            clientY: clientY,\n            dropData: _this.dropData,\n            target: target\n          });\n        });\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        if (changes.dragAxis) {\n          this.checkEventListeners();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.unsubscribeEventListeners();\n        this.pointerDown$.complete();\n        this.pointerMove$.complete();\n        this.pointerUp$.complete();\n        this.destroy$.next();\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"checkEventListeners\",\n      value: function checkEventListeners() {\n        var _this2 = this;\n\n        /** @type {?} */\n        var canDrag = this.canDrag();\n        /** @type {?} */\n\n        var hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n\n        if (canDrag && !hasEventListeners) {\n          this.zone.runOutsideAngular(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this2.eventListenerSubscriptions.mousedown = _this2.renderer.listen(_this2.element.nativeElement, 'mousedown',\n            /**\n            * @param {?} event\n            * @return {?}\n            */\n            function (event) {\n              _this2.onMouseDown(event);\n            });\n            _this2.eventListenerSubscriptions.mouseup = _this2.renderer.listen('document', 'mouseup',\n            /**\n            * @param {?} event\n            * @return {?}\n            */\n            function (event) {\n              _this2.onMouseUp(event);\n            });\n            _this2.eventListenerSubscriptions.touchstart = _this2.renderer.listen(_this2.element.nativeElement, 'touchstart',\n            /**\n            * @param {?} event\n            * @return {?}\n            */\n            function (event) {\n              _this2.onTouchStart(event);\n            });\n            _this2.eventListenerSubscriptions.touchend = _this2.renderer.listen('document', 'touchend',\n            /**\n            * @param {?} event\n            * @return {?}\n            */\n            function (event) {\n              _this2.onTouchEnd(event);\n            });\n            _this2.eventListenerSubscriptions.touchcancel = _this2.renderer.listen('document', 'touchcancel',\n            /**\n            * @param {?} event\n            * @return {?}\n            */\n            function (event) {\n              _this2.onTouchEnd(event);\n            });\n            _this2.eventListenerSubscriptions.mouseenter = _this2.renderer.listen(_this2.element.nativeElement, 'mouseenter',\n            /**\n            * @return {?}\n            */\n            function () {\n              _this2.onMouseEnter();\n            });\n            _this2.eventListenerSubscriptions.mouseleave = _this2.renderer.listen(_this2.element.nativeElement, 'mouseleave',\n            /**\n            * @return {?}\n            */\n            function () {\n              _this2.onMouseLeave();\n            });\n          });\n        } else if (!canDrag && hasEventListeners) {\n          this.unsubscribeEventListeners();\n        }\n      }\n      /**\n       * @private\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMouseDown\",\n      value: function onMouseDown(event) {\n        var _this3 = this;\n\n        if (event.button === 0) {\n          if (!this.eventListenerSubscriptions.mousemove) {\n            this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove',\n            /**\n            * @param {?} mouseMoveEvent\n            * @return {?}\n            */\n            function (mouseMoveEvent) {\n              _this3.pointerMove$.next({\n                event: mouseMoveEvent,\n                clientX: mouseMoveEvent.clientX,\n                clientY: mouseMoveEvent.clientY\n              });\n            });\n          }\n\n          this.pointerDown$.next({\n            event: event,\n            clientX: event.clientX,\n            clientY: event.clientY\n          });\n        }\n      }\n      /**\n       * @private\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMouseUp\",\n      value: function onMouseUp(event) {\n        if (event.button === 0) {\n          if (this.eventListenerSubscriptions.mousemove) {\n            this.eventListenerSubscriptions.mousemove();\n            delete this.eventListenerSubscriptions.mousemove;\n          }\n\n          this.pointerUp$.next({\n            event: event,\n            clientX: event.clientX,\n            clientY: event.clientY\n          });\n        }\n      }\n      /**\n       * @private\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onTouchStart\",\n      value: function onTouchStart(event) {\n        var _this4 = this;\n\n        /** @type {?} */\n        var startScrollPosition;\n        /** @type {?} */\n\n        var isDragActivated;\n        /** @type {?} */\n\n        var hasContainerScrollbar;\n\n        if (this.scrollContainer && this.scrollContainer.activeLongPressDrag || this.touchStartLongPress) {\n          this.timeLongPress.timerBegin = Date.now();\n          isDragActivated = false;\n          hasContainerScrollbar = this.hasScrollbar();\n          startScrollPosition = this.getScrollPosition();\n        }\n\n        if (!this.eventListenerSubscriptions.touchmove) {\n          /** @type {?} */\n          var contextMenuListener = fromEvent(this.document, 'contextmenu').subscribe(\n          /**\n          * @param {?} e\n          * @return {?}\n          */\n          function (e) {\n            e.preventDefault();\n          });\n          /** @type {?} */\n\n          var touchMoveListener = fromEvent(this.document, 'touchmove', {\n            passive: false\n          }).subscribe(\n          /**\n          * @param {?} touchMoveEvent\n          * @return {?}\n          */\n          function (touchMoveEvent) {\n            if ((_this4.scrollContainer && _this4.scrollContainer.activeLongPressDrag || _this4.touchStartLongPress) && !isDragActivated && hasContainerScrollbar) {\n              isDragActivated = _this4.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n            }\n\n            if ((!_this4.scrollContainer || !_this4.scrollContainer.activeLongPressDrag) && !_this4.touchStartLongPress || !hasContainerScrollbar || isDragActivated) {\n              touchMoveEvent.preventDefault();\n\n              _this4.pointerMove$.next({\n                event: touchMoveEvent,\n                clientX: touchMoveEvent.targetTouches[0].clientX,\n                clientY: touchMoveEvent.targetTouches[0].clientY\n              });\n            }\n          });\n\n          this.eventListenerSubscriptions.touchmove =\n          /**\n          * @return {?}\n          */\n          function () {\n            contextMenuListener.unsubscribe();\n            touchMoveListener.unsubscribe();\n          };\n        }\n\n        this.pointerDown$.next({\n          event: event,\n          clientX: event.touches[0].clientX,\n          clientY: event.touches[0].clientY\n        });\n      }\n      /**\n       * @private\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onTouchEnd\",\n      value: function onTouchEnd(event) {\n        if (this.eventListenerSubscriptions.touchmove) {\n          this.eventListenerSubscriptions.touchmove();\n          delete this.eventListenerSubscriptions.touchmove;\n\n          if (this.scrollContainer && this.scrollContainer.activeLongPressDrag || this.touchStartLongPress) {\n            this.enableScroll();\n          }\n        }\n\n        this.pointerUp$.next({\n          event: event,\n          clientX: event.changedTouches[0].clientX,\n          clientY: event.changedTouches[0].clientY\n        });\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMouseEnter\",\n      value: function onMouseEnter() {\n        this.setCursor(this.dragCursor);\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMouseLeave\",\n      value: function onMouseLeave() {\n        this.setCursor('');\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"canDrag\",\n      value: function canDrag() {\n        return this.dragAxis.x || this.dragAxis.y;\n      }\n      /**\n       * @private\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"setCursor\",\n      value: function setCursor(value) {\n        if (!this.eventListenerSubscriptions.mousemove) {\n          this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n        }\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeEventListeners\",\n      value: function unsubscribeEventListeners() {\n        var _this5 = this;\n\n        Object.keys(this.eventListenerSubscriptions).forEach(\n        /**\n        * @param {?} type\n        * @return {?}\n        */\n        function (type) {\n          /** @type {?} */\n          _this5.eventListenerSubscriptions[type]();\n\n          delete\n          /** @type {?} */\n          _this5.eventListenerSubscriptions[type];\n        });\n      }\n      /**\n       * @private\n       * @param {?} element\n       * @param {?} styles\n       * @return {?}\n       */\n\n    }, {\n      key: \"setElementStyles\",\n      value: function setElementStyles(element, styles) {\n        var _this6 = this;\n\n        Object.keys(styles).forEach(\n        /**\n        * @param {?} key\n        * @return {?}\n        */\n        function (key) {\n          _this6.renderer.setStyle(element, key, styles[key]);\n        });\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"getScrollElement\",\n      value: function getScrollElement() {\n        if (this.scrollContainer) {\n          return this.scrollContainer.elementRef.nativeElement;\n        } else {\n          return this.document.body;\n        }\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"getScrollPosition\",\n      value: function getScrollPosition() {\n        if (this.scrollContainer) {\n          return {\n            top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n            left: this.scrollContainer.elementRef.nativeElement.scrollLeft\n          };\n        } else {\n          return {\n            top: window.pageYOffset || this.document.documentElement.scrollTop,\n            left: window.pageXOffset || this.document.documentElement.scrollLeft\n          };\n        }\n      }\n      /**\n       * @private\n       * @param {?} event\n       * @param {?} touchMoveEvent\n       * @param {?} startScrollPosition\n       * @return {?}\n       */\n\n    }, {\n      key: \"shouldBeginDrag\",\n      value: function shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n        /** @type {?} */\n        var moveScrollPosition = this.getScrollPosition();\n        /** @type {?} */\n\n        var deltaScroll = {\n          top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n          left: Math.abs(moveScrollPosition.left - startScrollPosition.left)\n        };\n        /** @type {?} */\n\n        var deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n        /** @type {?} */\n\n        var deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n        /** @type {?} */\n\n        var deltaTotal = deltaX + deltaY;\n        /** @type {?} */\n\n        var longPressConfig = this.touchStartLongPress ? this.touchStartLongPress :\n        /* istanbul ignore next */\n        {\n          delta: this.scrollContainer.longPressConfig.delta,\n          delay: this.scrollContainer.longPressConfig.duration\n        };\n\n        if (deltaTotal > longPressConfig.delta || deltaScroll.top > 0 || deltaScroll.left > 0) {\n          this.timeLongPress.timerBegin = Date.now();\n        }\n\n        this.timeLongPress.timerEnd = Date.now();\n        /** @type {?} */\n\n        var duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n\n        if (duration >= longPressConfig.delay) {\n          this.disableScroll();\n          return true;\n        }\n\n        return false;\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"enableScroll\",\n      value: function enableScroll() {\n        if (this.scrollContainer) {\n          this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n        }\n\n        this.renderer.setStyle(this.document.body, 'overflow', '');\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"disableScroll\",\n      value: function disableScroll() {\n        /* istanbul ignore next */\n        if (this.scrollContainer) {\n          this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n        }\n\n        this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"hasScrollbar\",\n      value: function hasScrollbar() {\n        /** @type {?} */\n        var scrollContainer = this.getScrollElement();\n        /** @type {?} */\n\n        var containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n        /** @type {?} */\n\n        var containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n        return containerHasHorizontalScroll || containerHasVerticalScroll;\n      }\n    }]);\n\n    return DraggableDirective;\n  }();\n\n  DraggableDirective.ɵfac = function DraggableDirective_Factory(t) {\n    return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  DraggableDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DraggableDirective,\n    selectors: [[\"\", \"mwlDraggable\", \"\"]],\n    inputs: {\n      dragAxis: \"dragAxis\",\n      dragSnapGrid: \"dragSnapGrid\",\n      ghostDragEnabled: \"ghostDragEnabled\",\n      showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\",\n      dragCursor: \"dragCursor\",\n      autoScroll: \"autoScroll\",\n      dropData: \"dropData\",\n      validateDrag: \"validateDrag\",\n      dragActiveClass: \"dragActiveClass\",\n      ghostElementAppendTo: \"ghostElementAppendTo\",\n      ghostElementTemplate: \"ghostElementTemplate\",\n      touchStartLongPress: \"touchStartLongPress\"\n    },\n    outputs: {\n      dragPointerDown: \"dragPointerDown\",\n      dragStart: \"dragStart\",\n      ghostElementCreated: \"ghostElementCreated\",\n      dragging: \"dragging\",\n      dragEnd: \"dragEnd\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return DraggableDirective;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} clientX\n * @param {?} clientY\n * @param {?} rect\n * @return {?}\n */\n\n\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n  return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n}\n\nvar DroppableDirective = /*@__PURE__*/function () {\n  var DroppableDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} element\n     * @param {?} draggableHelper\n     * @param {?} zone\n     * @param {?} renderer\n     * @param {?} scrollContainer\n     */\n    function DroppableDirective(element, draggableHelper, zone, renderer, scrollContainer) {\n      _classCallCheck(this, DroppableDirective);\n\n      this.element = element;\n      this.draggableHelper = draggableHelper;\n      this.zone = zone;\n      this.renderer = renderer;\n      this.scrollContainer = scrollContainer;\n      /**\n       * Called when a draggable element starts overlapping the element\n       */\n\n      this.dragEnter = new EventEmitter();\n      /**\n       * Called when a draggable element stops overlapping the element\n       */\n\n      this.dragLeave = new EventEmitter();\n      /**\n       * Called when a draggable element is moved over the element\n       */\n\n      this.dragOver = new EventEmitter();\n      /**\n       * Called when a draggable element is dropped on this element\n       */\n\n      this.drop = new EventEmitter(); // tslint:disable-line no-output-named-after-standard-event\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(DroppableDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this7 = this;\n\n        this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(\n        /**\n        * @param {?} drag$\n        * @return {?}\n        */\n        function (drag$) {\n          addClass(_this7.renderer, _this7.element, _this7.dragActiveClass);\n          /** @type {?} */\n\n          var droppableElement = {\n            updateCache: true\n          };\n          /** @type {?} */\n\n          var deregisterScrollListener = _this7.renderer.listen(_this7.scrollContainer ? _this7.scrollContainer.elementRef.nativeElement : 'window', 'scroll',\n          /**\n          * @return {?}\n          */\n          function () {\n            droppableElement.updateCache = true;\n          });\n          /** @type {?} */\n\n\n          var currentDragDropData;\n          /** @type {?} */\n\n          var overlaps$ = drag$.pipe(map(\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          function (_ref11) {\n            var clientX = _ref11.clientX,\n                clientY = _ref11.clientY,\n                dropData = _ref11.dropData,\n                target = _ref11.target;\n            currentDragDropData = dropData;\n\n            if (droppableElement.updateCache) {\n              droppableElement.rect = _this7.element.nativeElement.getBoundingClientRect();\n\n              if (_this7.scrollContainer) {\n                droppableElement.scrollContainerRect = _this7.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n              }\n\n              droppableElement.updateCache = false;\n            }\n            /** @type {?} */\n\n\n            var isWithinElement = isCoordinateWithinRectangle(clientX, clientY,\n            /** @type {?} */\n            droppableElement.rect);\n            /** @type {?} */\n\n            var isDropAllowed = !_this7.validateDrop || _this7.validateDrop({\n              clientX: clientX,\n              clientY: clientY,\n              target: target\n            });\n\n            if (droppableElement.scrollContainerRect) {\n              return isWithinElement && isDropAllowed && isCoordinateWithinRectangle(clientX, clientY,\n              /** @type {?} */\n              droppableElement.scrollContainerRect);\n            } else {\n              return isWithinElement && isDropAllowed;\n            }\n          }));\n          /** @type {?} */\n\n          var overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n          /** @type {?} */\n\n          var dragOverActive;\n          overlapsChanged$.pipe(filter(\n          /**\n          * @param {?} overlapsNow\n          * @return {?}\n          */\n          function (overlapsNow) {\n            return overlapsNow;\n          })).subscribe(\n          /**\n          * @return {?}\n          */\n          function () {\n            dragOverActive = true;\n            addClass(_this7.renderer, _this7.element, _this7.dragOverClass);\n\n            _this7.zone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              _this7.dragEnter.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n          overlaps$.pipe(filter(\n          /**\n          * @param {?} overlapsNow\n          * @return {?}\n          */\n          function (overlapsNow) {\n            return overlapsNow;\n          })).subscribe(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this7.zone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              _this7.dragOver.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n          overlapsChanged$.pipe(pairwise(), filter(\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          function (_ref12) {\n            var _ref13 = _slicedToArray(_ref12, 2),\n                didOverlap = _ref13[0],\n                overlapsNow = _ref13[1];\n\n            return didOverlap && !overlapsNow;\n          })).subscribe(\n          /**\n          * @return {?}\n          */\n          function () {\n            dragOverActive = false;\n            removeClass(_this7.renderer, _this7.element, _this7.dragOverClass);\n\n            _this7.zone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              _this7.dragLeave.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n          drag$.subscribe({\n            complete:\n            /**\n            * @return {?}\n            */\n            function complete() {\n              deregisterScrollListener();\n              removeClass(_this7.renderer, _this7.element, _this7.dragActiveClass);\n\n              if (dragOverActive) {\n                removeClass(_this7.renderer, _this7.element, _this7.dragOverClass);\n\n                _this7.zone.run(\n                /**\n                * @return {?}\n                */\n                function () {\n                  _this7.drop.next({\n                    dropData: currentDragDropData\n                  });\n                });\n              }\n            }\n          });\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.currentDragSubscription) {\n          this.currentDragSubscription.unsubscribe();\n        }\n      }\n    }]);\n\n    return DroppableDirective;\n  }();\n\n  DroppableDirective.ɵfac = function DroppableDirective_Factory(t) {\n    return new (t || DroppableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8));\n  };\n\n  DroppableDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DroppableDirective,\n    selectors: [[\"\", \"mwlDroppable\", \"\"]],\n    inputs: {\n      dragOverClass: \"dragOverClass\",\n      dragActiveClass: \"dragActiveClass\",\n      validateDrop: \"validateDrop\"\n    },\n    outputs: {\n      dragEnter: \"dragEnter\",\n      dragLeave: \"dragLeave\",\n      dragOver: \"dragOver\",\n      drop: \"drop\"\n    }\n  });\n  return DroppableDirective;\n}();\n\nvar DragAndDropModule = /*@__PURE__*/function () {\n  var DragAndDropModule = function DragAndDropModule() {\n    _classCallCheck(this, DragAndDropModule);\n  };\n\n  DragAndDropModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DragAndDropModule\n  });\n  DragAndDropModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    factory: function DragAndDropModule_Factory(t) {\n      return new (t || DragAndDropModule)();\n    }\n  });\n  return DragAndDropModule;\n}();\n/*@__PURE__*/\n\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragAndDropModule, {\n    declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],\n    exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { DragAndDropModule, DraggableHelper as ɵc, DraggableScrollContainerDirective as ɵd, DraggableDirective as ɵb, DroppableDirective as ɵa };","map":null,"metadata":{},"sourceType":"module"}