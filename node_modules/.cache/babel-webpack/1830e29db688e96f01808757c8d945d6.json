{"ast":null,"code":"import _slicedToArray from \"C:/Users/DTI_UCH/Desktop/template_angularjs10/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createClass from \"C:/Users/DTI_UCH/Desktop/template_angularjs10/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"C:/Users/DTI_UCH/Desktop/template_angularjs10/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { Subject, Observable, merge, ReplaySubject, combineLatest, fromEvent } from 'rxjs';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\nimport { Injectable, Directive, ElementRef, Input, Renderer2, Output, EventEmitter, NgZone, Inject, ViewContainerRef, Optional, NgModule, defineInjectable } from '@angular/core';\nimport { map, mergeMap, takeUntil, take, takeLast, pairwise, share, filter, count, startWith, distinctUntilChanged } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar DraggableHelper = function DraggableHelper() {\n  _classCallCheck(this, DraggableHelper);\n\n  this.currentDrag = new Subject();\n};\n\nDraggableHelper.ɵfac = function DraggableHelper_Factory(t) {\n  return new (t || DraggableHelper)();\n};\n\nDraggableHelper.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: DraggableHelper,\n  factory: DraggableHelper.ɵfac,\n  providedIn: 'root'\n});\n/** @nocollapse */\n\nDraggableHelper.ngInjectableDef = defineInjectable({\n  factory: function DraggableHelper_Factory() {\n    return new DraggableHelper();\n  },\n  token: DraggableHelper,\n  providedIn: \"root\"\n});\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DraggableHelper, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n * <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n * <div mwlDraggable>Drag me!</div>\n * </div>\n * ```\n */\n\n\nvar DraggableScrollContainerDirective =\n/**\n * @hidden\n * @param {?} elementRef\n */\nfunction DraggableScrollContainerDirective(elementRef) {\n  _classCallCheck(this, DraggableScrollContainerDirective);\n\n  this.elementRef = elementRef;\n  /**\n   * Trigger the DragStart after a long touch in scrollable container when true\n   * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n   */\n\n  this.activeLongPressDrag = false;\n  /**\n   * Configuration of a long touch\n   * Duration in ms of a long touch before activating DragStart\n   * Delta of the\n   * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n   */\n\n  this.longPressConfig = {\n    duration: 300,\n    delta: 30\n  };\n};\n\nDraggableScrollContainerDirective.ɵfac = function DraggableScrollContainerDirective_Factory(t) {\n  return new (t || DraggableScrollContainerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n};\n\nDraggableScrollContainerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DraggableScrollContainerDirective,\n  selectors: [[\"\", \"mwlDraggableScrollContainer\", \"\"]],\n  inputs: {\n    activeLongPressDrag: \"activeLongPressDrag\",\n    longPressConfig: \"longPressConfig\"\n  }\n});\n/** @nocollapse */\n\nDraggableScrollContainerDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }];\n};\n\nDraggableScrollContainerDirective.propDecorators = {\n  activeLongPressDrag: [{\n    type: Input\n  }],\n  longPressConfig: [{\n    type: Input\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DraggableScrollContainerDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggableScrollContainer]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }];\n  }, {\n    activeLongPressDrag: [{\n      type: Input\n    }],\n    longPressConfig: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} renderer\n * @param {?} element\n * @param {?} classToAdd\n * @return {?}\n */\n\n\nfunction addClass(renderer, element, classToAdd) {\n  if (classToAdd) {\n    classToAdd.split(' ').forEach(\n    /**\n    * @param {?} className\n    * @return {?}\n    */\n    function (className) {\n      return renderer.addClass(element.nativeElement, className);\n    });\n  }\n}\n/**\n * @param {?} renderer\n * @param {?} element\n * @param {?} classToRemove\n * @return {?}\n */\n\n\nfunction removeClass(renderer, element, classToRemove) {\n  if (classToRemove) {\n    classToRemove.split(' ').forEach(\n    /**\n    * @param {?} className\n    * @return {?}\n    */\n    function (className) {\n      return renderer.removeClass(element.nativeElement, className);\n    });\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar DraggableDirective = /*#__PURE__*/function () {\n  /**\n   * @hidden\n   * @param {?} element\n   * @param {?} renderer\n   * @param {?} draggableHelper\n   * @param {?} zone\n   * @param {?} vcr\n   * @param {?} scrollContainer\n   * @param {?} document\n   */\n  function DraggableDirective(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n    _classCallCheck(this, DraggableDirective);\n\n    this.element = element;\n    this.renderer = renderer;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.vcr = vcr;\n    this.scrollContainer = scrollContainer;\n    this.document = document;\n    /**\n     * The axis along which the element is draggable\n     */\n\n    this.dragAxis = {\n      x: true,\n      y: true\n    };\n    /**\n     * Snap all drags to an x / y grid\n     */\n\n    this.dragSnapGrid = {};\n    /**\n     * Show a ghost element that shows the drag when dragging\n     */\n\n    this.ghostDragEnabled = true;\n    /**\n     * Show the original element when ghostDragEnabled is true\n     */\n\n    this.showOriginalElementWhileDragging = false;\n    /**\n     * The cursor to use when hovering over a draggable element\n     */\n\n    this.dragCursor = '';\n    /*\n       * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n       */\n\n    this.autoScroll = {\n      margin: 20\n    };\n    /**\n     * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n     */\n\n    this.dragPointerDown = new EventEmitter();\n    /**\n     * Called when the element has started to be dragged.\n     * Only called after at least one mouse or touch move event.\n     * If you call $event.cancelDrag$.emit() it will cancel the current drag\n     */\n\n    this.dragStart = new EventEmitter();\n    /**\n     * Called after the ghost element has been created\n     */\n\n    this.ghostElementCreated = new EventEmitter();\n    /**\n     * Called when the element is being dragged\n     */\n\n    this.dragging = new EventEmitter();\n    /**\n     * Called after the element is dragged\n     */\n\n    this.dragEnd = new EventEmitter();\n    /**\n     * @hidden\n     */\n\n    this.pointerDown$ = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.pointerMove$ = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.pointerUp$ = new Subject();\n    this.eventListenerSubscriptions = {};\n    this.destroy$ = new Subject();\n    this.timeLongPress = {\n      timerBegin: 0,\n      timerEnd: 0\n    };\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(DraggableDirective, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this = this;\n\n      this.checkEventListeners();\n      /** @type {?} */\n\n      var pointerDragged$ = this.pointerDown$.pipe(filter(\n      /**\n      * @return {?}\n      */\n      function () {\n        return _this.canDrag();\n      }), mergeMap(\n      /**\n      * @param {?} pointerDownEvent\n      * @return {?}\n      */\n      function (pointerDownEvent) {\n        // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n        // stop mouse events propagating up the chain\n        if (pointerDownEvent.event.stopPropagation && !_this.scrollContainer) {\n          pointerDownEvent.event.stopPropagation();\n        } // hack to prevent text getting selected in safari while dragging\n\n        /** @type {?} */\n\n\n        var globalDragStyle = _this.renderer.createElement('style');\n\n        _this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n\n        _this.renderer.appendChild(globalDragStyle, _this.renderer.createText(\"\\n          body * {\\n           -moz-user-select: none;\\n           -ms-user-select: none;\\n           -webkit-user-select: none;\\n           user-select: none;\\n          }\\n        \"));\n\n        requestAnimationFrame(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this.document.head.appendChild(globalDragStyle);\n        });\n        /** @type {?} */\n\n        var startScrollPosition = _this.getScrollPosition();\n        /** @type {?} */\n\n\n        var scrollContainerScroll$ = new Observable(\n        /**\n        * @param {?} observer\n        * @return {?}\n        */\n        function (observer) {\n          /** @type {?} */\n          var scrollContainer = _this.scrollContainer ? _this.scrollContainer.elementRef.nativeElement : 'window';\n          return _this.renderer.listen(scrollContainer, 'scroll',\n          /**\n          * @param {?} e\n          * @return {?}\n          */\n          function (e) {\n            return observer.next(e);\n          });\n        }).pipe(startWith(startScrollPosition), map(\n        /**\n        * @return {?}\n        */\n        function () {\n          return _this.getScrollPosition();\n        }));\n        /** @type {?} */\n\n        var currentDrag$ = new Subject();\n        /** @type {?} */\n\n        var cancelDrag$ = new ReplaySubject();\n\n        _this.zone.run(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this.dragPointerDown.next({\n            x: 0,\n            y: 0\n          });\n        });\n        /** @type {?} */\n\n\n        var dragComplete$ = merge(_this.pointerUp$, _this.pointerDown$, cancelDrag$, _this.destroy$).pipe(share());\n        /** @type {?} */\n\n        var pointerMove = combineLatest([_this.pointerMove$, scrollContainerScroll$]).pipe(map(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              pointerMoveEvent = _ref2[0],\n              scroll = _ref2[1];\n\n          return {\n            currentDrag$: currentDrag$,\n            transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n            transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n            clientX: pointerMoveEvent.clientX,\n            clientY: pointerMoveEvent.clientY,\n            scrollLeft: scroll.left,\n            scrollTop: scroll.top,\n            target: pointerMoveEvent.event.target\n          };\n        }), map(\n        /**\n        * @param {?} moveData\n        * @return {?}\n        */\n        function (moveData) {\n          if (_this.dragSnapGrid.x) {\n            moveData.transformX = Math.round(moveData.transformX / _this.dragSnapGrid.x) * _this.dragSnapGrid.x;\n          }\n\n          if (_this.dragSnapGrid.y) {\n            moveData.transformY = Math.round(moveData.transformY / _this.dragSnapGrid.y) * _this.dragSnapGrid.y;\n          }\n\n          return moveData;\n        }), map(\n        /**\n        * @param {?} moveData\n        * @return {?}\n        */\n        function (moveData) {\n          if (!_this.dragAxis.x) {\n            moveData.transformX = 0;\n          }\n\n          if (!_this.dragAxis.y) {\n            moveData.transformY = 0;\n          }\n\n          return moveData;\n        }), map(\n        /**\n        * @param {?} moveData\n        * @return {?}\n        */\n        function (moveData) {\n          /** @type {?} */\n          var scrollX = moveData.scrollLeft - startScrollPosition.left;\n          /** @type {?} */\n\n          var scrollY = moveData.scrollTop - startScrollPosition.top;\n          return Object.assign({}, moveData, {\n            x: moveData.transformX + scrollX,\n            y: moveData.transformY + scrollY\n          });\n        }), filter(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref3) {\n          var x = _ref3.x,\n              y = _ref3.y,\n              transformX = _ref3.transformX,\n              transformY = _ref3.transformY;\n          return !_this.validateDrag || _this.validateDrag({\n            x: x,\n            y: y,\n            transform: {\n              x: transformX,\n              y: transformY\n            }\n          });\n        }), takeUntil(dragComplete$), share());\n        /** @type {?} */\n\n        var dragStarted$ = pointerMove.pipe(take(1), share());\n        /** @type {?} */\n\n        var dragEnded$ = pointerMove.pipe(takeLast(1), share());\n        dragStarted$.subscribe(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref4) {\n          var clientX = _ref4.clientX,\n              clientY = _ref4.clientY,\n              x = _ref4.x,\n              y = _ref4.y;\n\n          _this.zone.run(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this.dragStart.next({\n              cancelDrag$: cancelDrag$\n            });\n          });\n\n          _this.scroller = autoScroll([_this.scrollContainer ? _this.scrollContainer.elementRef.nativeElement : _this.document.defaultView], Object.assign({}, _this.autoScroll, {\n            /**\n            * @return {?}\n            */\n            autoScroll: function autoScroll() {\n              return true;\n            }\n          }));\n          addClass(_this.renderer, _this.element, _this.dragActiveClass);\n\n          if (_this.ghostDragEnabled) {\n            /** @type {?} */\n            var rect = _this.element.nativeElement.getBoundingClientRect();\n            /** @type {?} */\n\n\n            var clone =\n            /** @type {?} */\n            _this.element.nativeElement.cloneNode(true);\n\n            if (!_this.showOriginalElementWhileDragging) {\n              _this.renderer.setStyle(_this.element.nativeElement, 'visibility', 'hidden');\n            }\n\n            if (_this.ghostElementAppendTo) {\n              _this.ghostElementAppendTo.appendChild(clone);\n            } else {\n              /** @type {?} */\n              _this.element.nativeElement.parentNode.insertBefore(clone, _this.element.nativeElement.nextSibling);\n            }\n\n            _this.ghostElement = clone;\n            _this.document.body.style.cursor = _this.dragCursor;\n\n            _this.setElementStyles(clone, {\n              position: 'fixed',\n              top: \"\".concat(rect.top, \"px\"),\n              left: \"\".concat(rect.left, \"px\"),\n              width: \"\".concat(rect.width, \"px\"),\n              height: \"\".concat(rect.height, \"px\"),\n              cursor: _this.dragCursor,\n              margin: '0',\n              willChange: 'transform',\n              pointerEvents: 'none'\n            });\n\n            if (_this.ghostElementTemplate) {\n              /** @type {?} */\n              var viewRef = _this.vcr.createEmbeddedView(_this.ghostElementTemplate);\n\n              clone.innerHTML = '';\n              viewRef.rootNodes.filter(\n              /**\n              * @param {?} node\n              * @return {?}\n              */\n              function (node) {\n                return node instanceof Node;\n              }).forEach(\n              /**\n              * @param {?} node\n              * @return {?}\n              */\n              function (node) {\n                clone.appendChild(node);\n              });\n              dragEnded$.subscribe(\n              /**\n              * @return {?}\n              */\n              function () {\n                _this.vcr.remove(_this.vcr.indexOf(viewRef));\n              });\n            }\n\n            _this.zone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              _this.ghostElementCreated.emit({\n                clientX: clientX - x,\n                clientY: clientY - y,\n                element: clone\n              });\n            });\n\n            dragEnded$.subscribe(\n            /**\n            * @return {?}\n            */\n            function () {\n              /** @type {?} */\n              clone.parentElement.removeChild(clone);\n              _this.ghostElement = null;\n\n              _this.renderer.setStyle(_this.element.nativeElement, 'visibility', '');\n            });\n          }\n\n          _this.draggableHelper.currentDrag.next(currentDrag$);\n        });\n        dragEnded$.pipe(mergeMap(\n        /**\n        * @param {?} dragEndData\n        * @return {?}\n        */\n        function (dragEndData) {\n          /** @type {?} */\n          var dragEndData$ = cancelDrag$.pipe(count(), take(1), map(\n          /**\n          * @param {?} calledCount\n          * @return {?}\n          */\n          function (calledCount) {\n            return Object.assign({}, dragEndData, {\n              dragCancelled: calledCount > 0\n            });\n          }));\n          cancelDrag$.complete();\n          return dragEndData$;\n        })).subscribe(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref5) {\n          var x = _ref5.x,\n              y = _ref5.y,\n              dragCancelled = _ref5.dragCancelled;\n\n          _this.scroller.destroy();\n\n          _this.zone.run(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this.dragEnd.next({\n              x: x,\n              y: y,\n              dragCancelled: dragCancelled\n            });\n          });\n\n          removeClass(_this.renderer, _this.element, _this.dragActiveClass);\n          currentDrag$.complete();\n        });\n        merge(dragComplete$, dragEnded$).pipe(take(1)).subscribe(\n        /**\n        * @return {?}\n        */\n        function () {\n          requestAnimationFrame(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this.document.head.removeChild(globalDragStyle);\n          });\n        });\n        return pointerMove;\n      }), share());\n      merge(pointerDragged$.pipe(take(1), map(\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      function (value) {\n        return [, value];\n      })), pointerDragged$.pipe(pairwise())).pipe(filter(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 2),\n            previous = _ref7[0],\n            next = _ref7[1];\n\n        if (!previous) {\n          return true;\n        }\n\n        return previous.x !== next.x || previous.y !== next.y;\n      }), map(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref8) {\n        var _ref9 = _slicedToArray(_ref8, 2),\n            previous = _ref9[0],\n            next = _ref9[1];\n\n        return next;\n      })).subscribe(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref10) {\n        var x = _ref10.x,\n            y = _ref10.y,\n            currentDrag$ = _ref10.currentDrag$,\n            clientX = _ref10.clientX,\n            clientY = _ref10.clientY,\n            transformX = _ref10.transformX,\n            transformY = _ref10.transformY,\n            target = _ref10.target;\n\n        _this.zone.run(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this.dragging.next({\n            x: x,\n            y: y\n          });\n        });\n\n        requestAnimationFrame(\n        /**\n        * @return {?}\n        */\n        function () {\n          if (_this.ghostElement) {\n            /** @type {?} */\n            var transform = \"translate3d(\".concat(transformX, \"px, \").concat(transformY, \"px, 0px)\");\n\n            _this.setElementStyles(_this.ghostElement, {\n              transform: transform,\n              '-webkit-transform': transform,\n              '-ms-transform': transform,\n              '-moz-transform': transform,\n              '-o-transform': transform\n            });\n          }\n        });\n        currentDrag$.next({\n          clientX: clientX,\n          clientY: clientY,\n          dropData: _this.dropData,\n          target: target\n        });\n      });\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      if (changes.dragAxis) {\n        this.checkEventListeners();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.unsubscribeEventListeners();\n      this.pointerDown$.complete();\n      this.pointerMove$.complete();\n      this.pointerUp$.complete();\n      this.destroy$.next();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"checkEventListeners\",\n    value: function checkEventListeners() {\n      var _this2 = this;\n\n      /** @type {?} */\n      var canDrag = this.canDrag();\n      /** @type {?} */\n\n      var hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n\n      if (canDrag && !hasEventListeners) {\n        this.zone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this2.eventListenerSubscriptions.mousedown = _this2.renderer.listen(_this2.element.nativeElement, 'mousedown',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            _this2.onMouseDown(event);\n          });\n          _this2.eventListenerSubscriptions.mouseup = _this2.renderer.listen('document', 'mouseup',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            _this2.onMouseUp(event);\n          });\n          _this2.eventListenerSubscriptions.touchstart = _this2.renderer.listen(_this2.element.nativeElement, 'touchstart',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            _this2.onTouchStart(event);\n          });\n          _this2.eventListenerSubscriptions.touchend = _this2.renderer.listen('document', 'touchend',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            _this2.onTouchEnd(event);\n          });\n          _this2.eventListenerSubscriptions.touchcancel = _this2.renderer.listen('document', 'touchcancel',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            _this2.onTouchEnd(event);\n          });\n          _this2.eventListenerSubscriptions.mouseenter = _this2.renderer.listen(_this2.element.nativeElement, 'mouseenter',\n          /**\n          * @return {?}\n          */\n          function () {\n            _this2.onMouseEnter();\n          });\n          _this2.eventListenerSubscriptions.mouseleave = _this2.renderer.listen(_this2.element.nativeElement, 'mouseleave',\n          /**\n          * @return {?}\n          */\n          function () {\n            _this2.onMouseLeave();\n          });\n        });\n      } else if (!canDrag && hasEventListeners) {\n        this.unsubscribeEventListeners();\n      }\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(event) {\n      var _this3 = this;\n\n      if (event.button === 0) {\n        if (!this.eventListenerSubscriptions.mousemove) {\n          this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove',\n          /**\n          * @param {?} mouseMoveEvent\n          * @return {?}\n          */\n          function (mouseMoveEvent) {\n            _this3.pointerMove$.next({\n              event: mouseMoveEvent,\n              clientX: mouseMoveEvent.clientX,\n              clientY: mouseMoveEvent.clientY\n            });\n          });\n        }\n\n        this.pointerDown$.next({\n          event: event,\n          clientX: event.clientX,\n          clientY: event.clientY\n        });\n      }\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(event) {\n      if (event.button === 0) {\n        if (this.eventListenerSubscriptions.mousemove) {\n          this.eventListenerSubscriptions.mousemove();\n          delete this.eventListenerSubscriptions.mousemove;\n        }\n\n        this.pointerUp$.next({\n          event: event,\n          clientX: event.clientX,\n          clientY: event.clientY\n        });\n      }\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onTouchStart\",\n    value: function onTouchStart(event) {\n      var _this4 = this;\n\n      /** @type {?} */\n      var startScrollPosition;\n      /** @type {?} */\n\n      var isDragActivated;\n      /** @type {?} */\n\n      var hasContainerScrollbar;\n\n      if (this.scrollContainer && this.scrollContainer.activeLongPressDrag || this.touchStartLongPress) {\n        this.timeLongPress.timerBegin = Date.now();\n        isDragActivated = false;\n        hasContainerScrollbar = this.hasScrollbar();\n        startScrollPosition = this.getScrollPosition();\n      }\n\n      if (!this.eventListenerSubscriptions.touchmove) {\n        /** @type {?} */\n        var contextMenuListener = fromEvent(this.document, 'contextmenu').subscribe(\n        /**\n        * @param {?} e\n        * @return {?}\n        */\n        function (e) {\n          e.preventDefault();\n        });\n        /** @type {?} */\n\n        var touchMoveListener = fromEvent(this.document, 'touchmove', {\n          passive: false\n        }).subscribe(\n        /**\n        * @param {?} touchMoveEvent\n        * @return {?}\n        */\n        function (touchMoveEvent) {\n          if ((_this4.scrollContainer && _this4.scrollContainer.activeLongPressDrag || _this4.touchStartLongPress) && !isDragActivated && hasContainerScrollbar) {\n            isDragActivated = _this4.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n          }\n\n          if ((!_this4.scrollContainer || !_this4.scrollContainer.activeLongPressDrag) && !_this4.touchStartLongPress || !hasContainerScrollbar || isDragActivated) {\n            touchMoveEvent.preventDefault();\n\n            _this4.pointerMove$.next({\n              event: touchMoveEvent,\n              clientX: touchMoveEvent.targetTouches[0].clientX,\n              clientY: touchMoveEvent.targetTouches[0].clientY\n            });\n          }\n        });\n\n        this.eventListenerSubscriptions.touchmove =\n        /**\n        * @return {?}\n        */\n        function () {\n          contextMenuListener.unsubscribe();\n          touchMoveListener.unsubscribe();\n        };\n      }\n\n      this.pointerDown$.next({\n        event: event,\n        clientX: event.touches[0].clientX,\n        clientY: event.touches[0].clientY\n      });\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onTouchEnd\",\n    value: function onTouchEnd(event) {\n      if (this.eventListenerSubscriptions.touchmove) {\n        this.eventListenerSubscriptions.touchmove();\n        delete this.eventListenerSubscriptions.touchmove;\n\n        if (this.scrollContainer && this.scrollContainer.activeLongPressDrag || this.touchStartLongPress) {\n          this.enableScroll();\n        }\n      }\n\n      this.pointerUp$.next({\n        event: event,\n        clientX: event.changedTouches[0].clientX,\n        clientY: event.changedTouches[0].clientY\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"onMouseEnter\",\n    value: function onMouseEnter() {\n      this.setCursor(this.dragCursor);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"onMouseLeave\",\n    value: function onMouseLeave() {\n      this.setCursor('');\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"canDrag\",\n    value: function canDrag() {\n      return this.dragAxis.x || this.dragAxis.y;\n    }\n    /**\n     * @private\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"setCursor\",\n    value: function setCursor(value) {\n      if (!this.eventListenerSubscriptions.mousemove) {\n        this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"unsubscribeEventListeners\",\n    value: function unsubscribeEventListeners() {\n      var _this5 = this;\n\n      Object.keys(this.eventListenerSubscriptions).forEach(\n      /**\n      * @param {?} type\n      * @return {?}\n      */\n      function (type) {\n        /** @type {?} */\n        _this5.eventListenerSubscriptions[type]();\n\n        delete\n        /** @type {?} */\n        _this5.eventListenerSubscriptions[type];\n      });\n    }\n    /**\n     * @private\n     * @param {?} element\n     * @param {?} styles\n     * @return {?}\n     */\n\n  }, {\n    key: \"setElementStyles\",\n    value: function setElementStyles(element, styles) {\n      var _this6 = this;\n\n      Object.keys(styles).forEach(\n      /**\n      * @param {?} key\n      * @return {?}\n      */\n      function (key) {\n        _this6.renderer.setStyle(element, key, styles[key]);\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"getScrollElement\",\n    value: function getScrollElement() {\n      if (this.scrollContainer) {\n        return this.scrollContainer.elementRef.nativeElement;\n      } else {\n        return this.document.body;\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"getScrollPosition\",\n    value: function getScrollPosition() {\n      if (this.scrollContainer) {\n        return {\n          top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n          left: this.scrollContainer.elementRef.nativeElement.scrollLeft\n        };\n      } else {\n        return {\n          top: window.pageYOffset || this.document.documentElement.scrollTop,\n          left: window.pageXOffset || this.document.documentElement.scrollLeft\n        };\n      }\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @param {?} touchMoveEvent\n     * @param {?} startScrollPosition\n     * @return {?}\n     */\n\n  }, {\n    key: \"shouldBeginDrag\",\n    value: function shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n      /** @type {?} */\n      var moveScrollPosition = this.getScrollPosition();\n      /** @type {?} */\n\n      var deltaScroll = {\n        top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n        left: Math.abs(moveScrollPosition.left - startScrollPosition.left)\n      };\n      /** @type {?} */\n\n      var deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n      /** @type {?} */\n\n      var deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n      /** @type {?} */\n\n      var deltaTotal = deltaX + deltaY;\n      /** @type {?} */\n\n      var longPressConfig = this.touchStartLongPress ? this.touchStartLongPress :\n      /* istanbul ignore next */\n      {\n        delta: this.scrollContainer.longPressConfig.delta,\n        delay: this.scrollContainer.longPressConfig.duration\n      };\n\n      if (deltaTotal > longPressConfig.delta || deltaScroll.top > 0 || deltaScroll.left > 0) {\n        this.timeLongPress.timerBegin = Date.now();\n      }\n\n      this.timeLongPress.timerEnd = Date.now();\n      /** @type {?} */\n\n      var duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n\n      if (duration >= longPressConfig.delay) {\n        this.disableScroll();\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"enableScroll\",\n    value: function enableScroll() {\n      if (this.scrollContainer) {\n        this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n      }\n\n      this.renderer.setStyle(this.document.body, 'overflow', '');\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"disableScroll\",\n    value: function disableScroll() {\n      /* istanbul ignore next */\n      if (this.scrollContainer) {\n        this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n      }\n\n      this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"hasScrollbar\",\n    value: function hasScrollbar() {\n      /** @type {?} */\n      var scrollContainer = this.getScrollElement();\n      /** @type {?} */\n\n      var containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n      /** @type {?} */\n\n      var containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n      return containerHasHorizontalScroll || containerHasVerticalScroll;\n    }\n  }]);\n\n  return DraggableDirective;\n}();\n\nDraggableDirective.ɵfac = function DraggableDirective_Factory(t) {\n  return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n};\n\nDraggableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DraggableDirective,\n  selectors: [[\"\", \"mwlDraggable\", \"\"]],\n  inputs: {\n    dragAxis: \"dragAxis\",\n    dragSnapGrid: \"dragSnapGrid\",\n    ghostDragEnabled: \"ghostDragEnabled\",\n    showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\",\n    dragCursor: \"dragCursor\",\n    autoScroll: \"autoScroll\",\n    dropData: \"dropData\",\n    validateDrag: \"validateDrag\",\n    dragActiveClass: \"dragActiveClass\",\n    ghostElementAppendTo: \"ghostElementAppendTo\",\n    ghostElementTemplate: \"ghostElementTemplate\",\n    touchStartLongPress: \"touchStartLongPress\"\n  },\n  outputs: {\n    dragPointerDown: \"dragPointerDown\",\n    dragStart: \"dragStart\",\n    ghostElementCreated: \"ghostElementCreated\",\n    dragging: \"dragging\",\n    dragEnd: \"dragEnd\"\n  },\n  features: [ɵngcc0.ɵɵNgOnChangesFeature]\n});\n/** @nocollapse */\n\nDraggableDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }, {\n    type: DraggableHelper\n  }, {\n    type: NgZone\n  }, {\n    type: ViewContainerRef\n  }, {\n    type: DraggableScrollContainerDirective,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }];\n};\n\nDraggableDirective.propDecorators = {\n  dropData: [{\n    type: Input\n  }],\n  dragAxis: [{\n    type: Input\n  }],\n  dragSnapGrid: [{\n    type: Input\n  }],\n  ghostDragEnabled: [{\n    type: Input\n  }],\n  showOriginalElementWhileDragging: [{\n    type: Input\n  }],\n  validateDrag: [{\n    type: Input\n  }],\n  dragCursor: [{\n    type: Input\n  }],\n  dragActiveClass: [{\n    type: Input\n  }],\n  ghostElementAppendTo: [{\n    type: Input\n  }],\n  ghostElementTemplate: [{\n    type: Input\n  }],\n  touchStartLongPress: [{\n    type: Input\n  }],\n  autoScroll: [{\n    type: Input\n  }],\n  dragPointerDown: [{\n    type: Output\n  }],\n  dragStart: [{\n    type: Output\n  }],\n  ghostElementCreated: [{\n    type: Output\n  }],\n  dragging: [{\n    type: Output\n  }],\n  dragEnd: [{\n    type: Output\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DraggableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggable]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: DraggableHelper\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: ɵngcc0.ViewContainerRef\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, {\n    dragAxis: [{\n      type: Input\n    }],\n    dragSnapGrid: [{\n      type: Input\n    }],\n    ghostDragEnabled: [{\n      type: Input\n    }],\n    showOriginalElementWhileDragging: [{\n      type: Input\n    }],\n    dragCursor: [{\n      type: Input\n    }],\n    autoScroll: [{\n      type: Input\n    }],\n    dragPointerDown: [{\n      type: Output\n    }],\n    dragStart: [{\n      type: Output\n    }],\n    ghostElementCreated: [{\n      type: Output\n    }],\n    dragging: [{\n      type: Output\n    }],\n    dragEnd: [{\n      type: Output\n    }],\n    dropData: [{\n      type: Input\n    }],\n    validateDrag: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }],\n    ghostElementAppendTo: [{\n      type: Input\n    }],\n    ghostElementTemplate: [{\n      type: Input\n    }],\n    touchStartLongPress: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} clientX\n * @param {?} clientY\n * @param {?} rect\n * @return {?}\n */\n\n\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n  return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n}\n\nvar DroppableDirective = /*#__PURE__*/function () {\n  /**\n   * @param {?} element\n   * @param {?} draggableHelper\n   * @param {?} zone\n   * @param {?} renderer\n   * @param {?} scrollContainer\n   */\n  function DroppableDirective(element, draggableHelper, zone, renderer, scrollContainer) {\n    _classCallCheck(this, DroppableDirective);\n\n    this.element = element;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.renderer = renderer;\n    this.scrollContainer = scrollContainer;\n    /**\n     * Called when a draggable element starts overlapping the element\n     */\n\n    this.dragEnter = new EventEmitter();\n    /**\n     * Called when a draggable element stops overlapping the element\n     */\n\n    this.dragLeave = new EventEmitter();\n    /**\n     * Called when a draggable element is moved over the element\n     */\n\n    this.dragOver = new EventEmitter();\n    /**\n     * Called when a draggable element is dropped on this element\n     */\n\n    this.drop = new EventEmitter(); // tslint:disable-line no-output-named-after-standard-event\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(DroppableDirective, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this7 = this;\n\n      this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(\n      /**\n      * @param {?} drag$\n      * @return {?}\n      */\n      function (drag$) {\n        addClass(_this7.renderer, _this7.element, _this7.dragActiveClass);\n        /** @type {?} */\n\n        var droppableElement = {\n          updateCache: true\n        };\n        /** @type {?} */\n\n        var deregisterScrollListener = _this7.renderer.listen(_this7.scrollContainer ? _this7.scrollContainer.elementRef.nativeElement : 'window', 'scroll',\n        /**\n        * @return {?}\n        */\n        function () {\n          droppableElement.updateCache = true;\n        });\n        /** @type {?} */\n\n\n        var currentDragDropData;\n        /** @type {?} */\n\n        var overlaps$ = drag$.pipe(map(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref11) {\n          var clientX = _ref11.clientX,\n              clientY = _ref11.clientY,\n              dropData = _ref11.dropData,\n              target = _ref11.target;\n          currentDragDropData = dropData;\n\n          if (droppableElement.updateCache) {\n            droppableElement.rect = _this7.element.nativeElement.getBoundingClientRect();\n\n            if (_this7.scrollContainer) {\n              droppableElement.scrollContainerRect = _this7.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n            }\n\n            droppableElement.updateCache = false;\n          }\n          /** @type {?} */\n\n\n          var isWithinElement = isCoordinateWithinRectangle(clientX, clientY,\n          /** @type {?} */\n          droppableElement.rect);\n          /** @type {?} */\n\n          var isDropAllowed = !_this7.validateDrop || _this7.validateDrop({\n            clientX: clientX,\n            clientY: clientY,\n            target: target\n          });\n\n          if (droppableElement.scrollContainerRect) {\n            return isWithinElement && isDropAllowed && isCoordinateWithinRectangle(clientX, clientY,\n            /** @type {?} */\n            droppableElement.scrollContainerRect);\n          } else {\n            return isWithinElement && isDropAllowed;\n          }\n        }));\n        /** @type {?} */\n\n        var overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n        /** @type {?} */\n\n        var dragOverActive;\n        overlapsChanged$.pipe(filter(\n        /**\n        * @param {?} overlapsNow\n        * @return {?}\n        */\n        function (overlapsNow) {\n          return overlapsNow;\n        })).subscribe(\n        /**\n        * @return {?}\n        */\n        function () {\n          dragOverActive = true;\n          addClass(_this7.renderer, _this7.element, _this7.dragOverClass);\n\n          _this7.zone.run(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this7.dragEnter.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n        overlaps$.pipe(filter(\n        /**\n        * @param {?} overlapsNow\n        * @return {?}\n        */\n        function (overlapsNow) {\n          return overlapsNow;\n        })).subscribe(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this7.zone.run(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this7.dragOver.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n        overlapsChanged$.pipe(pairwise(), filter(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref12) {\n          var _ref13 = _slicedToArray(_ref12, 2),\n              didOverlap = _ref13[0],\n              overlapsNow = _ref13[1];\n\n          return didOverlap && !overlapsNow;\n        })).subscribe(\n        /**\n        * @return {?}\n        */\n        function () {\n          dragOverActive = false;\n          removeClass(_this7.renderer, _this7.element, _this7.dragOverClass);\n\n          _this7.zone.run(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this7.dragLeave.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n        drag$.subscribe({\n          complete:\n          /**\n          * @return {?}\n          */\n          function complete() {\n            deregisterScrollListener();\n            removeClass(_this7.renderer, _this7.element, _this7.dragActiveClass);\n\n            if (dragOverActive) {\n              removeClass(_this7.renderer, _this7.element, _this7.dragOverClass);\n\n              _this7.zone.run(\n              /**\n              * @return {?}\n              */\n              function () {\n                _this7.drop.next({\n                  dropData: currentDragDropData\n                });\n              });\n            }\n          }\n        });\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      if (this.currentDragSubscription) {\n        this.currentDragSubscription.unsubscribe();\n      }\n    }\n  }]);\n\n  return DroppableDirective;\n}();\n\nDroppableDirective.ɵfac = function DroppableDirective_Factory(t) {\n  return new (t || DroppableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8));\n};\n\nDroppableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DroppableDirective,\n  selectors: [[\"\", \"mwlDroppable\", \"\"]],\n  inputs: {\n    dragOverClass: \"dragOverClass\",\n    dragActiveClass: \"dragActiveClass\",\n    validateDrop: \"validateDrop\"\n  },\n  outputs: {\n    dragEnter: \"dragEnter\",\n    dragLeave: \"dragLeave\",\n    dragOver: \"dragOver\",\n    drop: \"drop\"\n  }\n});\n/** @nocollapse */\n\nDroppableDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: DraggableHelper\n  }, {\n    type: NgZone\n  }, {\n    type: Renderer2\n  }, {\n    type: DraggableScrollContainerDirective,\n    decorators: [{\n      type: Optional\n    }]\n  }];\n};\n\nDroppableDirective.propDecorators = {\n  dragOverClass: [{\n    type: Input\n  }],\n  dragActiveClass: [{\n    type: Input\n  }],\n  validateDrop: [{\n    type: Input\n  }],\n  dragEnter: [{\n    type: Output\n  }],\n  dragLeave: [{\n    type: Output\n  }],\n  dragOver: [{\n    type: Output\n  }],\n  drop: [{\n    type: Output\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DroppableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDroppable]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: DraggableHelper\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    dragEnter: [{\n      type: Output\n    }],\n    dragLeave: [{\n      type: Output\n    }],\n    dragOver: [{\n      type: Output\n    }],\n    drop: [{\n      type: Output\n    }],\n    dragOverClass: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }],\n    validateDrop: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar DragAndDropModule = function DragAndDropModule() {\n  _classCallCheck(this, DragAndDropModule);\n};\n\nDragAndDropModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: DragAndDropModule\n});\nDragAndDropModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function DragAndDropModule_Factory(t) {\n    return new (t || DragAndDropModule)();\n  }\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragAndDropModule, {\n    declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],\n    exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]\n  });\n})();\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DragAndDropModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],\n      exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { DragAndDropModule, DraggableHelper as ɵc, DraggableScrollContainerDirective as ɵd, DraggableDirective as ɵb, DroppableDirective as ɵa };","map":{"version":3,"sources":["angular-draggable-droppable/lib/draggable-helper.provider.ts","angular-draggable-droppable/lib/draggable-scroll-container.directive.ts","angular-draggable-droppable/lib/util.ts","angular-draggable-droppable/lib/draggable.directive.ts","angular-draggable-droppable/lib/droppable.directive.ts","angular-draggable-droppable/lib/drag-and-drop.module.ts"],"names":[],"mappings":"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","sourcesContent":["import { Subject } from 'rxjs';\nimport { Injectable } from '@angular/core';\n\nexport interface CurrentDragData {\n  clientX: number;\n  clientY: number;\n  dropData: any;\n  target: EventTarget;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class DraggableHelper {\n  currentDrag = new Subject<Subject<CurrentDragData>>();\n}\n","import {\n  Directive,\n  ElementRef,\n  Input,\n  NgZone,\n  OnInit,\n  Renderer2,\n} from '@angular/core';\n\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n  <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n    <div mwlDraggable>Drag me!</div>\n  </div>\n  ```\n */\n@Directive({\n  selector: '[mwlDraggableScrollContainer]',\n})\nexport class DraggableScrollContainerDirective {\n  /**\n   * Trigger the DragStart after a long touch in scrollable container when true\n   * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n   */\n  @Input() activeLongPressDrag: boolean = false;\n\n  /**\n   * Configuration of a long touch\n   * Duration in ms of a long touch before activating DragStart\n   * Delta of the\n   * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n   */\n  @Input() longPressConfig = { duration: 300, delta: 30 };\n\n  /**\n   * @hidden\n   */\n  constructor(public elementRef: ElementRef<HTMLElement>) {}\n}\n","import { ElementRef, Renderer2 } from '@angular/core';\n\nexport function addClass(\n  renderer: Renderer2,\n  element: ElementRef<HTMLElement>,\n  classToAdd: string\n) {\n  if (classToAdd) {\n    classToAdd\n      .split(' ')\n      .forEach((className) =>\n        renderer.addClass(element.nativeElement, className)\n      );\n  }\n}\n\nexport function removeClass(\n  renderer: Renderer2,\n  element: ElementRef<HTMLElement>,\n  classToRemove: string\n) {\n  if (classToRemove) {\n    classToRemove\n      .split(' ')\n      .forEach((className) =>\n        renderer.removeClass(element.nativeElement, className)\n      );\n  }\n}\n","import {\n  Directive,\n  OnInit,\n  ElementRef,\n  Renderer2,\n  Output,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  OnChanges,\n  NgZone,\n  SimpleChanges,\n  Inject,\n  TemplateRef,\n  ViewContainerRef,\n  Optional,\n} from '@angular/core';\nimport {\n  Subject,\n  Observable,\n  merge,\n  ReplaySubject,\n  combineLatest,\n  fromEvent,\n} from 'rxjs';\nimport {\n  map,\n  mergeMap,\n  takeUntil,\n  take,\n  takeLast,\n  pairwise,\n  share,\n  filter,\n  count,\n  startWith,\n} from 'rxjs/operators';\nimport { CurrentDragData, DraggableHelper } from './draggable-helper.provider';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\nimport { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';\nimport { addClass, removeClass } from './util';\n\nexport interface Coordinates {\n  x: number;\n  y: number;\n}\n\nexport interface DragAxis {\n  x: boolean;\n  y: boolean;\n}\n\nexport interface SnapGrid {\n  x?: number;\n  y?: number;\n}\n\nexport interface DragPointerDownEvent extends Coordinates {}\n\nexport interface DragStartEvent {\n  cancelDrag$: ReplaySubject<void>;\n}\n\nexport interface DragMoveEvent extends Coordinates {}\n\nexport interface DragEndEvent extends Coordinates {\n  dragCancelled: boolean;\n}\n\nexport interface ValidateDragParams extends Coordinates {\n  transform: {\n    x: number;\n    y: number;\n  };\n}\n\nexport type ValidateDrag = (params: ValidateDragParams) => boolean;\n\nexport interface PointerEvent {\n  clientX: number;\n  clientY: number;\n  event: MouseEvent | TouchEvent;\n}\n\nexport interface TimeLongPress {\n  timerBegin: number;\n  timerEnd: number;\n}\n\nexport interface GhostElementCreatedEvent {\n  clientX: number;\n  clientY: number;\n  element: HTMLElement;\n}\n\n@Directive({\n  selector: '[mwlDraggable]',\n})\nexport class DraggableDirective implements OnInit, OnChanges, OnDestroy {\n  /**\n   * an object of data you can pass to the drop event\n   */\n  @Input() dropData: any;\n\n  /**\n   * The axis along which the element is draggable\n   */\n  @Input() dragAxis: DragAxis = { x: true, y: true };\n\n  /**\n   * Snap all drags to an x / y grid\n   */\n  @Input() dragSnapGrid: SnapGrid = {};\n\n  /**\n   * Show a ghost element that shows the drag when dragging\n   */\n  @Input() ghostDragEnabled: boolean = true;\n\n  /**\n   * Show the original element when ghostDragEnabled is true\n   */\n  @Input() showOriginalElementWhileDragging: boolean = false;\n\n  /**\n   * Allow custom behaviour to control when the element is dragged\n   */\n  @Input() validateDrag: ValidateDrag;\n\n  /**\n   * The cursor to use when hovering over a draggable element\n   */\n  @Input() dragCursor: string = '';\n\n  /**\n   * The css class to apply when the element is being dragged\n   */\n  @Input() dragActiveClass: string;\n\n  /**\n   * The element the ghost element will be appended to. Default is next to the dragged element\n   */\n  @Input() ghostElementAppendTo: HTMLElement;\n\n  /**\n   * An ng-template to be inserted into the parent element of the ghost element. It will overwrite any child nodes.\n   */\n  @Input() ghostElementTemplate: TemplateRef<any>;\n\n  /**\n   * Amount of milliseconds to wait on touch devices before starting to drag the element (so that you can scroll the page by touching a draggable element)\n   */\n  @Input() touchStartLongPress: { delay: number; delta: number };\n\n  /*\n   * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n   */\n  @Input() autoScroll: {\n    margin:\n      | number\n      | { top?: number; left?: number; right?: number; bottom?: number };\n    maxSpeed?:\n      | number\n      | { top?: number; left?: number; right?: number; bottom?: number };\n    scrollWhenOutside?: boolean;\n  } = {\n    margin: 20,\n  };\n\n  /**\n   * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n   */\n  @Output() dragPointerDown = new EventEmitter<DragPointerDownEvent>();\n\n  /**\n   * Called when the element has started to be dragged.\n   * Only called after at least one mouse or touch move event.\n   * If you call $event.cancelDrag$.emit() it will cancel the current drag\n   */\n  @Output() dragStart = new EventEmitter<DragStartEvent>();\n\n  /**\n   * Called after the ghost element has been created\n   */\n  @Output() ghostElementCreated = new EventEmitter<GhostElementCreatedEvent>();\n\n  /**\n   * Called when the element is being dragged\n   */\n  @Output() dragging = new EventEmitter<DragMoveEvent>();\n\n  /**\n   * Called after the element is dragged\n   */\n  @Output() dragEnd = new EventEmitter<DragEndEvent>();\n\n  /**\n   * @hidden\n   */\n  pointerDown$ = new Subject<PointerEvent>();\n\n  /**\n   * @hidden\n   */\n  pointerMove$ = new Subject<PointerEvent>();\n\n  /**\n   * @hidden\n   */\n  pointerUp$ = new Subject<PointerEvent>();\n\n  private eventListenerSubscriptions: {\n    mousemove?: () => void;\n    mousedown?: () => void;\n    mouseup?: () => void;\n    mouseenter?: () => void;\n    mouseleave?: () => void;\n    touchstart?: () => void;\n    touchmove?: () => void;\n    touchend?: () => void;\n    touchcancel?: () => void;\n  } = {};\n\n  private ghostElement: HTMLElement | null;\n\n  private destroy$ = new Subject();\n\n  private timeLongPress: TimeLongPress = { timerBegin: 0, timerEnd: 0 };\n\n  private scroller: { destroy: () => void };\n\n  /**\n   * @hidden\n   */\n  constructor(\n    private element: ElementRef<HTMLElement>,\n    private renderer: Renderer2,\n    private draggableHelper: DraggableHelper,\n    private zone: NgZone,\n    private vcr: ViewContainerRef,\n    @Optional() private scrollContainer: DraggableScrollContainerDirective,\n    @Inject(DOCUMENT) private document: any\n  ) {}\n\n  ngOnInit(): void {\n    this.checkEventListeners();\n\n    const pointerDragged$: Observable<any> = this.pointerDown$.pipe(\n      filter(() => this.canDrag()),\n      mergeMap((pointerDownEvent: PointerEvent) => {\n        // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n        // stop mouse events propagating up the chain\n        if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {\n          pointerDownEvent.event.stopPropagation();\n        }\n\n        // hack to prevent text getting selected in safari while dragging\n        const globalDragStyle: HTMLStyleElement = this.renderer.createElement(\n          'style'\n        );\n        this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n        this.renderer.appendChild(\n          globalDragStyle,\n          this.renderer.createText(`\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        `)\n        );\n        requestAnimationFrame(() => {\n          this.document.head.appendChild(globalDragStyle);\n        });\n\n        const startScrollPosition = this.getScrollPosition();\n\n        const scrollContainerScroll$ = new Observable((observer) => {\n          const scrollContainer = this.scrollContainer\n            ? this.scrollContainer.elementRef.nativeElement\n            : 'window';\n          return this.renderer.listen(scrollContainer, 'scroll', (e) =>\n            observer.next(e)\n          );\n        }).pipe(\n          startWith(startScrollPosition),\n          map(() => this.getScrollPosition())\n        );\n\n        const currentDrag$ = new Subject<CurrentDragData>();\n        const cancelDrag$ = new ReplaySubject<void>();\n\n        this.zone.run(() => {\n          this.dragPointerDown.next({ x: 0, y: 0 });\n        });\n\n        const dragComplete$ = merge(\n          this.pointerUp$,\n          this.pointerDown$,\n          cancelDrag$,\n          this.destroy$\n        ).pipe(share());\n\n        const pointerMove = combineLatest([\n          this.pointerMove$,\n          scrollContainerScroll$,\n        ]).pipe(\n          map(([pointerMoveEvent, scroll]) => {\n            return {\n              currentDrag$,\n              transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n              transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n              clientX: pointerMoveEvent.clientX,\n              clientY: pointerMoveEvent.clientY,\n              scrollLeft: scroll.left,\n              scrollTop: scroll.top,\n              target: pointerMoveEvent.event.target,\n            };\n          }),\n          map((moveData) => {\n            if (this.dragSnapGrid.x) {\n              moveData.transformX =\n                Math.round(moveData.transformX / this.dragSnapGrid.x) *\n                this.dragSnapGrid.x;\n            }\n\n            if (this.dragSnapGrid.y) {\n              moveData.transformY =\n                Math.round(moveData.transformY / this.dragSnapGrid.y) *\n                this.dragSnapGrid.y;\n            }\n\n            return moveData;\n          }),\n          map((moveData) => {\n            if (!this.dragAxis.x) {\n              moveData.transformX = 0;\n            }\n\n            if (!this.dragAxis.y) {\n              moveData.transformY = 0;\n            }\n\n            return moveData;\n          }),\n          map((moveData) => {\n            const scrollX = moveData.scrollLeft - startScrollPosition.left;\n            const scrollY = moveData.scrollTop - startScrollPosition.top;\n            return {\n              ...moveData,\n              x: moveData.transformX + scrollX,\n              y: moveData.transformY + scrollY,\n            };\n          }),\n          filter(\n            ({ x, y, transformX, transformY }) =>\n              !this.validateDrag ||\n              this.validateDrag({\n                x,\n                y,\n                transform: { x: transformX, y: transformY },\n              })\n          ),\n          takeUntil(dragComplete$),\n          share()\n        );\n\n        const dragStarted$ = pointerMove.pipe(take(1), share());\n        const dragEnded$ = pointerMove.pipe(takeLast(1), share());\n\n        dragStarted$.subscribe(({ clientX, clientY, x, y }) => {\n          this.zone.run(() => {\n            this.dragStart.next({ cancelDrag$ });\n          });\n\n          this.scroller = autoScroll(\n            [\n              this.scrollContainer\n                ? this.scrollContainer.elementRef.nativeElement\n                : this.document.defaultView,\n            ],\n            {\n              ...this.autoScroll,\n              autoScroll() {\n                return true;\n              },\n            }\n          );\n          addClass(this.renderer, this.element, this.dragActiveClass);\n\n          if (this.ghostDragEnabled) {\n            const rect = this.element.nativeElement.getBoundingClientRect();\n            const clone = this.element.nativeElement.cloneNode(\n              true\n            ) as HTMLElement;\n            if (!this.showOriginalElementWhileDragging) {\n              this.renderer.setStyle(\n                this.element.nativeElement,\n                'visibility',\n                'hidden'\n              );\n            }\n\n            if (this.ghostElementAppendTo) {\n              this.ghostElementAppendTo.appendChild(clone);\n            } else {\n              this.element.nativeElement.parentNode!.insertBefore(\n                clone,\n                this.element.nativeElement.nextSibling\n              );\n            }\n\n            this.ghostElement = clone;\n\n            this.document.body.style.cursor = this.dragCursor;\n\n            this.setElementStyles(clone, {\n              position: 'fixed',\n              top: `${rect.top}px`,\n              left: `${rect.left}px`,\n              width: `${rect.width}px`,\n              height: `${rect.height}px`,\n              cursor: this.dragCursor,\n              margin: '0',\n              willChange: 'transform',\n              pointerEvents: 'none',\n            });\n\n            if (this.ghostElementTemplate) {\n              const viewRef = this.vcr.createEmbeddedView(\n                this.ghostElementTemplate\n              );\n              clone.innerHTML = '';\n              viewRef.rootNodes\n                .filter((node) => node instanceof Node)\n                .forEach((node) => {\n                  clone.appendChild(node);\n                });\n              dragEnded$.subscribe(() => {\n                this.vcr.remove(this.vcr.indexOf(viewRef));\n              });\n            }\n\n            this.zone.run(() => {\n              this.ghostElementCreated.emit({\n                clientX: clientX - x,\n                clientY: clientY - y,\n                element: clone,\n              });\n            });\n\n            dragEnded$.subscribe(() => {\n              clone.parentElement!.removeChild(clone);\n              this.ghostElement = null;\n              this.renderer.setStyle(\n                this.element.nativeElement,\n                'visibility',\n                ''\n              );\n            });\n          }\n\n          this.draggableHelper.currentDrag.next(currentDrag$);\n        });\n\n        dragEnded$\n          .pipe(\n            mergeMap((dragEndData) => {\n              const dragEndData$ = cancelDrag$.pipe(\n                count(),\n                take(1),\n                map((calledCount) => ({\n                  ...dragEndData,\n                  dragCancelled: calledCount > 0,\n                }))\n              );\n              cancelDrag$.complete();\n              return dragEndData$;\n            })\n          )\n          .subscribe(({ x, y, dragCancelled }) => {\n            this.scroller.destroy();\n            this.zone.run(() => {\n              this.dragEnd.next({ x, y, dragCancelled });\n            });\n            removeClass(this.renderer, this.element, this.dragActiveClass);\n            currentDrag$.complete();\n          });\n\n        merge(dragComplete$, dragEnded$)\n          .pipe(take(1))\n          .subscribe(() => {\n            requestAnimationFrame(() => {\n              this.document.head.removeChild(globalDragStyle);\n            });\n          });\n\n        return pointerMove;\n      }),\n      share()\n    );\n\n    merge(\n      pointerDragged$.pipe(\n        take(1),\n        map((value) => [, value])\n      ),\n      pointerDragged$.pipe(pairwise())\n    )\n      .pipe(\n        filter(([previous, next]) => {\n          if (!previous) {\n            return true;\n          }\n          return previous.x !== next.x || previous.y !== next.y;\n        }),\n        map(([previous, next]) => next)\n      )\n      .subscribe(\n        ({\n          x,\n          y,\n          currentDrag$,\n          clientX,\n          clientY,\n          transformX,\n          transformY,\n          target,\n        }) => {\n          this.zone.run(() => {\n            this.dragging.next({ x, y });\n          });\n          requestAnimationFrame(() => {\n            if (this.ghostElement) {\n              const transform = `translate3d(${transformX}px, ${transformY}px, 0px)`;\n              this.setElementStyles(this.ghostElement, {\n                transform,\n                '-webkit-transform': transform,\n                '-ms-transform': transform,\n                '-moz-transform': transform,\n                '-o-transform': transform,\n              });\n            }\n          });\n          currentDrag$.next({\n            clientX,\n            clientY,\n            dropData: this.dropData,\n            target,\n          });\n        }\n      );\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes.dragAxis) {\n      this.checkEventListeners();\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.unsubscribeEventListeners();\n    this.pointerDown$.complete();\n    this.pointerMove$.complete();\n    this.pointerUp$.complete();\n    this.destroy$.next();\n  }\n\n  private checkEventListeners(): void {\n    const canDrag: boolean = this.canDrag();\n    const hasEventListeners: boolean =\n      Object.keys(this.eventListenerSubscriptions).length > 0;\n\n    if (canDrag && !hasEventListeners) {\n      this.zone.runOutsideAngular(() => {\n        this.eventListenerSubscriptions.mousedown = this.renderer.listen(\n          this.element.nativeElement,\n          'mousedown',\n          (event: MouseEvent) => {\n            this.onMouseDown(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseup = this.renderer.listen(\n          'document',\n          'mouseup',\n          (event: MouseEvent) => {\n            this.onMouseUp(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchstart = this.renderer.listen(\n          this.element.nativeElement,\n          'touchstart',\n          (event: TouchEvent) => {\n            this.onTouchStart(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchend = this.renderer.listen(\n          'document',\n          'touchend',\n          (event: TouchEvent) => {\n            this.onTouchEnd(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchcancel = this.renderer.listen(\n          'document',\n          'touchcancel',\n          (event: TouchEvent) => {\n            this.onTouchEnd(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseenter = this.renderer.listen(\n          this.element.nativeElement,\n          'mouseenter',\n          () => {\n            this.onMouseEnter();\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseleave = this.renderer.listen(\n          this.element.nativeElement,\n          'mouseleave',\n          () => {\n            this.onMouseLeave();\n          }\n        );\n      });\n    } else if (!canDrag && hasEventListeners) {\n      this.unsubscribeEventListeners();\n    }\n  }\n\n  private onMouseDown(event: MouseEvent): void {\n    if (event.button === 0) {\n      if (!this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove = this.renderer.listen(\n          'document',\n          'mousemove',\n          (mouseMoveEvent: MouseEvent) => {\n            this.pointerMove$.next({\n              event: mouseMoveEvent,\n              clientX: mouseMoveEvent.clientX,\n              clientY: mouseMoveEvent.clientY,\n            });\n          }\n        );\n      }\n      this.pointerDown$.next({\n        event,\n        clientX: event.clientX,\n        clientY: event.clientY,\n      });\n    }\n  }\n\n  private onMouseUp(event: MouseEvent): void {\n    if (event.button === 0) {\n      if (this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove();\n        delete this.eventListenerSubscriptions.mousemove;\n      }\n      this.pointerUp$.next({\n        event,\n        clientX: event.clientX,\n        clientY: event.clientY,\n      });\n    }\n  }\n\n  private onTouchStart(event: TouchEvent): void {\n    let startScrollPosition: any;\n    let isDragActivated: boolean;\n    let hasContainerScrollbar: boolean;\n    if (\n      (this.scrollContainer && this.scrollContainer.activeLongPressDrag) ||\n      this.touchStartLongPress\n    ) {\n      this.timeLongPress.timerBegin = Date.now();\n      isDragActivated = false;\n      hasContainerScrollbar = this.hasScrollbar();\n      startScrollPosition = this.getScrollPosition();\n    }\n\n    if (!this.eventListenerSubscriptions.touchmove) {\n      const contextMenuListener = fromEvent<Event>(\n        this.document,\n        'contextmenu'\n      ).subscribe((e) => {\n        e.preventDefault();\n      });\n\n      const touchMoveListener = fromEvent<TouchEvent>(\n        this.document,\n        'touchmove',\n        {\n          passive: false,\n        }\n      ).subscribe((touchMoveEvent) => {\n        if (\n          ((this.scrollContainer && this.scrollContainer.activeLongPressDrag) ||\n            this.touchStartLongPress) &&\n          !isDragActivated &&\n          hasContainerScrollbar\n        ) {\n          isDragActivated = this.shouldBeginDrag(\n            event,\n            touchMoveEvent,\n            startScrollPosition\n          );\n        }\n        if (\n          ((!this.scrollContainer ||\n            !this.scrollContainer.activeLongPressDrag) &&\n            !this.touchStartLongPress) ||\n          !hasContainerScrollbar ||\n          isDragActivated\n        ) {\n          touchMoveEvent.preventDefault();\n          this.pointerMove$.next({\n            event: touchMoveEvent,\n            clientX: touchMoveEvent.targetTouches[0].clientX,\n            clientY: touchMoveEvent.targetTouches[0].clientY,\n          });\n        }\n      });\n\n      this.eventListenerSubscriptions.touchmove = () => {\n        contextMenuListener.unsubscribe();\n        touchMoveListener.unsubscribe();\n      };\n    }\n    this.pointerDown$.next({\n      event,\n      clientX: event.touches[0].clientX,\n      clientY: event.touches[0].clientY,\n    });\n  }\n\n  private onTouchEnd(event: TouchEvent): void {\n    if (this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove();\n      delete this.eventListenerSubscriptions.touchmove;\n\n      if (\n        (this.scrollContainer && this.scrollContainer.activeLongPressDrag) ||\n        this.touchStartLongPress\n      ) {\n        this.enableScroll();\n      }\n    }\n    this.pointerUp$.next({\n      event,\n      clientX: event.changedTouches[0].clientX,\n      clientY: event.changedTouches[0].clientY,\n    });\n  }\n\n  private onMouseEnter(): void {\n    this.setCursor(this.dragCursor);\n  }\n\n  private onMouseLeave(): void {\n    this.setCursor('');\n  }\n\n  private canDrag(): boolean {\n    return this.dragAxis.x || this.dragAxis.y;\n  }\n\n  private setCursor(value: string): void {\n    if (!this.eventListenerSubscriptions.mousemove) {\n      this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n    }\n  }\n\n  private unsubscribeEventListeners(): void {\n    Object.keys(this.eventListenerSubscriptions).forEach((type) => {\n      (this as any).eventListenerSubscriptions[type]();\n      delete (this as any).eventListenerSubscriptions[type];\n    });\n  }\n\n  private setElementStyles(\n    element: HTMLElement,\n    styles: { [key: string]: string }\n  ) {\n    Object.keys(styles).forEach((key) => {\n      this.renderer.setStyle(element, key, styles[key]);\n    });\n  }\n\n  private getScrollElement() {\n    if (this.scrollContainer) {\n      return this.scrollContainer.elementRef.nativeElement;\n    } else {\n      return this.document.body;\n    }\n  }\n\n  private getScrollPosition() {\n    if (this.scrollContainer) {\n      return {\n        top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n        left: this.scrollContainer.elementRef.nativeElement.scrollLeft,\n      };\n    } else {\n      return {\n        top: window.pageYOffset || this.document.documentElement.scrollTop,\n        left: window.pageXOffset || this.document.documentElement.scrollLeft,\n      };\n    }\n  }\n\n  private shouldBeginDrag(\n    event: TouchEvent,\n    touchMoveEvent: TouchEvent,\n    startScrollPosition: { top: number; left: number }\n  ): boolean {\n    const moveScrollPosition = this.getScrollPosition();\n    const deltaScroll = {\n      top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n      left: Math.abs(moveScrollPosition.left - startScrollPosition.left),\n    };\n    const deltaX =\n      Math.abs(\n        touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX\n      ) - deltaScroll.left;\n    const deltaY =\n      Math.abs(\n        touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY\n      ) - deltaScroll.top;\n    const deltaTotal = deltaX + deltaY;\n    const longPressConfig = this.touchStartLongPress\n      ? this.touchStartLongPress\n      : /* istanbul ignore next */\n        {\n          delta: this.scrollContainer.longPressConfig.delta,\n          delay: this.scrollContainer.longPressConfig.duration,\n        };\n    if (\n      deltaTotal > longPressConfig.delta ||\n      deltaScroll.top > 0 ||\n      deltaScroll.left > 0\n    ) {\n      this.timeLongPress.timerBegin = Date.now();\n    }\n    this.timeLongPress.timerEnd = Date.now();\n    const duration =\n      this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n    if (duration >= longPressConfig.delay) {\n      this.disableScroll();\n      return true;\n    }\n    return false;\n  }\n\n  private enableScroll() {\n    if (this.scrollContainer) {\n      this.renderer.setStyle(\n        this.scrollContainer.elementRef.nativeElement,\n        'overflow',\n        ''\n      );\n    }\n    this.renderer.setStyle(this.document.body, 'overflow', '');\n  }\n\n  private disableScroll() {\n    /* istanbul ignore next */\n    if (this.scrollContainer) {\n      this.renderer.setStyle(\n        this.scrollContainer.elementRef.nativeElement,\n        'overflow',\n        'hidden'\n      );\n    }\n    this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n  }\n\n  private hasScrollbar(): boolean {\n    const scrollContainer = this.getScrollElement();\n    const containerHasHorizontalScroll =\n      scrollContainer.scrollWidth > scrollContainer.clientWidth;\n    const containerHasVerticalScroll =\n      scrollContainer.scrollHeight > scrollContainer.clientHeight;\n    return containerHasHorizontalScroll || containerHasVerticalScroll;\n  }\n}\n","import {\n  Directive,\n  OnInit,\n  ElementRef,\n  OnDestroy,\n  Output,\n  EventEmitter,\n  NgZone,\n  Input,\n  Renderer2,\n  Optional,\n} from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { distinctUntilChanged, pairwise, filter, map } from 'rxjs/operators';\nimport { DraggableHelper } from './draggable-helper.provider';\nimport { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';\nimport { addClass, removeClass } from './util';\n\nfunction isCoordinateWithinRectangle(\n  clientX: number,\n  clientY: number,\n  rect: ClientRect\n): boolean {\n  return (\n    clientX >= rect.left &&\n    clientX <= rect.right &&\n    clientY >= rect.top &&\n    clientY <= rect.bottom\n  );\n}\n\nexport interface DropEvent<T = any> {\n  dropData: T;\n}\n\nexport interface ValidateDropParams {\n  /**\n   * ClientX value of the mouse location where the drop occurred\n   */\n  clientX: number;\n  /**\n   * ClientY value of the mouse location where the drop occurred\n   */\n  clientY: number;\n  /**\n   * The target of the event where the drop occurred\n   */\n  target: EventTarget;\n}\n\nexport type ValidateDrop = (params: ValidateDropParams) => boolean;\n\n@Directive({\n  selector: '[mwlDroppable]',\n})\nexport class DroppableDirective implements OnInit, OnDestroy {\n  /**\n   * Added to the element when an element is dragged over it\n   */\n  @Input() dragOverClass: string;\n\n  /**\n   * Added to the element any time a draggable element is being dragged\n   */\n  @Input() dragActiveClass: string;\n\n  /**\n   * Allow custom behaviour to control when the element is dropped\n   */\n  @Input() validateDrop: ValidateDrop;\n\n  /**\n   * Called when a draggable element starts overlapping the element\n   */\n  @Output() dragEnter = new EventEmitter<DropEvent>();\n\n  /**\n   * Called when a draggable element stops overlapping the element\n   */\n  @Output() dragLeave = new EventEmitter<DropEvent>();\n\n  /**\n   * Called when a draggable element is moved over the element\n   */\n  @Output() dragOver = new EventEmitter<DropEvent>();\n\n  /**\n   * Called when a draggable element is dropped on this element\n   */\n  @Output() drop = new EventEmitter<DropEvent>(); // tslint:disable-line no-output-named-after-standard-event\n\n  currentDragSubscription: Subscription;\n\n  constructor(\n    private element: ElementRef<HTMLElement>,\n    private draggableHelper: DraggableHelper,\n    private zone: NgZone,\n    private renderer: Renderer2,\n    @Optional() private scrollContainer: DraggableScrollContainerDirective\n  ) {}\n\n  ngOnInit() {\n    this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(\n      (drag$) => {\n        addClass(this.renderer, this.element, this.dragActiveClass);\n        const droppableElement: {\n          rect?: ClientRect;\n          updateCache: boolean;\n          scrollContainerRect?: ClientRect;\n        } = {\n          updateCache: true,\n        };\n\n        const deregisterScrollListener = this.renderer.listen(\n          this.scrollContainer\n            ? this.scrollContainer.elementRef.nativeElement\n            : 'window',\n          'scroll',\n          () => {\n            droppableElement.updateCache = true;\n          }\n        );\n\n        let currentDragDropData: any;\n        const overlaps$ = drag$.pipe(\n          map(({ clientX, clientY, dropData, target }) => {\n            currentDragDropData = dropData;\n            if (droppableElement.updateCache) {\n              droppableElement.rect = this.element.nativeElement.getBoundingClientRect();\n              if (this.scrollContainer) {\n                droppableElement.scrollContainerRect = this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n              }\n              droppableElement.updateCache = false;\n            }\n            const isWithinElement = isCoordinateWithinRectangle(\n              clientX,\n              clientY,\n              droppableElement.rect as ClientRect\n            );\n\n            const isDropAllowed =\n              !this.validateDrop ||\n              this.validateDrop({ clientX, clientY, target });\n\n            if (droppableElement.scrollContainerRect) {\n              return (\n                isWithinElement &&\n                isDropAllowed &&\n                isCoordinateWithinRectangle(\n                  clientX,\n                  clientY,\n                  droppableElement.scrollContainerRect as ClientRect\n                )\n              );\n            } else {\n              return isWithinElement && isDropAllowed;\n            }\n          })\n        );\n\n        const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n\n        let dragOverActive: boolean; // TODO - see if there's a way of doing this via rxjs\n\n        overlapsChanged$\n          .pipe(filter((overlapsNow) => overlapsNow))\n          .subscribe(() => {\n            dragOverActive = true;\n            addClass(this.renderer, this.element, this.dragOverClass);\n            this.zone.run(() => {\n              this.dragEnter.next({\n                dropData: currentDragDropData,\n              });\n            });\n          });\n\n        overlaps$.pipe(filter((overlapsNow) => overlapsNow)).subscribe(() => {\n          this.zone.run(() => {\n            this.dragOver.next({\n              dropData: currentDragDropData,\n            });\n          });\n        });\n\n        overlapsChanged$\n          .pipe(\n            pairwise(),\n            filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow)\n          )\n          .subscribe(() => {\n            dragOverActive = false;\n            removeClass(this.renderer, this.element, this.dragOverClass);\n            this.zone.run(() => {\n              this.dragLeave.next({\n                dropData: currentDragDropData,\n              });\n            });\n          });\n\n        drag$.subscribe({\n          complete: () => {\n            deregisterScrollListener();\n            removeClass(this.renderer, this.element, this.dragActiveClass);\n            if (dragOverActive) {\n              removeClass(this.renderer, this.element, this.dragOverClass);\n              this.zone.run(() => {\n                this.drop.next({\n                  dropData: currentDragDropData,\n                });\n              });\n            }\n          },\n        });\n      }\n    );\n  }\n\n  ngOnDestroy() {\n    if (this.currentDragSubscription) {\n      this.currentDragSubscription.unsubscribe();\n    }\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { DraggableDirective } from './draggable.directive';\nimport { DroppableDirective } from './droppable.directive';\nimport { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';\n\n@NgModule({\n  declarations: [\n    DraggableDirective,\n    DroppableDirective,\n    DraggableScrollContainerDirective,\n  ],\n  exports: [\n    DraggableDirective,\n    DroppableDirective,\n    DraggableScrollContainerDirective,\n  ],\n})\nexport class DragAndDropModule {}\n"]},"metadata":{},"sourceType":"module"}