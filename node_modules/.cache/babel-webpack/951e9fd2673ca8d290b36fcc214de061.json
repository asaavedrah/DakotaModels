{"ast":null,"code":"import _classCallCheck from \"C:/Users/DTI_UCH/Desktop/Angular10/admin/template/template_angularjs10/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/DTI_UCH/Desktop/Angular10/admin/template/template_angularjs10/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _toConsumableArray from \"C:/Users/DTI_UCH/Desktop/Angular10/admin/template/template_angularjs10/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _toArray from \"C:/Users/DTI_UCH/Desktop/Angular10/admin/template/template_angularjs10/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport { trigger, state, style, transition, animate, keyframes } from '@angular/animations';\nimport { Component, Input, ViewChild, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/* eslint-disable no-restricted-properties */\n\n/** normalize\n * This lets us translate a value from one scale to another.\n *\n * @param value - Our initial value to translate\n * @param min - the current minimum value possible\n * @param max - the current maximum value possible\n * @param scaleMin - the min value of the scale we're translating to\n * @param scaleMax - the max value of the scale we're translating to\n * @returns the value on its new scale\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nvar _c0 = [\"pathEl\"];\n\nfunction TrendComponent__svg_svg_0__svg_defs_1__svg_stop_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"stop\");\n  }\n\n  if (rf & 2) {\n    var g_r4 = ctx.$implicit;\n    ɵngcc0.ɵɵattribute(\"key\", g_r4.idx)(\"offset\", g_r4.offset)(\"stop-color\", g_r4.stopColor);\n  }\n}\n\nfunction TrendComponent__svg_svg_0__svg_defs_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"defs\");\n    ɵngcc0.ɵɵelementStart(1, \"linearGradient\", 3);\n    ɵngcc0.ɵɵtemplate(2, TrendComponent__svg_svg_0__svg_defs_1__svg_stop_2_Template, 1, 3, \"stop\", 4);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"id\", ctx_r1.gradientId);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r1.gradientTrimmed);\n  }\n}\n\nvar _c1 = function _c1(a0, a1, a2) {\n  return {\n    autoDrawDuration: a0,\n    autoDrawEasing: a1,\n    lineLength: a2\n  };\n};\n\nvar _c2 = function _c2(a0, a1) {\n  return {\n    value: a0,\n    params: a1\n  };\n};\n\nfunction TrendComponent__svg_svg_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"svg\");\n    ɵngcc0.ɵɵtemplate(1, TrendComponent__svg_svg_0__svg_defs_1_Template, 3, 2, \"defs\", 0);\n    ɵngcc0.ɵɵelement(2, \"path\", 1, 2);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵattribute(\"width\", ctx_r0.svgWidth)(\"height\", ctx_r0.svgHeight)(\"stroke\", ctx_r0.stroke)(\"stroke-width\", ctx_r0.strokeWidth)(\"stroke-linecap\", ctx_r0.strokeLinecap)(\"viewBox\", ctx_r0.viewBox)(\"preserveAspectRatio\", ctx_r0.preserveAspectRatio);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.gradient && ctx_r0.gradient.length);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"@pathAnimaiton\", ɵngcc0.ɵɵpureFunction2(15, _c2, ctx_r0.animationState, ɵngcc0.ɵɵpureFunction3(11, _c1, ctx_r0.autoDrawDuration, ctx_r0.autoDrawEasing, ctx_r0.lineLength)));\n    ɵngcc0.ɵɵattribute(\"stroke\", ctx_r0.pathStroke)(\"d\", ctx_r0.d);\n  }\n}\n\nfunction normalize(value, min, max) {\n  var scaleMin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var scaleMax = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n\n  // If the `min` and `max` are the same value, it means our dataset is flat.\n  // For now, let's assume that flat data should be aligned to the bottom.\n  if (min === max) {\n    return scaleMin;\n  }\n\n  return scaleMin + (value - min) * (scaleMax - scaleMin) / (max - min);\n}\n/** moveTo\n * the coordinate that lies at a midpoint between 2 lines, based on the radius\n *\n * @param to - Our initial point\n * @param to.x - The x value of our initial point\n * @param to.y - The y value of our initial point\n * @param from - Our final point\n * @param from.x - The x value of our final point\n * @param from.y - The y value of our final point\n * @param radius - The distance away from the final point\n * @returns an object holding the x/y coordinates of the midpoint.\n */\n\n\nfunction moveTo(to, from, radius) {\n  var length = Math.sqrt((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y));\n  var unitVector = {\n    x: (to.x - from.x) / length,\n    y: (to.y - from.y) / length\n  };\n  return {\n    x: from.x + unitVector.x * radius,\n    y: from.y + unitVector.y * radius\n  };\n}\n/** getDistanceBetween\n * Simple formula derived from pythagoras to calculate the distance between\n * 2 points on a plane.\n *\n * @param p1 - Our initial point\n * @param p1.x - The x value of our initial point\n * @param p1.y - The y value of our initial point\n * @param p2 - Our final point\n * @param p2.x - The x value of our final point\n * @param p2.y - The y value of our final point\n * @returns the distance between the points.\n */\n\n\nvar getDistanceBetween = function getDistanceBetween(p1, p2) {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n};\n/** checkForCollinearPoints\n * Figure out if the midpoint fits perfectly on a line between the two others.\n *\n * @param p1 - Our initial point\n * @param p1.x - The x value of our initial point\n * @param p1.y - The y value of our initial point\n * @param p2 - Our mid-point\n * @param p2.x - The x value of our mid-point\n * @param p2.y - The y value of our mid-point\n * @param p3 - Our final point\n * @param p3.x - The x value of our final point\n * @param p3.y - The y value of our final point\n * @returns whether or not p2 sits on the line between p1 and p3.\n */\n\n\nvar checkForCollinearPoints = function checkForCollinearPoints(p1, p2, p3) {\n  return (p1.y - p2.y) * (p1.x - p3.x) === (p1.y - p3.y) * (p1.x - p2.x);\n};\n\nvar buildLinearPath = function buildLinearPath(data) {\n  return data.reduce(function (path, point, index) {\n    // The very first instruction needs to be a \"move\".\n    // The rest will be a \"line\".\n    var isFirstInstruction = index === 0;\n    var instruction = isFirstInstruction ? 'M' : 'L';\n    return \"\".concat(path).concat(instruction, \" \").concat(point.x, \",\").concat(point.y, \"\\n\");\n  }, '');\n};\n\nfunction buildSmoothPath(data, radius) {\n  var _data = _toArray(data),\n      firstPoint = _data[0],\n      otherPoints = _data.slice(1);\n\n  return otherPoints.reduce(function (path, point, index) {\n    var next = otherPoints[index + 1];\n    var prev = otherPoints[index - 1] || firstPoint;\n    var isCollinear = next && checkForCollinearPoints(prev, point, next);\n\n    if (!next || isCollinear) {\n      // The very last line in the sequence can just be a regular line.\n      return \"\".concat(path, \"\\nL \").concat(point.x, \",\").concat(point.y);\n    }\n\n    var distanceFromPrev = getDistanceBetween(prev, point);\n    var distanceFromNext = getDistanceBetween(next, point);\n    var threshold = Math.min(distanceFromPrev, distanceFromNext);\n    var isTooCloseForRadius = threshold / 2 < radius;\n    var radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;\n    var before = moveTo(prev, point, radiusForPoint);\n    var after = moveTo(next, point, radiusForPoint);\n    return [path, \"L \".concat(before.x, \",\").concat(before.y), \"S \".concat(point.x, \",\").concat(point.y, \" \").concat(after.x, \",\").concat(after.y)].join('\\n');\n  }, \"M \".concat(firstPoint.x, \",\").concat(firstPoint.y));\n}\n\nvar generateId = function generateId() {\n  return Math.round(Math.random() * Math.pow(10, 16));\n};\n\nfunction normalizeDataset(data, minX, maxX, minY, maxY) {\n  // For the X axis, we want to normalize it based on its index in the array.\n  // For the Y axis, we want to normalize it based on the element's value.\n  //\n  // X axis is easy: just evenly-space each item in the array.\n  // For the Y axis, we first need to find the min and max of our array,\n  // and then normalize those values between 0 and 1.\n  var boundariesX = {\n    min: 0,\n    max: data.length - 1\n  };\n  var boundariesY = {\n    min: Math.min.apply(Math, _toConsumableArray(data)),\n    max: Math.max.apply(Math, _toConsumableArray(data))\n  };\n  var normalizedData = data.map(function (point, index) {\n    return {\n      x: normalize(index, boundariesX.min, boundariesX.max, minX, maxX),\n      y: normalize(point, boundariesY.min, boundariesY.max, minY, maxY)\n    };\n  }); // According to the SVG spec, paths with a height/width of `0` can't have\n  // linear gradients applied. This means that our lines are invisible when\n  // the dataset is flat (eg. [0, 0, 0, 0]).\n  //\n  // The hacky solution is to apply a very slight offset to the first point of\n  // the dataset. As ugly as it is, it's the best solution we can find (there\n  // are ways within the SVG spec of changing it, but not without causing\n  // breaking changes).\n\n  if (boundariesY.min === boundariesY.max) {\n    normalizedData[0].y += 0.0001;\n  }\n\n  return normalizedData;\n}\n\nvar TrendComponent = /*#__PURE__*/function () {\n  function TrendComponent() {\n    _classCallCheck(this, TrendComponent);\n\n    this.autoDraw = false;\n    this.autoDrawDuration = 2000;\n    this.autoDrawEasing = 'ease';\n    this.padding = 8;\n    this.radius = 10;\n    this.stroke = 'black';\n    this.strokeLinecap = '';\n    this.strokeWidth = 1;\n    this.gradient = [];\n    this.svgHeight = '25%';\n    this.svgWidth = '100%';\n    this.animationState = '';\n    this.id = generateId();\n    this.gradientId = \"ngx-trend-vertical-gradient-\".concat(this.id);\n  }\n\n  _createClass(TrendComponent, [{\n    key: \"ngOnChanges\",\n    value: function ngOnChanges() {\n      var _this = this;\n\n      // We need at least 2 points to draw a graph.\n      if (!this.data || this.data.length < 2) {\n        return;\n      } // `data` can either be an array of numbers:\n      // [1, 2, 3]\n      // or, an array of objects containing a value:\n      // [{ value: 1 }, { value: 2 }, { value: 3 }]\n      //\n      // For now, we're just going to convert the second form to the first.\n      // Later on, if/when we support tooltips, we may adjust.\n\n\n      var plainValues = this.data.map(function (point) {\n        if (typeof point === 'number') {\n          return point;\n        }\n\n        return point.value;\n      }); // Our viewbox needs to be in absolute units, so we'll default to 300x75\n      // Our SVG can be a %, though; this is what makes it scalable.\n      // By defaulting to percentages, the SVG will grow to fill its parent\n      // container, preserving a 1/4 aspect ratio.\n\n      var viewBoxWidth = this.width || 300;\n      var viewBoxHeight = this.height || 75;\n      this.svgWidth = this.width || '100%';\n      this.svgHeight = this.height || '25%';\n      this.viewBox = \"0 0 \".concat(viewBoxWidth, \" \").concat(viewBoxHeight);\n      var root = location.href.split(location.hash || '#')[0];\n      this.pathStroke = this.gradient && this.gradient.length ? \"url('\".concat(root, \"#\").concat(this.gradientId, \"')\") : undefined;\n      this.gradientTrimmed = this.gradient.slice().reverse().map(function (val, idx) {\n        return {\n          idx: idx,\n          stopColor: val,\n          offset: normalize(idx, 0, _this.gradient.length - 1 || 1)\n        };\n      });\n      var normalizedValues = normalizeDataset(plainValues, this.padding, viewBoxWidth - this.padding, // NOTE: Because SVGs are indexed from the top left, but most data is\n      // indexed from the bottom left, we're inverting the Y min/max.\n      viewBoxHeight - this.padding, this.padding);\n\n      if (this.autoDraw && this.animationState !== 'active') {\n        this.animationState = 'inactive';\n        setTimeout(function () {\n          _this.lineLength = _this.pathEl.nativeElement.getTotalLength();\n          _this.animationState = 'active';\n        });\n      }\n\n      this.d = this.smooth ? buildSmoothPath(normalizedValues, this.radius) : buildLinearPath(normalizedValues);\n    }\n  }]);\n\n  return TrendComponent;\n}();\n\nTrendComponent.ɵfac = function TrendComponent_Factory(t) {\n  return new (t || TrendComponent)();\n};\n\nTrendComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n  type: TrendComponent,\n  selectors: [[\"ngx-trend\"]],\n  viewQuery: function TrendComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(_c0, true);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pathEl = _t.first);\n    }\n  },\n  inputs: {\n    autoDraw: \"autoDraw\",\n    autoDrawDuration: \"autoDrawDuration\",\n    autoDrawEasing: \"autoDrawEasing\",\n    padding: \"padding\",\n    radius: \"radius\",\n    stroke: \"stroke\",\n    strokeLinecap: \"strokeLinecap\",\n    strokeWidth: \"strokeWidth\",\n    gradient: \"gradient\",\n    svgHeight: \"svgHeight\",\n    svgWidth: \"svgWidth\",\n    data: \"data\",\n    smooth: \"smooth\",\n    width: \"width\",\n    height: \"height\",\n    preserveAspectRatio: \"preserveAspectRatio\"\n  },\n  features: [ɵngcc0.ɵɵNgOnChangesFeature],\n  decls: 1,\n  vars: 1,\n  consts: [[4, \"ngIf\"], [\"fill\", \"none\"], [\"pathEl\", \"\"], [\"x1\", \"0%\", \"y1\", \"0%\", \"x2\", \"0%\", \"y2\", \"100%\"], [4, \"ngFor\", \"ngForOf\"]],\n  template: function TrendComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵtemplate(0, TrendComponent__svg_svg_0_Template, 4, 18, \"svg\", 0);\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.data && ctx.data.length >= 2);\n    }\n  },\n  directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf],\n  encapsulation: 2,\n  data: {\n    animation: [trigger('pathAnimaiton', [state('inactive', style({\n      display: 'none'\n    })), transition('* => active', [style({\n      display: 'initial'\n    }), // We do the animation using the dash array/offset trick\n    // https://css-tricks.com/svg-line-animation-works/\n    animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', keyframes([style({\n      'stroke-dasharray': '{{ lineLength }}px',\n      'stroke-dashoffset': '{{ lineLength }}px'\n    }), style({\n      'stroke-dasharray': '{{ lineLength }}px',\n      'stroke-dashoffset': 0\n    })])), // One unfortunate side-effect of the auto-draw is that the line is\n    // actually 1 big dash, the same length as the line itself. If the\n    // line length changes (eg. radius change, new data), that dash won't\n    // be the same length anymore. We can fix that by removing those\n    // properties once the auto-draw is completed.\n    style({\n      'stroke-dashoffset': '',\n      'stroke-dasharray': ''\n    })])])]\n  }\n});\n\nTrendComponent.ctorParameters = function () {\n  return [];\n};\n\nTrendComponent.propDecorators = {\n  data: [{\n    type: Input\n  }],\n  smooth: [{\n    type: Input\n  }],\n  autoDraw: [{\n    type: Input\n  }],\n  autoDrawDuration: [{\n    type: Input\n  }],\n  autoDrawEasing: [{\n    type: Input\n  }],\n  width: [{\n    type: Input\n  }],\n  height: [{\n    type: Input\n  }],\n  padding: [{\n    type: Input\n  }],\n  radius: [{\n    type: Input\n  }],\n  stroke: [{\n    type: Input\n  }],\n  strokeLinecap: [{\n    type: Input\n  }],\n  strokeWidth: [{\n    type: Input\n  }],\n  gradient: [{\n    type: Input\n  }],\n  preserveAspectRatio: [{\n    type: Input\n  }],\n  svgHeight: [{\n    type: Input\n  }],\n  svgWidth: [{\n    type: Input\n  }],\n  pathEl: [{\n    type: ViewChild,\n    args: ['pathEl']\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(TrendComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-trend',\n      template: \"\\n    <svg\\n      *ngIf=\\\"data && data.length >= 2\\\"\\n      [attr.width]=\\\"svgWidth\\\"\\n      [attr.height]=\\\"svgHeight\\\"\\n      [attr.stroke]=\\\"stroke\\\"\\n      [attr.stroke-width]=\\\"strokeWidth\\\"\\n      [attr.stroke-linecap]=\\\"strokeLinecap\\\"\\n      [attr.viewBox]=\\\"viewBox\\\"\\n      [attr.preserveAspectRatio]=\\\"preserveAspectRatio\\\"\\n    >\\n      <defs *ngIf=\\\"gradient && gradient.length\\\">\\n        <linearGradient [attr.id]=\\\"gradientId\\\" x1=\\\"0%\\\" y1=\\\"0%\\\" x2=\\\"0%\\\" y2=\\\"100%\\\">\\n          <stop\\n            *ngFor=\\\"let g of gradientTrimmed\\\"\\n            [attr.key]=\\\"g.idx\\\"\\n            [attr.offset]=\\\"g.offset\\\"\\n            [attr.stop-color]=\\\"g.stopColor\\\"\\n          />\\n        </linearGradient>\\n      </defs>\\n      <path\\n        fill=\\\"none\\\"\\n        #pathEl\\n        [attr.stroke]=\\\"pathStroke\\\"\\n        [attr.d]=\\\"d\\\"\\n        [@pathAnimaiton]=\\\"{\\n          value: animationState,\\n          params: {\\n            autoDrawDuration: autoDrawDuration,\\n            autoDrawEasing: autoDrawEasing,\\n            lineLength: lineLength\\n          }\\n        }\\\"\\n      />\\n    </svg>\\n  \",\n      animations: [trigger('pathAnimaiton', [state('inactive', style({\n        display: 'none'\n      })), transition('* => active', [style({\n        display: 'initial'\n      }), // We do the animation using the dash array/offset trick\n      // https://css-tricks.com/svg-line-animation-works/\n      animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', keyframes([style({\n        'stroke-dasharray': '{{ lineLength }}px',\n        'stroke-dashoffset': '{{ lineLength }}px'\n      }), style({\n        'stroke-dasharray': '{{ lineLength }}px',\n        'stroke-dashoffset': 0\n      })])), // One unfortunate side-effect of the auto-draw is that the line is\n      // actually 1 big dash, the same length as the line itself. If the\n      // line length changes (eg. radius change, new data), that dash won't\n      // be the same length anymore. We can fix that by removing those\n      // properties once the auto-draw is completed.\n      style({\n        'stroke-dashoffset': '',\n        'stroke-dasharray': ''\n      })])])]\n    }]\n  }], function () {\n    return [];\n  }, {\n    autoDraw: [{\n      type: Input\n    }],\n    autoDrawDuration: [{\n      type: Input\n    }],\n    autoDrawEasing: [{\n      type: Input\n    }],\n    padding: [{\n      type: Input\n    }],\n    radius: [{\n      type: Input\n    }],\n    stroke: [{\n      type: Input\n    }],\n    strokeLinecap: [{\n      type: Input\n    }],\n    strokeWidth: [{\n      type: Input\n    }],\n    gradient: [{\n      type: Input\n    }],\n    svgHeight: [{\n      type: Input\n    }],\n    svgWidth: [{\n      type: Input\n    }],\n    data: [{\n      type: Input\n    }],\n    smooth: [{\n      type: Input\n    }],\n    width: [{\n      type: Input\n    }],\n    height: [{\n      type: Input\n    }],\n    preserveAspectRatio: [{\n      type: Input\n    }],\n    pathEl: [{\n      type: ViewChild,\n      args: ['pathEl']\n    }]\n  });\n})();\n\nvar TrendModule = function TrendModule() {\n  _classCallCheck(this, TrendModule);\n};\n\nTrendModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: TrendModule\n});\nTrendModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function TrendModule_Factory(t) {\n    return new (t || TrendModule)();\n  },\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TrendModule, {\n    declarations: function declarations() {\n      return [TrendComponent];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [TrendComponent];\n    }\n  });\n})();\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(TrendModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      exports: [TrendComponent],\n      declarations: [TrendComponent]\n    }]\n  }], null, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { TrendComponent, TrendModule };","map":{"version":3,"sources":["../src/lib/helpers/math.helpers.ts","../src/lib/helpers/DOM.helpers.ts","../src/lib/helpers/misc.helpers.ts","../src/lib/trend/trend.helpers.ts","../src/lib/trend/trend.component.ts","../src/lib/trend/trend.module.ts","../../src/lib/ngx-trend.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable no-restricted-properties */\n\n/** normalize\n * This lets us translate a value from one scale to another.\n *\n * @param value - Our initial value to translate\n * @param min - the current minimum value possible\n * @param max - the current maximum value possible\n * @param scaleMin - the min value of the scale we're translating to\n * @param scaleMax - the max value of the scale we're translating to\n * @returns the value on its new scale\n */\nexport function normalize(\n  value: number,\n  min: number,\n  max: number,\n  scaleMin = 0,\n  scaleMax = 1,\n): number {\n  // If the `min` and `max` are the same value, it means our dataset is flat.\n  // For now, let's assume that flat data should be aligned to the bottom.\n  if (min === max) {\n    return scaleMin;\n  }\n\n  return scaleMin + (value - min) * (scaleMax - scaleMin) / (max - min);\n}\n\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n/** moveTo\n * the coordinate that lies at a midpoint between 2 lines, based on the radius\n *\n * @param to - Our initial point\n * @param to.x - The x value of our initial point\n * @param to.y - The y value of our initial point\n * @param from - Our final point\n * @param from.x - The x value of our final point\n * @param from.y - The y value of our final point\n * @param radius - The distance away from the final point\n * @returns an object holding the x/y coordinates of the midpoint.\n */\nexport function moveTo(to: Point, from: Point, radius: number): Point {\n  const length = Math.sqrt((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y));\n  const unitVector = { x: (to.x - from.x) / length, y: (to.y - from.y) / length };\n\n  return {\n    x: from.x + unitVector.x * radius,\n    y: from.y + unitVector.y * radius,\n  };\n}\n\n/** getDistanceBetween\n * Simple formula derived from pythagoras to calculate the distance between\n * 2 points on a plane.\n *\n * @param p1 - Our initial point\n * @param p1.x - The x value of our initial point\n * @param p1.y - The y value of our initial point\n * @param p2 - Our final point\n * @param p2.x - The x value of our final point\n * @param p2.y - The y value of our final point\n * @returns the distance between the points.\n */\nexport const getDistanceBetween = (p1: Point, p2: Point): number =>\n  Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n\n/** checkForCollinearPoints\n * Figure out if the midpoint fits perfectly on a line between the two others.\n *\n * @param p1 - Our initial point\n * @param p1.x - The x value of our initial point\n * @param p1.y - The y value of our initial point\n * @param p2 - Our mid-point\n * @param p2.x - The x value of our mid-point\n * @param p2.y - The y value of our mid-point\n * @param p3 - Our final point\n * @param p3.x - The x value of our final point\n * @param p3.y - The y value of our final point\n * @returns whether or not p2 sits on the line between p1 and p3.\n */\nexport const checkForCollinearPoints = (p1: Point, p2: Point, p3: Point): boolean =>\n  (p1.y - p2.y) * (p1.x - p3.x) === (p1.y - p3.y) * (p1.x - p2.x);\n","import {\n  checkForCollinearPoints,\n  getDistanceBetween,\n  moveTo,\n  Point,\n} from './math.helpers';\n\nexport const buildLinearPath = (data: Point[]) =>\n  data.reduce((path, point, index) => {\n    // The very first instruction needs to be a \"move\".\n    // The rest will be a \"line\".\n    const isFirstInstruction = index === 0;\n    const instruction = isFirstInstruction ? 'M' : 'L';\n\n    return `${path}${instruction} ${point.x},${point.y}\\n`;\n  }, '');\n\nexport function buildSmoothPath(data: Point[], radius: number): string {\n  const [firstPoint, ...otherPoints] = data;\n\n  return otherPoints.reduce((path, point, index) => {\n    const next = otherPoints[index + 1];\n    const prev = otherPoints[index - 1] || firstPoint;\n\n    const isCollinear = next && checkForCollinearPoints(prev, point, next);\n\n    if (!next || isCollinear) {\n      // The very last line in the sequence can just be a regular line.\n      return `${path}\\nL ${point.x},${point.y}`;\n    }\n\n    const distanceFromPrev = getDistanceBetween(prev, point);\n    const distanceFromNext = getDistanceBetween(next, point);\n    const threshold = Math.min(distanceFromPrev, distanceFromNext);\n\n    const isTooCloseForRadius = threshold / 2 < radius;\n\n    const radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;\n\n    const before = moveTo(prev, point, radiusForPoint);\n    const after = moveTo(next, point, radiusForPoint);\n\n    return [\n      path,\n      `L ${before.x},${before.y}`,\n      `S ${point.x},${point.y} ${after.x},${after.y}`,\n    ].join('\\n');\n  }, `M ${firstPoint.x},${firstPoint.y}`);\n}\n","export const generateId = () => Math.round(Math.random() * Math.pow(10, 16));\n","import { normalize } from '../helpers/math.helpers';\n\nexport function normalizeDataset(\n  data: number[],\n  minX: number,\n  maxX: number,\n  minY: number,\n  maxY: number,\n): Array<{ x: number; y: number }> {\n  // For the X axis, we want to normalize it based on its index in the array.\n  // For the Y axis, we want to normalize it based on the element's value.\n  //\n  // X axis is easy: just evenly-space each item in the array.\n  // For the Y axis, we first need to find the min and max of our array,\n  // and then normalize those values between 0 and 1.\n  const boundariesX = { min: 0, max: data.length - 1 };\n  const boundariesY = { min: Math.min(...data), max: Math.max(...data) };\n\n  const normalizedData = data.map((point, index) => ({\n    x: normalize(index, boundariesX.min, boundariesX.max, minX, maxX),\n    y: normalize(point, boundariesY.min, boundariesY.max, minY, maxY),\n  }));\n\n  // According to the SVG spec, paths with a height/width of `0` can't have\n  // linear gradients applied. This means that our lines are invisible when\n  // the dataset is flat (eg. [0, 0, 0, 0]).\n  //\n  // The hacky solution is to apply a very slight offset to the first point of\n  // the dataset. As ugly as it is, it's the best solution we can find (there\n  // are ways within the SVG spec of changing it, but not without causing\n  // breaking changes).\n  if (boundariesY.min === boundariesY.max) {\n    normalizedData[0].y += 0.0001;\n  }\n\n  return normalizedData;\n}\n","import { animate, keyframes, state, style, transition, trigger } from '@angular/animations';\nimport { Component, ElementRef, Input, OnChanges, ViewChild } from '@angular/core';\n\nimport { buildLinearPath, buildSmoothPath } from '../helpers/DOM.helpers';\nimport { normalize } from '../helpers/math.helpers';\nimport { generateId } from '../helpers/misc.helpers';\nimport { normalizeDataset } from './trend.helpers';\n\n@Component({\n  selector: 'ngx-trend',\n  template: `\n    <svg\n      *ngIf=\"data && data.length >= 2\"\n      [attr.width]=\"svgWidth\"\n      [attr.height]=\"svgHeight\"\n      [attr.stroke]=\"stroke\"\n      [attr.stroke-width]=\"strokeWidth\"\n      [attr.stroke-linecap]=\"strokeLinecap\"\n      [attr.viewBox]=\"viewBox\"\n      [attr.preserveAspectRatio]=\"preserveAspectRatio\"\n    >\n      <defs *ngIf=\"gradient && gradient.length\">\n        <linearGradient [attr.id]=\"gradientId\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n          <stop\n            *ngFor=\"let g of gradientTrimmed\"\n            [attr.key]=\"g.idx\"\n            [attr.offset]=\"g.offset\"\n            [attr.stop-color]=\"g.stopColor\"\n          />\n        </linearGradient>\n      </defs>\n      <path\n        fill=\"none\"\n        #pathEl\n        [attr.stroke]=\"pathStroke\"\n        [attr.d]=\"d\"\n        [@pathAnimaiton]=\"{\n          value: animationState,\n          params: {\n            autoDrawDuration: autoDrawDuration,\n            autoDrawEasing: autoDrawEasing,\n            lineLength: lineLength\n          }\n        }\"\n      />\n    </svg>\n  `,\n  animations: [\n    trigger('pathAnimaiton', [\n      state('inactive', style({ display: 'none' })),\n      transition('* => active', [\n        style({ display: 'initial' }),\n        // We do the animation using the dash array/offset trick\n        // https://css-tricks.com/svg-line-animation-works/\n        animate(\n          '{{ autoDrawDuration }}ms {{ autoDrawEasing }}',\n          keyframes([\n            style({\n              'stroke-dasharray': '{{ lineLength }}px',\n              'stroke-dashoffset': '{{ lineLength }}px',\n            }),\n            style({\n              'stroke-dasharray': '{{ lineLength }}px',\n              'stroke-dashoffset': 0,\n            }),\n          ]),\n        ),\n        // One unfortunate side-effect of the auto-draw is that the line is\n        // actually 1 big dash, the same length as the line itself. If the\n        // line length changes (eg. radius change, new data), that dash won't\n        // be the same length anymore. We can fix that by removing those\n        // properties once the auto-draw is completed.\n        style({\n          'stroke-dashoffset': '',\n          'stroke-dasharray': '',\n        }),\n      ]),\n    ]),\n  ],\n})\nexport class TrendComponent implements OnChanges {\n  id: number;\n  @Input() data?: Array<(number | { value: number })>;\n  @Input() smooth?: boolean;\n  @Input() autoDraw = false;\n  @Input() autoDrawDuration = 2000;\n  @Input() autoDrawEasing = 'ease';\n  @Input() width?: number;\n  @Input() height?: number;\n  @Input() padding = 8;\n  @Input() radius = 10;\n  @Input() stroke = 'black';\n  @Input() strokeLinecap = '';\n  @Input() strokeWidth = 1;\n  @Input() gradient: string[] = [];\n  @Input() preserveAspectRatio?: string;\n  @Input() svgHeight: string | number = '25%';\n  @Input() svgWidth: string | number = '100%';\n  @ViewChild('pathEl') pathEl!: ElementRef;\n  gradientTrimmed!: Array<{ idx: number; stopColor: string; offset: number }>;\n  d: any;\n  viewBox!: string;\n  pathStroke: any;\n  gradientId: string;\n  lineLength!: number;\n  animationState = '';\n\n  constructor() {\n    this.id = generateId();\n    this.gradientId = `ngx-trend-vertical-gradient-${this.id}`;\n  }\n  ngOnChanges(): void {\n    // We need at least 2 points to draw a graph.\n    if (!this.data || this.data.length < 2) {\n      return;\n    }\n\n    // `data` can either be an array of numbers:\n    // [1, 2, 3]\n    // or, an array of objects containing a value:\n    // [{ value: 1 }, { value: 2 }, { value: 3 }]\n    //\n    // For now, we're just going to convert the second form to the first.\n    // Later on, if/when we support tooltips, we may adjust.\n    const plainValues = this.data.map(point => {\n      if (typeof point === 'number') {\n        return point;\n      }\n      return point.value;\n    });\n\n    // Our viewbox needs to be in absolute units, so we'll default to 300x75\n    // Our SVG can be a %, though; this is what makes it scalable.\n    // By defaulting to percentages, the SVG will grow to fill its parent\n    // container, preserving a 1/4 aspect ratio.\n    const viewBoxWidth = this.width || 300;\n    const viewBoxHeight = this.height || 75;\n    this.svgWidth = this.width || '100%';\n    this.svgHeight = this.height || '25%';\n    this.viewBox = `0 0 ${viewBoxWidth} ${viewBoxHeight}`;\n    const root = location.href.split(location.hash || '#')[0];\n    this.pathStroke =\n      this.gradient && this.gradient.length ? `url('${root}#${this.gradientId}')` : undefined;\n\n    this.gradientTrimmed = this.gradient\n      .slice()\n      .reverse()\n      .map((val, idx) => {\n        return {\n          idx,\n          stopColor: val,\n          offset: normalize(idx, 0, this.gradient.length - 1 || 1),\n        };\n      });\n\n    const normalizedValues = normalizeDataset(\n      plainValues,\n      this.padding,\n      viewBoxWidth - this.padding,\n      // NOTE: Because SVGs are indexed from the top left, but most data is\n      // indexed from the bottom left, we're inverting the Y min/max.\n      viewBoxHeight - this.padding,\n      this.padding,\n    );\n\n    if (this.autoDraw && this.animationState !== 'active') {\n      this.animationState = 'inactive';\n      setTimeout(() => {\n        this.lineLength = this.pathEl.nativeElement.getTotalLength();\n        this.animationState = 'active';\n      });\n    }\n\n    this.d = this.smooth\n      ? buildSmoothPath(normalizedValues, this.radius)\n      : buildLinearPath(normalizedValues);\n  }\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\n\nimport { TrendComponent } from './trend.component';\n\n@NgModule({\n  imports: [CommonModule],\n  exports: [TrendComponent],\n  declarations: [TrendComponent],\n})\nexport class TrendModule {\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"]},"metadata":{},"sourceType":"module"}